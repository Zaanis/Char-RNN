#include "ape.h"
#include "file.h"
#include "xmalloc.h"
#include "utils.h"

#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <strings.h>

/* http://www.personal.uni-jena.de/~pfk/mpp/sv8/apetag.html */

#define PREAMBLE_SIZE (8)
static const char preamble[PREAMBLE_SIZE] = { 'A', 'P', 'E', 'T', 'A', 'G', 'E', 'X' };

/* NOTE: not sizeof(struct ape_header)! */
#define HEADER_SIZE (32)

/* returns position of APE header or -1 if not found */
static int find_ape_tag_slow(int fd)
{
	char buf[4096];
	int match = 0;
	int pos = 0;

	/* seek to start of file */
	if (lseek(fd, pos, SEEK_SET) == -1)
		return -1;

	while (1) {
		int i, got = read(fd, buf, sizeof(buf));

		if (got == -1) {
			if (errno == EAGAIN || errno == EINTR)
				continue;
			break;
		}
		if (got == 0)
			break;

		for (i = 0; i < got; i++) {
			if (buf[i] != preamble[match]) {
				match = 0;
				continue;
			}

			match++;
			if (match == PREAMBLE_SIZE)
				return pos + i + 1 - PREAMBLE_SIZE;
		}
		pos += got;
	}
	return -1;
}

static int ape_parse_header(const char *buf, struct ape_header *h)
{
	if (memcmp(buf, preamble, PREAMBLE_SIZE))
		return 0;

	h->version = read_le32(buf + 8);
	h->size = read_le32(buf + 12);
	h->count = read_le32(buf + 16);
	h->flags = read_le32(buf + 20);
	return 1;
}

static int read_header(int fd, struct ape_header *h)
{
	char buf[HEADER_SIZE];

	if (read_all(fd, buf, sizeof(buf)) != sizeof(buf))
		return 0;

	return ape_parse_header(buf, h);
}

/* sets fd right after the header and returns 1 if found,
 * otherwise returns 0
 */
static int find_ape_tag(int fd, struct ape_header *h, int slow)
{
	int pos;

	if (lseek(fd, -HEADER_SIZE, SEEK_END) == -1)
		return 0;
	if (read_header(fd, h))
		return 1;

	/* try to skip ID3v1 tag at the end of the file */
	if (lseek(fd, -(HEADER_SIZE + 128), SEEK_END) == -1)
		return 0;
	if (read_header(fd, h))
		return 1;

	if (!slow)
		return 0;

	pos = find_ape_tag_slow(fd);
	if (pos == -1)
		return 0;
	if (lseek(fd, pos, SEEK_SET) == -1)
		return 0;
	return read_header(fd, h);
}

/*
 * All keys are ASCII and length is 2..255
 *
 * UTF-8:	Artist, Album, Title, Genre
 * Integer:	Track (N or N/M)
 * Date:	Year (release), "Record Date"
 *
 * UTF-8 strings are NOT zero terminated.
 *
 * Also support "discnumber" (vorbis) and "disc" (non-standard)
 */
static int ape_parse_one(const char *buf, int size, char **keyp, char **valp)
{
	int pos = 0;

	while (size - pos > 8) {
		uint32_t val_len, flags;
		char *key, *val;
		int64_t max_key_len, key_len;

		val_len = read_le32(buf + pos); pos += 4;
		flags = read_le32(buf + pos); pos += 4;

		max_key_len = size - pos - (int64_t)val_len - 1;
		if (max_key_len < 0) {
			/* corrupt */
			break;
		}

		for (key_len = 0; key_len < max_key_len && buf[pos + key_len]; key_len++)
			; /* nothing */
		if (buf[pos + key_len]) {
			/* corrupt */
			break;
		}

		if (!AF_IS_UTF8(flags)) {
			/* ignore binary data */
			pos += key_len + 1 + val_len;
			continue;
		}

		key = xstrdup(buf + pos);
		pos += key_len + 1;

		/* should not be NUL-terminated */
		val = xstrndup(buf + pos, val_len);
		pos += val_len;

		/* could be moved to comment.c but I don't think anyone else would use it */
		if (!strcasecmp(key, "record date") || !strcasecmp(key, "year")) {
			free(key);
			key = xstrdup("date");
		}

		if (!strcasecmp(key, "date")) {
			/* Date format
			 *
			 * 1999-08-11 12:34:56
			 * 1999-08-11 12:34
			 * 1999-08-11
			 * 1999-08
			 * 1999
			 * 1999-W34	(week 34, totally crazy)
			 *
			 * convert to year, pl.c supports only years anyways
			 *
			 * FIXME: which one is the most common tag (year or record date)?
			 */
			if (strlen(val) > 4)
				val[4] = 0;
		}

		*keyp = key;
		*valp = val;
		return pos;
	}
	return -1;
}

/* return the number of comments, or -1 */
int ape_read_tags(struct apetag *ape, int fd, int slow)
{
	struct ape_header *h = &ape->header;
	int rc = -1;
	off_t old_pos;

	/* save position */
	old_pos = lseek(fd, 0, SEEK_CUR);

	if (!find_ape_tag(fd, h, slow))
		goto fail;

	if (AF_IS_FOOTER(h->flags)) {
		/* seek back right after the header */
		if (lseek(fd, -((int)h->size), SEEK_CUR) == -1)
			goto fail;
	}

	/* ignore insane tags */
	if (h->size > 1024 * 1024)
		goto fail;

	ape->buf = xnew(char, h->size);
	if (read_all(fd, ape->buf, h->size) != h->size)
		goto fail;

	rc = h->count;

fail:
	lseek(fd, old_pos, SEEK_SET);
	return rc;
}

/* returned key-name must be free'd */
char *ape_get_comment(struct apetag *ape, char **val)
{
	struct ape_header *h = &ape->header;
	char *key;
	int rc;

	if (ape->pos >= h->size)
		return NULL;

	rc = ape_parse_one(ape->buf + ape->pos, h->size - ape->pos, &key, val);
	if (rc < 0)
		return NULL;
	ape->pos += rc;

	return key;
}
#include "browser.h"
#include "load_dir.h"
#include "cmus.h"
#include "xmalloc.h"
#include "ui_curses.h"
#include "file.h"
#include "misc.h"
#include "options.h"
#include "uchar.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <string.h>
#include <errno.h>
#include <sys/mman.h>

struct window *browser_win;
struct searchable *browser_searchable;
char *browser_dir;

static LIST_HEAD(browser_head);

static inline void browser_entry_to_iter(struct browser_entry *e, struct iter *iter)
{
	iter->data0 = &browser_head;
	iter->data1 = e;
	iter->data2 = NULL;
}

/* filter out names starting with '.' except '..' */
static int normal_filter(const char *name, const struct stat *s)
{
	if (name[0] == '.') {
		if (name[1] == '.' && name[2] == 0)
			return 1;
		return 0;
	}
	if (S_ISDIR(s->st_mode))
		return 1;
	return cmus_is_supported(name);
}

/* filter out '.' */
static int hidden_filter(const char *name, const struct stat *s)
{
	if (name[0] == '.' && name[1] == 0)
		return 0;
	return 1;
}

/* only works for BROWSER_ENTRY_DIR and BROWSER_ENTRY_FILE */
static int entry_cmp(const struct browser_entry *a, const struct browser_entry *b)
{
	if (a->type == BROWSER_ENTRY_DIR) {
		if (b->type == BROWSER_ENTRY_FILE)
			return -1;
		if (!strcmp(a->name, "../"))
			return -1;
		if (!strcmp(b->name, "../"))
			return 1;
		return strcmp(a->name, b->name);
	}
	if (b->type == BROWSER_ENTRY_DIR)
		return 1;
	return strcmp(a->name, b->name);
}

static char *fullname(const char *path, const char *name)
{
	int l1, l2;
	char *full;

	l1 = strlen(path);
	l2 = strlen(name);
	if (path[l1 - 1] == '/')
		l1--;
	full = xnew(char, l1 + 1 + l2 + 1);
	memcpy(full, path, l1);
	full[l1] = '/';
	memcpy(full + l1 + 1, name, l2 + 1);
	return full;
}

static void free_browser_list(void)
{
	struct list_head *item;

	item = browser_head.next;
	while (item != &browser_head) {
		struct list_head *next = item->next;
		struct browser_entry *entry;

		entry = list_entry(item, struct browser_entry, node);
		free(entry);
		item = next;
	}
	list_init(&browser_head);
}

static int add_pl_line(void *data, const char *line)
{
	struct browser_entry *e;
	int name_size = strlen(line) + 1;

	e = xmalloc(sizeof(struct browser_entry) + name_size);
	memcpy(e->name, line, name_size);
	e->type = BROWSER_ENTRY_PLLINE;
	list_add_tail(&e->node, &browser_head);
	return 0;
}

static int do_browser_load(const char *name)
{
	struct stat st;

	if (stat(name, &st))
		return -1;

	if (S_ISREG(st.st_mode) && cmus_is_playlist(name)) {
		char *buf;
		ssize_t size;

		buf = mmap_file(name, &size);
		if (size == -1)
			return -1;

		free_browser_list();

		if (buf) {
			struct browser_entry *parent_dir_e = xmalloc(sizeof(struct browser_entry) + 4);
			strcpy(parent_dir_e->name, "../");
			parent_dir_e->type = BROWSER_ENTRY_DIR;
			list_add_tail(&parent_dir_e->node, &browser_head);

			cmus_playlist_for_each(buf, size, 0, add_pl_line, NULL);
			munmap(buf, size);
		}
	} else if (S_ISDIR(st.st_mode)) {
		int (*filter)(const char *, const struct stat *) = normal_filter;
		struct directory dir;
		const char *str;
		int root = !strcmp(name, "/");

		if (show_hidden)
			filter = hidden_filter;

		if (dir_open(&dir, name))
			return -1;

		free_browser_list();
		while ((str = dir_read(&dir))) {
			struct browser_entry *e;
			struct list_head *item;
			int len;

			if (!filter(str, &dir.st))
				continue;

			/* ignore .. if we are in the root dir */
			if (root && !strcmp(str, ".."))
				continue;

			len = strlen(str);
			e = xmalloc(sizeof(struct browser_entry) + len + 2);
			e->type = BROWSER_ENTRY_FILE;
			memcpy(e->name, str, len);
			if (S_ISDIR(dir.st.st_mode)) {
				e->type = BROWSER_ENTRY_DIR;
				e->name[len++] = '/';
			}
			e->name[len] = 0;

			item = browser_head.prev;
			while (item != &browser_head) {
				struct browser_entry *other;

				other = container_of(item, struct browser_entry, node);
				if (entry_cmp(e, other) >= 0)
					break;
				item = item->prev;
			}
			/* add after item */
			list_add(&e->node, item);
		}
		dir_close(&dir);

		/* try to update currect working directory */
		if (chdir(name))
			return -1;
	} else {
		errno = ENOTDIR;
		return -1;
	}
	return 0;
}

static int browser_load(const char *name)
{
	int rc;

	rc = do_browser_load(name);
	if (rc)
		return rc;

	window_set_contents(browser_win, &browser_head);
	free(browser_dir);
	browser_dir = xstrdup(name);
	return 0;
}

static GENERIC_ITER_PREV(browser_get_prev, struct browser_entry, node)
static GENERIC_ITER_NEXT(browser_get_next, struct browser_entry, node)

static int browser_search_get_current(void *data, struct iter *iter)
{
	return window_get_sel(browser_win, iter);
}

static int browser_search_matches(void *data, struct iter *iter, const char *text)
{
	char **words = get_words(text);
	int matched = 0;

	if (words[0] != NULL) {
		struct browser_entry *e;
		int i;

		e = iter_to_browser_entry(iter);
		for (i = 0; ; i++) {
			if (words[i] == NULL) {
				window_set_sel(browser_win, iter);
				matched = 1;
				break;
			}
			if (u_strcasestr_filename(e->name, words[i]) == NULL)
				break;
		}
	}
	free_str_array(words);
	return matched;
}

static const struct searchable_ops browser_search_ops = {
	.get_prev = browser_get_prev,
	.get_next = browser_get_next,
	.get_current = browser_search_get_current,
	.matches = browser_search_matches
};

void browser_init(void)
{
	struct iter iter;
	char cwd[1024];
	char *dir;

	if (getcwd(cwd, sizeof(cwd)) == NULL) {
		dir = xstrdup("/");
	} else {
		dir = xstrdup(cwd);
	}
	if (do_browser_load(dir)) {
		free(dir);
		do_browser_load("/");
		browser_dir = xstrdup("/");
	} else {
		browser_dir = dir;
	}

	browser_win = window_new(browser_get_prev, browser_get_next);
	window_set_contents(browser_win, &browser_head);
	window_changed(browser_win);

	iter.data0 = &browser_head;
	iter.data1 = NULL;
	iter.data2 = NULL;
	browser_searchable = searchable_new(NULL, &iter, &browser_search_ops);
}

void browser_exit(void)
{
	searchable_free(browser_searchable);
	free_browser_list();
	window_free(browser_win);
	free(browser_dir);
}

int browser_chdir(const char *dir)
{
	if (browser_load(dir)) {
	}
	return 0;
}

void browser_up(void)
{
	char *new, *ptr, *pos;
	struct browser_entry *e;
	int len;

	if (strcmp(browser_dir, "/") == 0)
		return;

	ptr = strrchr(browser_dir, '/');
	if (ptr == browser_dir) {
		new = xstrdup("/");
	} else {
		new = xstrndup(browser_dir, ptr - browser_dir);
	}

	/* remember old position */
	ptr++;
	len = strlen(ptr);
	pos = xstrdup(ptr);

	errno = 0;
	if (browser_load(new)) {
		if (errno == ENOENT) {
			free(pos);
			free(browser_dir);
			browser_dir = new;
			browser_up();
			return;
		}
		error_msg("could not open directory '%s': %s\n", new, strerror(errno));
		free(new);
		free(pos);
		return;
	}
	free(new);

	/* select old position */
	list_for_each_entry(e, &browser_head, node) {
		if (strncmp(e->name, pos, len) == 0 &&
		    (e->name[len] == '/' || e->name[len] == '\0')) {
			struct iter iter;

			browser_entry_to_iter(e, &iter);
			window_set_sel(browser_win, &iter);
			break;
		}
	}
	free(pos);
}

static void browser_cd(const char *dir)
{
	char *new;
	int len;

	if (strcmp(dir, "../") == 0) {
		browser_up();
		return;
	}

	new = fullname(browser_dir, dir);
	len = strlen(new);
	if (new[len - 1] == '/')
		new[len - 1] = 0;
	if (browser_load(new))
		error_msg("could not open directory '%s': %s\n", dir, strerror(errno));
	free(new);
}

static void browser_cd_playlist(const char *filename)
{
	if (browser_load(filename))
		error_msg("could not read playlist '%s': %s\n", filename, strerror(errno));
}

void browser_enter(void)
{
	struct browser_entry *e;
	struct iter sel;
	int len;

	if (!window_get_sel(browser_win, &sel))
		return;
	e = iter_to_browser_entry(&sel);
	len = strlen(e->name);
	if (len == 0)
		return;
	if (e->type == BROWSER_ENTRY_DIR) {
		browser_cd(e->name);
	} else {
		if (e->type == BROWSER_ENTRY_PLLINE) {
			cmus_play_file(e->name);
		} else {
			char *filename;

			filename = fullname(browser_dir, e->name);
			if (cmus_is_playlist(filename)) {
				browser_cd_playlist(filename);
			} else {
				cmus_play_file(filename);
			}
			free(filename);
		}
	}
}

char *browser_get_sel(void)
{
	struct browser_entry *e;
	struct iter sel;

	if (!window_get_sel(browser_win, &sel))
		return NULL;

	e = iter_to_browser_entry(&sel);
	if (e->type == BROWSER_ENTRY_PLLINE)
		return xstrdup(e->name);

	return fullname(browser_dir, e->name);
}

void browser_delete(void)
{
	struct browser_entry *e;
	struct iter sel;
	int len;

	if (!window_get_sel(browser_win, &sel))
		return;
	e = iter_to_browser_entry(&sel);
	len = strlen(e->name);
	if (len == 0)
		return;
	if (e->type == BROWSER_ENTRY_FILE) {
		char *name;

		name = fullname(browser_dir, e->name);
		if (yes_no_query("Delete file '%s'? [y/N]", e->name) == UI_QUERY_ANSWER_YES) {
			if (unlink(name) == -1) {
				error_msg("deleting '%s': %s", e->name, strerror(errno));
			} else {
				window_row_vanishes(browser_win, &sel);
				list_del(&e->node);
				free(e);
			}
		}
		free(name);
	}
}

void browser_reload(void)
{
	char *tmp = xstrdup(browser_dir);
	char *sel = NULL;
	struct iter iter;
	struct browser_entry *e;

	/* remember selection */
	if (window_get_sel(browser_win, &iter)) {
		e = iter_to_browser_entry(&iter);
		sel = xstrdup(e->name);
	}

	/* have to use tmp  */
	if (browser_load(tmp)) {
		error_msg("could not update contents '%s': %s\n", tmp, strerror(errno));
		free(tmp);
		free(sel);
		return;
	}

	if (sel) {
		/* set selection */
		list_for_each_entry(e, &browser_head, node) {
			if (strcmp(e->name, sel) == 0) {
				browser_entry_to_iter(e, &iter);
				window_set_sel(browser_win, &iter);
				break;
			}
		}
	}

	free(tmp);
	free(sel);
}
#include "buffer.h"
#include "xmalloc.h"
#include "locking.h"
#include "debug.h"

/*
 * chunk can be accessed by either consumer OR producer, not both at same time
 * -> no need to lock
 */
struct chunk {
	char data[CHUNK_SIZE];

	/* index to data, first filled byte */
	unsigned int l;

	/* index to data, last filled byte + 1
	 *
	 * there are h - l bytes available (filled)
	 */
	unsigned int h : 31;

	/* if chunk is marked filled it can only be accessed by consumer
	 * otherwise only producer is allowed to access the chunk
	 */
	unsigned int filled : 1;
};

unsigned int buffer_nr_chunks;

static pthread_mutex_t buffer_mutex = CMUS_MUTEX_INITIALIZER;
static struct chunk *buffer_chunks = NULL;
static unsigned int buffer_ridx;
static unsigned int buffer_widx;

void buffer_init(void)
{
	free(buffer_chunks);
	buffer_chunks = xnew(struct chunk, buffer_nr_chunks);
	buffer_reset();
}

void buffer_free(void)
{
	free(buffer_chunks);
}

/*
 * @pos: returned pointer to available data
 *
 * Returns number of bytes available at @pos
 *
 * After reading bytes mark them consumed calling buffer_consume().
 */
int buffer_get_rpos(char **pos)
{
	struct chunk *c;
	int size = 0;

	cmus_mutex_lock(&buffer_mutex);
	c = &buffer_chunks[buffer_ridx];
	if (c->filled) {
		size = c->h - c->l;
		*pos = c->data + c->l;
	}
	cmus_mutex_unlock(&buffer_mutex);

	return size;
}

/*
 * @pos: pointer to buffer position where data can be written
 *
 * Returns number of bytes can be written to @pos.  If the return value is
 * non-zero it is guaranteed to be >= 1024.
 *
 * After writing bytes mark them filled calling buffer_fill().
 */
int buffer_get_wpos(char **pos)
{
	struct chunk *c;
	int size = 0;

	cmus_mutex_lock(&buffer_mutex);
	c = &buffer_chunks[buffer_widx];
	if (!c->filled) {
		size = CHUNK_SIZE - c->h;
		*pos = c->data + c->h;
	}
	cmus_mutex_unlock(&buffer_mutex);

	return size;
}

void buffer_consume(int count)
{
	struct chunk *c;

	BUG_ON(count < 0);
	cmus_mutex_lock(&buffer_mutex);
	c = &buffer_chunks[buffer_ridx];
	BUG_ON(!c->filled);
	c->l += count;
	if (c->l == c->h) {
		c->l = 0;
		c->h = 0;
		c->filled = 0;
		buffer_ridx++;
		buffer_ridx %= buffer_nr_chunks;
	}
	cmus_mutex_unlock(&buffer_mutex);
}

/* chunk is marked filled if free bytes < 1024 or count == 0 */
int buffer_fill(int count)
{
	struct chunk *c;
	int filled = 0;

	cmus_mutex_lock(&buffer_mutex);
	c = &buffer_chunks[buffer_widx];
	BUG_ON(c->filled);
	c->h += count;

	if (CHUNK_SIZE - c->h < 1024 || (count == 0 && c->h > 0)) {
		c->filled = 1;
		buffer_widx++;
		buffer_widx %= buffer_nr_chunks;
		filled = 1;
	}

	cmus_mutex_unlock(&buffer_mutex);
	return filled;
}

void buffer_reset(void)
{
	int i;

	cmus_mutex_lock(&buffer_mutex);
	buffer_ridx = 0;
	buffer_widx = 0;
	for (i = 0; i < buffer_nr_chunks; i++) {
		buffer_chunks[i].l = 0;
		buffer_chunks[i].h = 0;
		buffer_chunks[i].filled = 0;
	}
	cmus_mutex_unlock(&buffer_mutex);
}

int buffer_get_filled_chunks(void)
{
	int c;

	cmus_mutex_lock(&buffer_mutex);
	if (buffer_ridx < buffer_widx) {
		/*
		 * |__##########____|
		 *    r         w
		 *
		 * |############____|
		 *  r           w
		 */
		c = buffer_widx - buffer_ridx;
	} else if (buffer_ridx > buffer_widx) {
		/*
		 * |#######______###|
		 *         w     r
		 *
		 * |_____________###|
		 *  w            r
		 */
		c = buffer_nr_chunks - buffer_ridx + buffer_widx;
	} else {
		/*
		 * |################|
		 *     r
		 *     w
		 *
		 * |________________|
		 *     r
		 *     w
		 */
		if (buffer_chunks[buffer_ridx].filled) {
			c = buffer_nr_chunks;
		} else {
			c = 0;
		}
	}
	cmus_mutex_unlock(&buffer_mutex);
	return c;
}
#include "cache.h"
#include "misc.h"
#include "file.h"
#include "input.h"
#include "track_info.h"
#include "utils.h"
#include "xmalloc.h"
#include "xstrjoin.h"
#include "gbuf.h"
#include "options.h"

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/mman.h>

#define CACHE_VERSION   0x0d

#define CACHE_64_BIT	0x01
#define CACHE_BE	0x02

#define CACHE_RESERVED_PATTERN  	0xff

#define CACHE_ENTRY_USED_SIZE		28
#define CACHE_ENTRY_RESERVED_SIZE	52
#define CACHE_ENTRY_TOTAL_SIZE	(CACHE_ENTRY_RESERVED_SIZE + CACHE_ENTRY_USED_SIZE)

// Cmus Track Cache version X + 4 bytes flags
static char cache_header[8] = "CTC\0\0\0\0\0";

// host byte order
// mtime is either 32 or 64 bits
struct cache_entry {
	// size of this struct including size itself
	uint32_t size;

	int32_t play_count;
	int64_t mtime;
	int32_t duration;
	int32_t bitrate;
	int32_t bpm;

	// when introducing new fields decrease the reserved space accordingly
	uint8_t _reserved[CACHE_ENTRY_RESERVED_SIZE];

	// filename, codec, codec_profile and N * (key, val)
	char strings[];
};

// make sure our mmap/sizeof-based code works
STATIC_ASSERT(CACHE_ENTRY_TOTAL_SIZE == sizeof(struct cache_entry));
STATIC_ASSERT(CACHE_ENTRY_TOTAL_SIZE == offsetof(struct cache_entry, strings));


#define ALIGN(size) (((size) + sizeof(long) - 1) & ~(sizeof(long) - 1))
#define HASH_SIZE 1023

static struct track_info *hash_table[HASH_SIZE];
static char *cache_filename;
static int total;

struct fifo_mutex cache_mutex = FIFO_MUTEX_INITIALIZER;


static void add_ti(struct track_info *ti, unsigned int hash)
{
	unsigned int pos = hash % HASH_SIZE;
	struct track_info *next = hash_table[pos];

	ti->next = next;
	hash_table[pos] = ti;
	total++;
}

static int valid_cache_entry(const struct cache_entry *e, unsigned int avail)
{
	unsigned int min_size = sizeof(*e);
	unsigned int str_size;
	int i, count;

	if (avail < min_size)
		return 0;

	if (e->size < min_size || e->size > avail)
		return 0;

	str_size = e->size - min_size;
	count = 0;
	for (i = 0; i < str_size; i++) {
		if (!e->strings[i])
			count++;
	}
	if (count % 2 == 0)
		return 0;
	if (e->strings[str_size - 1])
		return 0;
	return 1;
}

static struct track_info *cache_entry_to_ti(struct cache_entry *e)
{
	const char *strings = e->strings;
	struct track_info *ti = track_info_new(strings);
	struct keyval *kv;
	int str_size = e->size - sizeof(*e);
	int pos, i, count;

	ti->duration = e->duration;
	ti->bitrate = e->bitrate;
	ti->mtime = e->mtime;
	ti->play_count = e->play_count;
	ti->bpm = e->bpm;

	// count strings (filename + codec + codec_profile + key/val pairs)
	count = 0;
	for (i = 0; i < str_size; i++) {
		if (!strings[i])
			count++;
	}
	count = (count - 3) / 2;

	// NOTE: filename already copied by track_info_new()
	pos = strlen(strings) + 1;
	ti->codec = strings[pos] ? xstrdup(strings + pos) : NULL;
	pos += strlen(strings + pos) + 1;
	ti->codec_profile = strings[pos] ? xstrdup(strings + pos) : NULL;
	pos += strlen(strings + pos) + 1;
	kv = xnew(struct keyval, count + 1);
	for (i = 0; i < count; i++) {
		int size;

		size = strlen(strings + pos) + 1;
		kv[i].key = xstrdup(strings + pos);
		pos += size;

		size = strlen(strings + pos) + 1;
		kv[i].val = xstrdup(strings + pos);
		pos += size;
	}
	kv[i].key = NULL;
	kv[i].val = NULL;
	track_info_set_comments(ti, kv);
	return ti;
}

struct track_info *lookup_cache_entry(const char *filename, unsigned int hash)
{
	struct track_info *ti = hash_table[hash % HASH_SIZE];

	while (ti) {
		if (!strcmp(filename, ti->filename))
			return ti;
		ti = ti->next;
	}
	return NULL;
}

static void do_cache_remove_ti(struct track_info *ti, unsigned int hash)
{
	unsigned int pos = hash % HASH_SIZE;
	struct track_info *t = hash_table[pos];
	struct track_info *next, *prev = NULL;

	while (t) {
		next = t->next;
		if (t == ti) {
			if (prev) {
				prev->next = next;
			} else {
				hash_table[pos] = next;
			}
			total--;
			track_info_unref(ti);
			return;
		}
		prev = t;
		t = next;
	}
}

void cache_remove_ti(struct track_info *ti)
{
	do_cache_remove_ti(ti, hash_str(ti->filename));
}

static int read_cache(void)
{
	unsigned int size, offset = 0;
	struct stat st = {};
	char *buf;
	int fd;

	fd = open(cache_filename, O_RDONLY);
	if (fd < 0) {
		if (errno == ENOENT)
			return 0;
		return -1;
	}
	fstat(fd, &st);
	if (st.st_size < sizeof(cache_header))
		goto close;
	size = st.st_size;

	buf = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
	if (buf == MAP_FAILED) {
		close(fd);
		return -1;
	}

	if (memcmp(buf, cache_header, sizeof(cache_header)))
		goto corrupt;

	offset = sizeof(cache_header);
	while (offset < size) {
		struct cache_entry *e = (void *)(buf + offset);
		struct track_info *ti;

		if (!valid_cache_entry(e, size - offset))
			goto corrupt;

		ti = cache_entry_to_ti(e);
		add_ti(ti, hash_str(ti->filename));
		offset += ALIGN(e->size);
	}
	munmap(buf, size);
	close(fd);
	return 0;
corrupt:
	munmap(buf, size);
close:
	close(fd);
	// corrupt
	return -2;
}

int cache_init(void)
{
	unsigned int flags = 0;

#ifdef WORDS_BIGENDIAN
	flags |= CACHE_BE;
#endif
	if (sizeof(long) == 8)
		flags |= CACHE_64_BIT;

	cache_header[7] = flags & 0xff; flags >>= 8;
	cache_header[6] = flags & 0xff; flags >>= 8;
	cache_header[5] = flags & 0xff; flags >>= 8;
	cache_header[4] = flags & 0xff;

	/* assumed version */
	cache_header[3] = CACHE_VERSION;

	cache_filename = xstrjoin(cmus_config_dir, "/cache");
	return read_cache();
}

static int ti_filename_cmp(const void *a, const void *b)
{
	const struct track_info *ai = *(const struct track_info **)a;
	const struct track_info *bi = *(const struct track_info **)b;

	return strcmp(ai->filename, bi->filename);
}

static struct track_info **get_track_infos(bool reference)
{
	struct track_info **tis;
	int i, c;

	tis = xnew(struct track_info *, total);
	c = 0;
	for (i = 0; i < HASH_SIZE; i++) {
		struct track_info *ti = hash_table[i];

		while (ti) {
			if (reference)
				track_info_ref(ti);
			tis[c++] = ti;
			ti = ti->next;
		}
	}
	qsort(tis, total, sizeof(struct track_info *), ti_filename_cmp);
	return tis;
}

static void flush_buffer(int fd, struct gbuf *buf)
{
	if (buf->len) {
		write_all(fd, buf->buffer, buf->len);
		gbuf_clear(buf);
	}
}

static void write_ti(int fd, struct gbuf *buf, struct track_info *ti, unsigned int *offsetp)
{
	const struct keyval *kv = ti->comments;
	unsigned int offset = *offsetp;
	unsigned int pad;
	struct cache_entry e;
	int *len, alloc = 64, count, i;

	memset(e._reserved, CACHE_RESERVED_PATTERN, sizeof(e._reserved));

	count = 0;
	len = xnew(int, alloc);
	e.size = sizeof(e);
	e.duration = ti->duration;
	e.bitrate = ti->bitrate;
	e.mtime = ti->mtime;
	e.play_count = ti->play_count;
	e.bpm = ti->bpm;
	len[count] = strlen(ti->filename) + 1;
	e.size += len[count++];
	len[count] = (ti->codec ? strlen(ti->codec) : 0) + 1;
	e.size += len[count++];
	len[count] = (ti->codec_profile ? strlen(ti->codec_profile) : 0) + 1;
	e.size += len[count++];
	for (i = 0; kv[i].key; i++) {
		if (count + 2 > alloc) {
			alloc *= 2;
			len = xrenew(int, len, alloc);
		}
		len[count] = strlen(kv[i].key) + 1;
		e.size += len[count++];
		len[count] = strlen(kv[i].val) + 1;
		e.size += len[count++];
	}

	pad = ALIGN(offset) - offset;
	if (gbuf_avail(buf) < pad + e.size)
		flush_buffer(fd, buf);

	count = 0;
	if (pad)
		gbuf_set(buf, 0, pad);
	gbuf_add_bytes(buf, &e, sizeof(e));
	gbuf_add_bytes(buf, ti->filename, len[count++]);
	gbuf_add_bytes(buf, ti->codec ? ti->codec : "", len[count++]);
	gbuf_add_bytes(buf, ti->codec_profile ? ti->codec_profile : "", len[count++]);
	for (i = 0; kv[i].key; i++) {
		gbuf_add_bytes(buf, kv[i].key, len[count++]);
		gbuf_add_bytes(buf, kv[i].val, len[count++]);
	}

	free(len);
	*offsetp = offset + pad + e.size;
}

int cache_close(void)
{
	GBUF(buf);
	struct track_info **tis;
	unsigned int offset;
	int i, fd, rc;
	char *tmp;

	tmp = xstrjoin(cmus_config_dir, "/cache.tmp");
	fd = open(tmp, O_WRONLY | O_CREAT | O_TRUNC, 0666);
	if (fd < 0) {
		free(tmp);
		return -1;
	}

	tis = get_track_infos(false);

	gbuf_grow(&buf, 64 * 1024 - 1);
	gbuf_add_bytes(&buf, cache_header, sizeof(cache_header));
	offset = sizeof(cache_header);
	for (i = 0; i < total; i++)
		write_ti(fd, &buf, tis[i], &offset);
	flush_buffer(fd, &buf);
	gbuf_free(&buf);
	free(tis);

	close(fd);
	rc = rename(tmp, cache_filename);
	free(tmp);
	return rc;
}

static struct track_info *ip_get_ti(const char *filename)
{
	struct track_info *ti = NULL;
	struct input_plugin *ip;
	struct keyval *comments;
	int rc;

	ip = ip_new(filename);
	rc = ip_open(ip);
	if (rc) {
		ip_delete(ip);
		return NULL;
	}

	rc = ip_read_comments(ip, &comments);
	if (!rc) {
		ti = track_info_new(filename);
		track_info_set_comments(ti, comments);
		ti->duration = ip_duration(ip);
		ti->bitrate = ip_bitrate(ip);
		ti->codec = ip_codec(ip);
		ti->codec_profile = ip_codec_profile(ip);
		ti->mtime = ip_is_remote(ip) ? -1 : file_get_mtime(filename);
	}
	ip_delete(ip);
	return ti;
}

struct track_info *cache_get_ti(const char *filename, int force)
{
	unsigned int hash = hash_str(filename);
	struct track_info *ti;
	int reload = 0;

	ti = lookup_cache_entry(filename, hash);
	if (ti) {
		if ((!skip_track_info && ti->duration == 0 && !is_http_url(filename)) || force){
			do_cache_remove_ti(ti, hash);
			ti = NULL;
			reload = 1;
		}
	}
	if (!ti) {
		if (skip_track_info && !reload && !force) {
			struct growing_keyvals c = {NULL, 0, 0};

			ti = track_info_new(filename);

			keyvals_terminate(&c);
			track_info_set_comments(ti, c.keyvals);

			ti->duration = 0;
		} else {
		       	ti = ip_get_ti(filename);
		}
		if (!ti)
			return NULL;
		add_ti(ti, hash);
	}
	track_info_ref(ti);
	return ti;
}

struct track_info **cache_refresh(int *count, int force)
{
	struct track_info **tis = get_track_infos(true);
	int i, n = total;

	for (i = 0; i < n; i++) {
		unsigned int hash;
		struct track_info *ti = tis[i];
		struct stat st;
		int rc = 0;

		cache_yield();

		/*
		 * If no-one else has reference to tis[i] then it is set to NULL
		 * otherwise:
		 *
		 * unchanged: tis[i] = NULL
		 * deleted:   tis[i]->next = NULL
		 * changed:   tis[i]->next = new
		 */

		if (!is_url(ti->filename)) {
			rc = stat(ti->filename, &st);
			if (!rc && !force && ti->mtime == st.st_mtime) {
				// unchanged
				track_info_unref(ti);
				tis[i] = NULL;
				continue;
			}
		}

		hash = hash_str(ti->filename);
		do_cache_remove_ti(ti, hash);

		if (!rc) {
			// changed
			struct track_info *new_ti;

			// clear cache-only entries
			if (force && track_info_unique_ref(ti)) {
				track_info_unref(ti);
				tis[i] = NULL;
				continue;
			}

			new_ti = ip_get_ti(ti->filename);
			if (new_ti) {
				add_ti(new_ti, hash);

				if (track_info_unique_ref(ti)) {
					track_info_unref(ti);
					tis[i] = NULL;
				} else {
					track_info_ref(new_ti);
					ti->next = new_ti;
				}
				continue;
			}
			// treat as deleted
		}

		// deleted
		if (track_info_unique_ref(ti)) {
			track_info_unref(ti);
			tis[i] = NULL;
		} else {
			ti->next = NULL;
		}
	}
	*count = n;
	return tis;
}
#include "channelmap.h"
#include "utils.h"

void channel_map_init_waveex(int channels, unsigned int mask, channel_position_t *map)
{
	/* http://www.microsoft.com/whdc/device/audio/multichaud.mspx#EMLAC */
	const channel_position_t channel_map_waveex[] = {
		CHANNEL_POSITION_FRONT_LEFT,
		CHANNEL_POSITION_FRONT_RIGHT,
		CHANNEL_POSITION_FRONT_CENTER,
		CHANNEL_POSITION_LFE,
		CHANNEL_POSITION_REAR_LEFT,
		CHANNEL_POSITION_REAR_RIGHT,
		CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
		CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,
		CHANNEL_POSITION_REAR_CENTER,
		CHANNEL_POSITION_SIDE_LEFT,
		CHANNEL_POSITION_SIDE_RIGHT,
		CHANNEL_POSITION_TOP_CENTER,
		CHANNEL_POSITION_TOP_FRONT_LEFT,
		CHANNEL_POSITION_TOP_FRONT_CENTER,
		CHANNEL_POSITION_TOP_FRONT_RIGHT,
		CHANNEL_POSITION_TOP_REAR_LEFT,
		CHANNEL_POSITION_TOP_REAR_CENTER,
		CHANNEL_POSITION_TOP_REAR_RIGHT
	};

	if (channels == 1) {
		map[0] = CHANNEL_POSITION_MONO;
	} else if (channels > 1 && channels < N_ELEMENTS(channel_map_waveex)) {
		int i, j = 0;

		if (!mask)
			mask = (1 << channels) - 1;

		for (i = 0; i < N_ELEMENTS(channel_map_waveex); i++) {
			if (mask & (1 << i))
				map[j++] = channel_map_waveex[i];
		}
		if (j != channels)
			map[0] = CHANNEL_POSITION_INVALID;
	} else {
		map[0] = CHANNEL_POSITION_INVALID;
	}
}
#include "cmdline.h"
#include "uchar.h"
#include "xmalloc.h"

struct cmdline cmdline;

const char cmdline_word_delimiters[]     = " ";
const char cmdline_filename_delimiters[] = "/";

void cmdline_init(void)
{
	cmdline.blen = 0;
	cmdline.clen = 0;
	cmdline.bpos = 0;
	cmdline.cpos = 0;
	cmdline.size = 128;
	cmdline.line = xnew(char, cmdline.size);
	cmdline.line[0] = 0;
}

void cmdline_insert_ch(uchar ch)
{
	int size;

	size = u_char_size(ch);
	if (cmdline.blen + size > cmdline.size) {
		cmdline.size *= 2;
		cmdline.line = xrenew(char, cmdline.line, cmdline.size);
	}
	memmove(cmdline.line + cmdline.bpos + size,
		cmdline.line + cmdline.bpos,
		cmdline.blen - cmdline.bpos + 1);
	u_set_char_raw(cmdline.line, &cmdline.bpos, ch);
	cmdline.cpos++;
	cmdline.blen += size;
	cmdline.clen++;
}

void cmdline_backspace(void)
{
	int bpos, size;

	if (cmdline.bpos == 0)
		return;

	bpos = cmdline.bpos;
	u_prev_char_pos(cmdline.line, &bpos);
	size = cmdline.bpos - bpos;

	memmove(cmdline.line + bpos,
		cmdline.line + cmdline.bpos,
		cmdline.blen - cmdline.bpos + 1);
	cmdline.bpos -= size;
	cmdline.cpos--;
	cmdline.blen -= size;
	cmdline.clen--;
}

void cmdline_backspace_to_bol(void)
{
	while (cmdline.bpos)
		cmdline_backspace();
}

void cmdline_delete_ch(void)
{
	uchar ch;
	int size, bpos;

	if (cmdline.bpos == cmdline.blen)
		return;
	bpos = cmdline.bpos;
	ch = u_get_char(cmdline.line, &bpos);
	size = u_char_size(ch);
	cmdline.blen -= size;
	cmdline.clen--;
	memmove(cmdline.line + cmdline.bpos,
		cmdline.line + cmdline.bpos + size,
		cmdline.blen - cmdline.bpos + 1);
}

void cmdline_set_text(const char *text)
{
	int len = strlen(text);

	if (len >= cmdline.size) {
		while (len >= cmdline.size)
			cmdline.size *= 2;
		cmdline.line = xrenew(char, cmdline.line, cmdline.size);
	}
	memcpy(cmdline.line, text, len + 1);
	cmdline.cpos = u_strlen_safe(cmdline.line);
	cmdline.bpos = len;
	cmdline.clen = cmdline.cpos;
	cmdline.blen = len;
}

void cmdline_clear(void)
{
	cmdline.blen = 0;
	cmdline.clen = 0;
	cmdline.bpos = 0;
	cmdline.cpos = 0;
	cmdline.line[0] = 0;
}

void cmdline_clear_end(void)
{
	cmdline.line[cmdline.bpos] = 0;

	cmdline.clen = u_strlen_safe(cmdline.line);
	cmdline.blen = strlen(cmdline.line);
}

void cmdline_move_left(void)
{
	if (cmdline.bpos > 0) {
		cmdline.cpos--;
		u_prev_char_pos(cmdline.line, &cmdline.bpos);
	}
}

void cmdline_move_right(void)
{
	if (cmdline.bpos < cmdline.blen) {
		u_get_char(cmdline.line, &cmdline.bpos);
		cmdline.cpos++;
	}
}

void cmdline_move_home(void)
{
	cmdline.cpos = 0;
	cmdline.bpos = 0;
}

void cmdline_move_end(void)
{
	cmdline.cpos = cmdline.clen;
	cmdline.bpos = cmdline.blen;
}

static int next_word(const char *str, int bpos, int *cdiff, const char *delim, int direction)
{
	int skip_delim = 1;
	while ((direction > 0) ? str[bpos] : (bpos > 0)) {
		uchar ch;
		int oldp = bpos;

		if (direction > 0) {
			ch = u_get_char(str, &bpos);
		} else {
			u_prev_char_pos(str, &bpos);
			oldp = bpos;
			ch = u_get_char(str, &oldp);
		}

		if (u_strchr(delim, ch)) {
			if (!skip_delim) {
				bpos -= bpos - oldp;
				break;
			}
		} else
			skip_delim = 0;

		*cdiff += direction;
	}
	return bpos;
}

void cmdline_forward_word(const char *delim)
{
	cmdline.bpos = next_word(cmdline.line, cmdline.bpos, &cmdline.cpos, delim, +1);
}

void cmdline_backward_word(const char *delim)
{
	cmdline.bpos = next_word(cmdline.line, cmdline.bpos, &cmdline.cpos, delim, -1);
}

void cmdline_delete_word(const char *delim)
{
	int bpos, cdiff = 0;

	bpos = next_word(cmdline.line, cmdline.bpos, &cdiff, delim, +1);

	memmove(cmdline.line + cmdline.bpos,
		cmdline.line + bpos,
		cmdline.blen - bpos + 1);
	cmdline.blen -= bpos - cmdline.bpos;
	cmdline.clen -= cdiff;
}

void cmdline_backward_delete_word(const char *delim)
{
	int bpos, cdiff = 0;

	bpos = next_word(cmdline.line, cmdline.bpos, &cdiff, delim, -1);

	cmdline.blen += bpos - cmdline.bpos;
	memmove(cmdline.line + bpos,
		cmdline.line + cmdline.bpos,
		cmdline.blen - bpos + 1);
	cmdline.bpos = bpos;
	cmdline.clen += cdiff;
	cmdline.cpos += cdiff;
}
#include "cmus.h"
#include "job.h"
#include "lib.h"
#include "pl.h"
#include "player.h"
#include "input.h"
#include "play_queue.h"
#include "cache.h"
#include "misc.h"
#include "file.h"
#include "utils.h"
#include "path.h"
#include "options.h"
#include "command_mode.h"
#include "xmalloc.h"
#include "debug.h"
#include "load_dir.h"
#include "ui_curses.h"
#include "cache.h"
#include "gbuf.h"
#include "discid.h"
#include "locking.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <ctype.h>
#include <strings.h>

/* save_playlist_cb, save_ext_playlist_cb */
typedef int (*save_tracks_cb)(void *data, struct track_info *ti);

static char **playable_exts;
static const char * const playlist_exts[] = { "m3u", "pl", "pls", NULL };

int cmus_next_track_request_fd;
static bool play_queue_active = false;
static int cmus_next_track_request_fd_priv;
static pthread_mutex_t cmus_next_file_mutex = CMUS_MUTEX_INITIALIZER;
static pthread_cond_t cmus_next_file_cond = CMUS_COND_INITIALIZER;
static int cmus_next_file_provided;
static struct track_info *cmus_next_file;

static int x11_init_done = 0;
static void *(*x11_open)(void *) = NULL;
static int (*x11_raise)(void *, int) = NULL;
static int (*x11_close)(void *) = NULL;

int cmus_init(void)
{
	playable_exts = ip_get_supported_extensions();
	cache_init();
	job_init();
	play_queue_init();
	return 0;
}

void cmus_exit(void)
{
	job_exit();
	if (cache_close())
		d_print("error: %s\n", strerror(errno));
}

void cmus_next(void)
{
	struct track_info *info = cmus_get_next_track();
	if (info)
		player_set_file(info);
}

void cmus_prev(void)
{
	struct track_info *info;

	if (play_library) {
		info = lib_goto_prev();
	} else {
		info = pl_goto_prev();
	}

	if (info)
		player_set_file(info);
}

void cmus_next_album(void)
{
	struct track_info *info;

	if (play_library) {
		info = lib_goto_next_album();
	} else {
		info = pl_goto_next();
	}

	if (info)
		player_set_file(info);
}

void cmus_prev_album(void)
{
	struct track_info *info;

	if (play_library) {
		info = lib_goto_prev_album();
	} else {
		info = pl_goto_prev();
	}

	if (info)
		player_set_file(info);
}

void cmus_play_file(const char *filename)
{
	struct track_info *ti;

	cache_lock();
	ti = cache_get_ti(filename, 0);
	cache_unlock();
	if (!ti) {
		error_msg("Couldn't get file information for %s\n", filename);
		return;
	}

	player_play_file(ti);
}

enum file_type cmus_detect_ft(const char *name, char **ret)
{
	char *absolute;
	struct stat st;

	if (is_http_url(name) || is_cue_url(name)) {
		*ret = xstrdup(name);
		return FILE_TYPE_URL;
	}

	if (is_cdda_url(name)) {
		*ret = complete_cdda_url(cdda_device, name);
		return FILE_TYPE_CDDA;
	}

	*ret = NULL;
	absolute = path_absolute(name);
	if (absolute == NULL)
		return FILE_TYPE_INVALID;

	/* stat follows symlinks, lstat does not */
	if (stat(absolute, &st) == -1) {
		free(absolute);
		return FILE_TYPE_INVALID;
	}

	if (S_ISDIR(st.st_mode)) {
		*ret = absolute;
		return FILE_TYPE_DIR;
	}
	if (!S_ISREG(st.st_mode)) {
		free(absolute);
		errno = EINVAL;
		return FILE_TYPE_INVALID;
	}

	*ret = absolute;
	if (cmus_is_playlist(absolute))
		return FILE_TYPE_PL;

	/* NOTE: it could be FILE_TYPE_PL too! */
	return FILE_TYPE_FILE;
}

void cmus_add(add_ti_cb add, const char *name, enum file_type ft, int jt, int force,
		void *opaque)
{
	struct add_data *data = xnew(struct add_data, 1);

	data->add = add;
	data->name = xstrdup(name);
	data->type = ft;
	data->force = force;
	data->opaque = opaque;

	job_schedule_add(jt, data);
}

static int save_ext_playlist_cb(void *data, struct track_info *ti)
{
	GBUF(buf);
	int fd = *(int *)data;
	int i, rc;

	gbuf_addf(&buf, "file %s\n", escape(ti->filename));
	gbuf_addf(&buf, "duration %d\n", ti->duration);
	gbuf_addf(&buf, "codec %s\n", ti->codec);
	gbuf_addf(&buf, "bitrate %ld\n", ti->bitrate);
	for (i = 0; ti->comments[i].key; i++)
		gbuf_addf(&buf, "tag %s %s\n",
				ti->comments[i].key,
				escape(ti->comments[i].val));

	rc = write_all(fd, buf.buffer, buf.len);
	gbuf_free(&buf);

	if (rc == -1)
		return -1;
	return 0;
}

static int save_playlist_cb(void *data, struct track_info *ti)
{
	int fd = *(int *)data;
	const char nl = '\n';
	int rc;

	rc = write_all(fd, ti->filename, strlen(ti->filename));
	if (rc == -1)
		return -1;
	rc = write_all(fd, &nl, 1);
	if (rc == -1)
		return -1;
	return 0;
}

static int do_cmus_save(for_each_ti_cb for_each_ti, const char *filename,
		save_tracks_cb save_tracks, void *opaque)
{
	int fd, rc;

	if (strcmp(filename, "-") == 0) {
		if (get_client_fd() == -1) {
			error_msg("saving to stdout works only remotely");
			return 0;
		}
		fd = dup(get_client_fd());
	} else
		fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0666);
	if (fd == -1)
		return -1;
	rc = for_each_ti(save_tracks, &fd, opaque);
	close(fd);
	return rc;
}

int cmus_save(for_each_ti_cb for_each_ti, const char *filename, void *opaque)
{
	return do_cmus_save(for_each_ti, filename, save_playlist_cb, opaque);
}

int cmus_save_ext(for_each_ti_cb for_each_ti, const char *filename,
		void *opaque)
{
	return do_cmus_save(for_each_ti, filename, save_ext_playlist_cb,
			opaque);
}

static int update_cb(void *data, struct track_info *ti)
{
	struct update_data *d = data;

	if (d->size == d->used) {
		if (d->size == 0)
			d->size = 16;
		d->size *= 2;
		d->ti = xrenew(struct track_info *, d->ti, d->size);
	}
	track_info_ref(ti);
	d->ti[d->used++] = ti;
	return 0;
}

void cmus_update_cache(int force)
{
	struct update_cache_data *data;

	data = xnew(struct update_cache_data, 1);
	data->force = force;

	job_schedule_update_cache(JOB_TYPE_LIB, data);
}

void cmus_update_lib(void)
{
	struct update_data *data;

	data = xnew0(struct update_data, 1);

	lib_for_each(update_cb, data, NULL);

	job_schedule_update(data);
}

void cmus_update_tis(struct track_info **tis, int nr, int force)
{
	struct update_data *data;

	data = xnew(struct update_data, 1);
	data->size = nr;
	data->used = nr;
	data->ti = tis;
	data->force = force;

	job_schedule_update(data);
}

static const char *get_ext(const char *filename)
{
	const char *ext = strrchr(filename, '.');

	if (ext)
		ext++;
	return ext;
}

static int str_in_array(const char *str, const char * const *array)
{
	int i;

	for (i = 0; array[i]; i++) {
		if (strcasecmp(str, array[i]) == 0)
			return 1;
	}
	return 0;
}

int cmus_is_playlist(const char *filename)
{
	const char *ext = get_ext(filename);

	return ext && str_in_array(ext, playlist_exts);
}

int cmus_is_playable(const char *filename)
{
	const char *ext = get_ext(filename);

	return ext && str_in_array(ext, (const char * const *)playable_exts);
}

int cmus_is_supported(const char *filename)
{
	const char *ext = get_ext(filename);

	return ext && (str_in_array(ext, (const char * const *)playable_exts) ||
			str_in_array(ext, playlist_exts));
}

struct pl_data {
	int (*cb)(void *data, const char *line);
	void *data;
};

static int pl_handle_line(void *data, const char *line)
{
	struct pl_data *d = data;
	int i = 0;

	while (isspace((unsigned char)line[i]))
		i++;
	if (line[i] == 0)
		return 0;

	if (line[i] == '#')
		return 0;

	return d->cb(d->data, line);
}

static int pls_handle_line(void *data, const char *line)
{
	struct pl_data *d = data;

	if (strncasecmp(line, "file", 4))
		return 0;
	line = strchr(line, '=');
	if (line == NULL)
		return 0;
	return d->cb(d->data, line + 1);
}

int cmus_playlist_for_each(const char *buf, int size, int reverse,
		int (*cb)(void *data, const char *line),
		void *data)
{
	struct pl_data d = { cb, data };
	int (*handler)(void *, const char *);

	handler = pl_handle_line;
	if (size >= 10 && strncasecmp(buf, "[playlist]", 10) == 0)
		handler = pls_handle_line;

	if (reverse) {
		buffer_for_each_line_reverse(buf, size, handler, &d);
	} else {
		buffer_for_each_line(buf, size, handler, &d);
	}
	return 0;
}

/* multi-threaded next track requests */

#define cmus_next_file_lock() cmus_mutex_lock(&cmus_next_file_mutex)
#define cmus_next_file_unlock() cmus_mutex_unlock(&cmus_next_file_mutex)

static struct track_info *cmus_get_next_from_main_thread(void)
{
	struct track_info *ti = play_queue_remove();
	if (ti) {
		play_queue_active = true;
	} else {
		if (!play_queue_active || !stop_after_queue)
			ti = play_library ? lib_goto_next() : pl_goto_next();
		play_queue_active = false;
	}
	return ti;
}

static struct track_info *cmus_get_next_from_other_thread(void)
{
	static pthread_mutex_t mutex = CMUS_MUTEX_INITIALIZER;
	cmus_mutex_lock(&mutex);

	/* only one thread may request a track at a time */

	notify_via_pipe(cmus_next_track_request_fd_priv);

	cmus_next_file_lock();
	while (!cmus_next_file_provided)
		pthread_cond_wait(&cmus_next_file_cond, &cmus_next_file_mutex);
	struct track_info *ti = cmus_next_file;
	cmus_next_file_provided = 0;
	cmus_next_file_unlock();

	cmus_mutex_unlock(&mutex);

	return ti;
}

struct track_info *cmus_get_next_track(void)
{
	pthread_t this_thread = pthread_self();
	if (pthread_equal(this_thread, main_thread))
		return cmus_get_next_from_main_thread();
	return cmus_get_next_from_other_thread();
}

void cmus_provide_next_track(void)
{
	clear_pipe(cmus_next_track_request_fd, 1);

	cmus_next_file_lock();
	cmus_next_file = cmus_get_next_from_main_thread();
	cmus_next_file_provided = 1;
	cmus_next_file_unlock();

	pthread_cond_broadcast(&cmus_next_file_cond);
}

void cmus_track_request_init(void)
{
	init_pipes(&cmus_next_track_request_fd, &cmus_next_track_request_fd_priv);
}

static int cmus_can_raise_vte_x11(void)
{
	return getenv("DISPLAY") && getenv("WINDOWID");
}

int cmus_can_raise_vte(void)
{
	return cmus_can_raise_vte_x11();
}

static int cmus_raise_vte_x11_error(void)
{
	return 0;
}

void cmus_raise_vte(void)
{
	if (cmus_can_raise_vte_x11()) {
		if (!x11_init_done) {
			void *x11;

			x11_init_done = 1;
			x11 = dlopen("libX11.so", RTLD_LAZY);

			if (x11) {
				int (*x11_error)(void *);

				x11_error = dlsym(x11, "XSetErrorHandler");
				x11_open = dlsym(x11, "XOpenDisplay");
				x11_raise = dlsym(x11, "XRaiseWindow");
				x11_close = dlsym(x11, "XCloseDisplay");

				if (x11_error) {
					x11_error(cmus_raise_vte_x11_error);
				}
			}
		}

		if (x11_open && x11_raise && x11_close) {
			char *xid_str;
			long int xid = 0;

			xid_str = getenv("WINDOWID");
			if (!str_to_int(xid_str, &xid) && xid != 0) {
				void *display;

				display = x11_open(NULL);
				if (display) {
					x11_raise(display, (int) xid);
					x11_close(display);
				}
			}
		}
	}
}

bool cmus_queue_active(void) {
	return play_queue_active;
}
#include "command_mode.h"
#include "search_mode.h"
#include "cmdline.h"
#include "options.h"
#include "ui_curses.h"
#include "history.h"
#include "tabexp.h"
#include "tabexp_file.h"
#include "browser.h"
#include "filters.h"
#include "player.h"
#include "output.h"
#include "editable.h"
#include "lib.h"
#include "pl.h"
#include "play_queue.h"
#include "cmus.h"
#include "worker.h"
#include "keys.h"
#include "xmalloc.h"
#include "xstrjoin.h"
#include "misc.h"
#include "path.h"
#include "spawn.h"
#include "utils.h"
#include "list.h"
#include "debug.h"
#include "load_dir.h"
#include "help.h"
#include "op.h"
#include "mpris.h"
#include "job.h"

#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <dirent.h>

static struct history cmd_history;
static char *cmd_history_filename;
static char *history_search_text = NULL;
static int arg_expand_cmd = -1;
static int mute_vol_l = 0, mute_vol_r = 0;

/* view {{{ */

void view_clear(int view)
{
	switch (view) {
	case TREE_VIEW:
	case SORTED_VIEW:
		worker_remove_jobs_by_type(JOB_TYPE_LIB);
		editable_clear(&lib_editable);

		/* FIXME: make this optional? */
		lib_clear_store();
		break;
	case PLAYLIST_VIEW:
		pl_clear();
		break;
	case QUEUE_VIEW:
		worker_remove_jobs_by_type(JOB_TYPE_QUEUE);
		editable_clear(&pq_editable);
		break;
	default:
		info_msg(":clear only works in views 1-4");
	}
}

void view_add(int view, char *arg, int prepend)
{
	char *tmp, *name;
	enum file_type ft;

	tmp = expand_filename(arg);
	ft = cmus_detect_ft(tmp, &name);
	if (ft == FILE_TYPE_INVALID) {
		error_msg("adding '%s': %s", tmp, strerror(errno));
		free(tmp);
		return;
	}
	free(tmp);

	switch (view) {
	case TREE_VIEW:
	case SORTED_VIEW:
		cmus_add(lib_add_track, name, ft, JOB_TYPE_LIB, 0, NULL);
		break;
	case PLAYLIST_VIEW:
		pl_add_file_to_marked_pl(name);
		break;
	case QUEUE_VIEW:
		if (prepend) {
			cmus_add(play_queue_prepend, name, ft, JOB_TYPE_QUEUE,
					0, NULL);
		} else {
			cmus_add(play_queue_append, name, ft, JOB_TYPE_QUEUE, 0,
					NULL);
		}
		break;
	default:
		info_msg(":add only works in views 1-4");
	}
	free(name);
}

static char *view_load_prepare(char *arg)
{
	char *name, *tmp = expand_filename(arg);
	enum file_type ft = cmus_detect_ft(tmp, &name);
	if (ft == FILE_TYPE_INVALID) {
		error_msg("loading '%s': %s", tmp, strerror(errno));
		free(tmp);
		return NULL;
	}
	free(tmp);

	if (ft == FILE_TYPE_FILE)
		ft = FILE_TYPE_PL;
	if (ft != FILE_TYPE_PL) {
		error_msg("loading '%s': not a playlist file", name);
		free(name);
		return NULL;
	}
	return name;
}

void view_load(int view, char *arg)
{
	char *name = view_load_prepare(arg);
	if (!name)
		return;

	switch (view) {
	case TREE_VIEW:
	case SORTED_VIEW:
		worker_remove_jobs_by_type(JOB_TYPE_LIB);
		editable_clear(&lib_editable);
		cmus_add(lib_add_track, name, FILE_TYPE_PL, JOB_TYPE_LIB, 0,
				NULL);
		free(lib_filename);
		lib_filename = name;
		break;
	default:
		info_msg(":load only works in views 1-2");
		free(name);
	}
}

static void do_save(for_each_ti_cb for_each_ti, const char *arg, char **filenamep,
		save_ti_cb save_ti)
{
	char *filename = *filenamep;

	if (arg) {
		if (strcmp(arg, "-") == 0) {
			filename = (char *) arg;
		} else {
			free(filename);
			filename = xstrdup(arg);
			*filenamep = filename;
		}
	} else if (!filename) {
		error_msg("need a file as argument, no default stored yet");
		return;
	}

	if (save_ti(for_each_ti, filename, NULL) == -1)
		error_msg("saving '%s': %s", filename, strerror(errno));
}

void view_save(int view, char *arg, int to_stdout, int filtered, int extended)
{
	char **dest;
	save_ti_cb     save_ti         = extended ? cmus_save_ext         : cmus_save;
	for_each_ti_cb lib_for_each_ti = filtered ? lib_for_each_filtered : lib_for_each;

	if (arg) {
		if (to_stdout) {
			arg = xstrdup(arg);
		} else {
			char *tmp = expand_filename(arg);
			arg = path_absolute(tmp);
			free(tmp);
		}
	}

	switch (view) {
	case TREE_VIEW:
	case SORTED_VIEW:
		if (worker_has_job_by_type(JOB_TYPE_LIB))
			goto worker_running;
		dest = extended ? &lib_ext_filename : &lib_filename;
		do_save(lib_for_each_ti, arg, dest, save_ti);
		break;
	case PLAYLIST_VIEW:
		if (arg)
			pl_export_selected_pl(arg);
		else
			pl_save();
		break;
	case QUEUE_VIEW:
		if (worker_has_job_by_type(JOB_TYPE_QUEUE))
			goto worker_running;
		dest = extended ? &play_queue_ext_filename : &play_queue_filename;
		do_save(play_queue_for_each, arg, dest, save_ti);
		break;
	default:
		info_msg(":save only works in views 1 - 4");
	}
	free(arg);
	return;
worker_running:
	error_msg("can't save when tracks are being added");
	free(arg);
}

/* }}} */

/* if only_last != 0, only return the last flag */
static int do_parse_flags(const char **strp, const char *flags, int only_last)
{
	const char *str = *strp;
	int flag = 0;

	if (str == NULL)
		return flag;

	while (*str && (only_last || !flag)) {
		if (*str != '-')
			break;

		// "-"
		if (str[1] == 0)
			break;

		// "--" or "-- "
		if (str[1] == '-' && (str[2] == 0 || str[2] == ' ')) {
			str += 2;
			break;
		}

		// not "-?" or "-? "
		if (str[2] && str[2] != ' ')
			break;

		flag = str[1];
		if (!strchr(flags, flag)) {
			error_msg("invalid option -%c", flag);
			return -1;
		}

		str += 2;

		while (*str == ' ')
			str++;
	}
	while (*str == ' ')
		str++;
	if (*str == 0)
		str = NULL;
	*strp = str;
	return flag;
}

static int parse_flags(const char **strp, const char *flags)
{
	return do_parse_flags(strp, flags, 1);
}

static int parse_one_flag(const char **strp, const char *flags)
{
	return do_parse_flags(strp, flags, 0);
}

/* is str == "...-", but not "...-- -" ? copied from do_parse_flags() */
static int is_stdout_filename(const char *str)
{
	if (!str)
		return 0;

	while (*str) {
		if (*str != '-')
			return 0;
		// "-"
		if (str[1] == 0)
			return 1;
		// "--" or "-- "
		if (str[1] == '-' && (str[2] == 0 || str[2] == ' '))
			return 0;
		// not "-?" or "-? "
		if (str[2] && str[2] != ' ')
			return 0;
		str += 2;
		while (*str == ' ')
			str++;
	}

	return 0;
}

static int flag_to_view(int flag)
{
	switch (flag) {
	case 'l':
	case 'L':
		return TREE_VIEW;
	case 'p':
		return PLAYLIST_VIEW;
	case 'q':
	case 'Q':
		return QUEUE_VIEW;
	default:
		return cur_view;
	}
}

struct window *current_win(void)
{
	switch (cur_view) {
	case TREE_VIEW:
		return lib_cur_win;
	case SORTED_VIEW:
		return lib_editable.shared->win;
	case PLAYLIST_VIEW:
		return pl_cursor_win();
	case QUEUE_VIEW:
		return pq_editable.shared->win;
	case BROWSER_VIEW:
		return browser_win;
	case HELP_VIEW:
		return help_win;
	case FILTERS_VIEW:
	default:
		return filters_win;
	}
}

static void cmd_add(char *arg)
{
	int flag = parse_flags((const char **)&arg, "lpqQ");

	if (flag == -1)
		return;
	if (arg == NULL) {
		error_msg("not enough arguments\n");
		return;
	}
	view_add(flag_to_view(flag), arg, flag == 'Q');
}

static void cmd_clear(char *arg)
{
	int flag = parse_flags((const char **)&arg, "lpq");

	if (flag == -1)
		return;
	if (arg) {
		error_msg("too many arguments\n");
		return;
	}
	view_clear(flag_to_view(flag));
}

static void cmd_load(char *arg)
{
	int flag = parse_flags((const char **)&arg, "lp");

	if (flag == -1)
		return;
	if (arg == NULL) {
		error_msg("not enough arguments\n");
		return;
	}
	view_load(flag_to_view(flag), arg);
}

static void cmd_save(char *arg)
{
	int to_stdout = is_stdout_filename(arg);
	int flag = 0, f, extended = 0;

	do {
		f = parse_one_flag((const char **)&arg, "eLlpq");
		if (f == 'e')
			extended = 1;
		else if (f)
			flag = f;
	} while (f > 0);

	if (flag == -1)
		return;
	view_save(flag_to_view(flag), arg, to_stdout, flag == 'L', extended);
}

static void cmd_set(char *arg)
{
	char *value = NULL;
	int i;

	for (i = 0; arg[i]; i++) {
		if (arg[i] == '=') {
			arg[i] = 0;
			value = &arg[i + 1];
			break;
		}
	}
	if (value) {
		option_set(arg, value);
		help_win->changed = 1;
		if (cur_view == TREE_VIEW) {
			lib_track_win->changed = 1;
			lib_tree_win->changed = 1;
		} else if (cur_view == PLAYLIST_VIEW) {
			pl_mark_for_redraw();
		} else {
			current_win()->changed = 1;
		}
		update_titleline();
		update_statusline();
	} else {
		struct cmus_opt *opt;
		char buf[OPTION_MAX_SIZE];

		/* support "set <option>?" */
		i--;
		if (arg[i] == '?')
			arg[i] = 0;

		opt = option_find(arg);
		if (opt) {
			opt->get(opt->data, buf, OPTION_MAX_SIZE);
			info_msg("setting: '%s=%s'", arg, buf);
		}
	}
}

static void cmd_toggle(char *arg)
{
	struct cmus_opt *opt = option_find(arg);

	if (opt == NULL)
		return;

	if (opt->toggle == NULL) {
		error_msg("%s is not toggle option", opt->name);
		return;
	}
	opt->toggle(opt->data);
	help_win->changed = 1;
	if (cur_view == TREE_VIEW) {
		lib_track_win->changed = 1;
		lib_tree_win->changed = 1;
	} else if (cur_view == PLAYLIST_VIEW) {
		pl_mark_for_redraw();
	} else {
		current_win()->changed = 1;
	}
	update_titleline();
	update_statusline();
}

static int get_number(char *str, char **end)
{
	int val = 0;

	while (*str >= '0' && *str <= '9') {
		val *= 10;
		val += *str++ - '0';
	}
	*end = str;
	return val;
}

static void cmd_seek(char *arg)
{
	int relative = 0;
	int seek = 0, sign = 1, count;

	switch (*arg) {
	case '-':
		sign = -1;
		/* fallthrough */
	case '+':
		relative = 1;
		arg++;
		break;
	}

	count = 0;
	goto inside;

	do {
		int num;
		char *end;

		if (*arg != ':')
			break;
		arg++;
inside:
		num = get_number(arg, &end);
		if (arg == end)
			break;
		arg = end;
		seek = seek * 60 + num;
	} while (++count < 3);

	seek *= sign;
	if (!count)
		goto err;

	if (count == 1) {
		switch (tolower((unsigned char)*arg)) {
		case 'h':
			seek *= 60;
			/* fallthrough */
		case 'm':
			seek *= 60;
			/* fallthrough */
		case 's':
			arg++;
			break;
		}
	}

	if (!*arg) {
		player_seek(seek, relative, 0);
		return;
	}
err:
	error_msg("expecting one argument: [+-]INTEGER[mh] or [+-]H:MM:SS");
}

static void cmd_factivate(char *arg)
{
	filters_activate_names(arg);
}

static void cmd_live_filter(char *arg)
{
	filters_set_live(arg);
}

static void cmd_filter(char *arg)
{
	filters_set_anonymous(arg);
}

static void cmd_fset(char *arg)
{
	filters_set_filter(arg);
}

static void cmd_help(char *arg)
{
	info_msg("To get started with cmus, read cmus-tutorial(7) and cmus(1) man pages");
}

static void cmd_invert(char *arg)
{
	switch (cur_view) {
	case SORTED_VIEW:
		editable_invert_marks(&lib_editable);
		break;
	case PLAYLIST_VIEW:
		pl_invert_marks();
		break;
	case QUEUE_VIEW:
		editable_invert_marks(&pq_editable);
		break;
	default:
		info_msg(":invert only works in views 2-4");
	}
}

static void cmd_mark(char *arg)
{
	switch (cur_view) {
	case SORTED_VIEW:
		editable_mark(&lib_editable, arg);
		break;
	case PLAYLIST_VIEW:
		pl_mark(arg);
		break;
	case QUEUE_VIEW:
		editable_mark(&pq_editable, arg);
		break;
	default:
		info_msg(":mark only works in views 2-4");
	}
}

static void cmd_unmark(char *arg)
{
	switch (cur_view) {
	case SORTED_VIEW:
		editable_unmark(&lib_editable);
		break;
	case PLAYLIST_VIEW:
		pl_unmark();
		break;
	case QUEUE_VIEW:
		editable_unmark(&pq_editable);
		break;
	default:
		info_msg(":unmark only works in views 2-4");
	}
}

static void cmd_update_cache(char *arg)
{
	int flag = parse_flags((const char **)&arg, "f");
	cmus_update_cache(flag == 'f');
}

static void cmd_cd(char *arg)
{
	if (arg) {
		char *dir, *absolute;

		dir = expand_filename(arg);
		absolute = path_absolute(dir);
		if (chdir(dir) == -1) {
			error_msg("could not cd to '%s': %s", dir, strerror(errno));
		} else {
			browser_chdir(absolute);
		}
		free(absolute);
		free(dir);
	} else {
		if (chdir(home_dir) == -1) {
			error_msg("could not cd to '%s': %s", home_dir, strerror(errno));
		} else {
			browser_chdir(home_dir);
		}
	}
}

static void cmd_bind(char *arg)
{
	int flag = parse_flags((const char **)&arg, "f");
	char *key, *func;

	if (flag == -1)
		return;

	if (arg == NULL)
		goto err;

	key = strchr(arg, ' ');
	if (key == NULL)
		goto err;
	*key++ = 0;
	while (*key == ' ')
		key++;

	func = strchr(key, ' ');
	if (func == NULL)
		goto err;
	*func++ = 0;
	while (*func == ' ')
		func++;
	if (*func == 0)
		goto err;

	key_bind(arg, key, func, flag == 'f');
	if (cur_view == HELP_VIEW)
		window_changed(help_win);
	return;
err:
	error_msg("expecting 3 arguments (context, key and function)\n");
}

static void cmd_unbind(char *arg)
{
	int flag = parse_flags((const char **)&arg, "f");
	char *key;

	if (flag == -1)
		return;

	if (arg == NULL)
		goto err;

	key = strchr(arg, ' ');
	if (key == NULL)
		goto err;
	*key++ = 0;
	while (*key == ' ')
		key++;
	if (*key == 0)
		goto err;

	strip_trailing_spaces(key);

	key_unbind(arg, key, flag == 'f');
	return;
err:
	error_msg("expecting 2 arguments (context and key)\n");
}

static void cmd_showbind(char *arg)
{
	char *key;

	key = strchr(arg, ' ');
	if (key == NULL)
		goto err;
	*key++ = 0;
	while (*key == ' ')
		key++;
	if (*key == 0)
		goto err;

	strip_trailing_spaces(key);

	show_binding(arg, key);
	return;
err:
	error_msg("expecting 2 arguments (context and key)\n");
}

static void cmd_quit(char *arg)
{
	int flag = parse_flags((const char **)&arg, "i");
	enum ui_query_answer answer;
	if (!worker_has_job_by_type(JOB_TYPE_ANY)) {
		if (flag != 'i' || yes_no_query("Quit cmus? [y/N]") != UI_QUERY_ANSWER_NO)
			cmus_running = 0;
	} else {
		answer = yes_no_query("Tracks are being added. Quit and truncate playlist(s)? [y/N]");
		if (answer != UI_QUERY_ANSWER_NO)
			cmus_running = 0;
	}
}

static void cmd_reshuffle(char *arg)
{
	lib_reshuffle();
	pl_reshuffle();
}

static void cmd_source(char *arg)
{
	char *filename = expand_filename(arg);

	if (source_file(filename) == -1)
		error_msg("sourcing %s: %s", filename, strerror(errno));
	free(filename);
}

static void cmd_colorscheme(char *arg)
{
	char filename[512];

	snprintf(filename, sizeof(filename), "%s/%s.theme", cmus_config_dir, arg);
	if (source_file(filename) == -1) {
		snprintf(filename, sizeof(filename), "%s/%s.theme", cmus_data_dir, arg);
		if (source_file(filename) == -1)
			error_msg("sourcing %s: %s", filename, strerror(errno));
	}
}

/*
 * \" inside double-quotes becomes "
 * \\ inside double-quotes becomes \
 */
static char *parse_quoted(const char **strp)
{
	const char *str = *strp;
	const char *start;
	char *ret, *dst;

	str++;
	start = str;
	while (1) {
		int c = *str++;

		if (c == 0)
			goto error;
		if (c == '"')
			break;
		if (c == '\\') {
			if (*str++ == 0)
				goto error;
		}
	}
	*strp = str;
	ret = xnew(char, str - start);
	str = start;
	dst = ret;
	while (1) {
		int c = *str++;

		if (c == '"')
			break;
		if (c == '\\') {
			c = *str++;
			if (c != '"' && c != '\\')
				*dst++ = '\\';
		}
		*dst++ = c;
	}
	*dst = 0;
	return ret;
error:
	error_msg("`\"' expected");
	return NULL;
}

static char *parse_escaped(const char **strp)
{
	const char *str = *strp;
	const char *start;
	char *ret, *dst;

	start = str;
	while (1) {
		int c = *str;

		if (c == 0 || c == ' ' || c == '\'' || c == '"')
			break;

		str++;
		if (c == '\\') {
			c = *str;
			if (c == 0)
				break;
			str++;
		}
	}
	*strp = str;
	ret = xnew(char, str - start + 1);
	str = start;
	dst = ret;
	while (1) {
		int c = *str;

		if (c == 0 || c == ' ' || c == '\'' || c == '"')
			break;

		str++;
		if (c == '\\') {
			c = *str;
			if (c == 0) {
				*dst++ = '\\';
				break;
			}
			str++;
		}
		*dst++ = c;
	}
	*dst = 0;
	return ret;
}

static char *parse_one(const char **strp)
{
	const char *str = *strp;
	char *ret = NULL;

	while (1) {
		char *part = NULL;
		int c = *str;

		if (!c || c == ' ')
			break;
		if (c == '"') {
			part = parse_quoted(&str);
			if (part == NULL)
				goto error;
		} else if (c == '\'') {
			/* backslashes are normal chars inside single-quotes */
			const char *end;

			str++;
			end = strchr(str, '\'');
			if (end == NULL)
				goto sq_missing;
			part = xstrndup(str, end - str);
			str = end + 1;
		} else {
			part = parse_escaped(&str);
		}

		if (ret == NULL) {
			ret = xstrdup(part);
		} else {
			char *tmp = xstrjoin(ret, part);
			free(ret);
			ret = tmp;
		}
		free(part);
	}
	*strp = str;
	return ret;
sq_missing:
	error_msg("`'' expected");
error:
	free(ret);
	return NULL;
}

char **parse_cmd(const char *cmd, int *args_idx, int *ac)
{
	char **av = NULL;
	int nr = 0;
	int alloc = 0;

	while (*cmd) {
		char *arg;

		/* there can't be spaces at start of command
		 * and there is at least one argument */
		if (cmd[0] == '{' && cmd[1] == '}' && (cmd[2] == ' ' || cmd[2] == 0)) {
			/* {} is replaced with file arguments */
			if (*args_idx != -1)
				goto only_once_please;
			*args_idx = nr;
			cmd += 2;
			goto skip_spaces;
		} else {
			arg = parse_one(&cmd);
			if (arg == NULL)
				goto error;
		}

		if (nr == alloc) {
			alloc = alloc ? alloc * 2 : 4;
			av = xrenew(char *, av, alloc + 1);
		}
		av[nr++] = arg;
skip_spaces:
		while (*cmd == ' ')
			cmd++;
	}
	av[nr] = NULL;
	*ac = nr;
	return av;
only_once_please:
	error_msg("{} can be used only once");
error:
	while (nr > 0)
		free(av[--nr]);
	free(av);
	return NULL;
}

struct track_info_selection {
	struct track_info **tis;
	int tis_alloc;
	int tis_nr;
};

static int add_ti(void *data, struct track_info *ti)
{
	struct track_info_selection *sel = data;
	if (sel->tis_nr == sel->tis_alloc) {
		sel->tis_alloc = sel->tis_alloc ? sel->tis_alloc * 2 : 8;
		sel->tis = xrenew(struct track_info *, sel->tis, sel->tis_alloc);
	}
	track_info_ref(ti);
	sel->tis[sel->tis_nr++] = ti;
	return 0;
}

static void cmd_run(char *arg)
{
	char **av, **argv;
	int ac, argc, i, run, files_idx = -1;
	struct track_info_selection sel = { .tis = NULL };

	if (cur_view > QUEUE_VIEW) {
		info_msg("Command execution is supported only in views 1-4");
		return;
	}

	av = parse_cmd(arg, &files_idx, &ac);
	if (av == NULL) {
		return;
	}

	/* collect selected files (struct track_info) */
	switch (cur_view) {
	case TREE_VIEW:
		_tree_for_each_sel(add_ti, &sel, 0);
		break;
	case SORTED_VIEW:
		_editable_for_each_sel(&lib_editable, add_ti, &sel, 0);
		break;
	case PLAYLIST_VIEW:
		_pl_for_each_sel(add_ti, &sel, 0);
		break;
	case QUEUE_VIEW:
		_editable_for_each_sel(&pq_editable, add_ti, &sel, 0);
		break;
	}

	if (sel.tis_nr == 0) {
		/* no files selected, do nothing */
		free_str_array(av);
		return;
	}
	sel.tis[sel.tis_nr] = NULL;

	/* build argv */
	argv = xnew(char *, ac + sel.tis_nr + 1);
	argc = 0;
	if (files_idx == -1) {
		/* add selected files after rest of the args */
		for (i = 0; i < ac; i++)
			argv[argc++] = av[i];
		for (i = 0; i < sel.tis_nr; i++)
			argv[argc++] = sel.tis[i]->filename;
	} else {
		for (i = 0; i < files_idx; i++)
			argv[argc++] = av[i];
		for (i = 0; i < sel.tis_nr; i++)
			argv[argc++] = sel.tis[i]->filename;
		for (i = files_idx; i < ac; i++)
			argv[argc++] = av[i];
	}
	argv[argc] = NULL;

	for (i = 0; argv[i]; i++)
		d_print("ARG: '%s'\n", argv[i]);

	run = 1;
	if (confirm_run && (sel.tis_nr > 1 || strcmp(argv[0], "rm") == 0)) {
		if (yes_no_query("Execute %s for the %d selected files? [y/N]", arg, sel.tis_nr) != UI_QUERY_ANSWER_YES) {
			info_msg("Aborted");
			run = 0;
		}
	}
	if (run) {
		int status;

		if (spawn(argv, &status, 1)) {
			error_msg("executing %s: %s", argv[0], strerror(errno));
		} else {
			if (WIFEXITED(status)) {
				int rc = WEXITSTATUS(status);

				if (rc)
					error_msg("%s returned %d", argv[0], rc);
			}
			if (WIFSIGNALED(status))
				error_msg("%s received signal %d", argv[0], WTERMSIG(status));

			switch (cur_view) {
			case TREE_VIEW:
			case SORTED_VIEW:
				/* this must be done before sel.tis are unreffed */
				free_str_array(av);
				free(argv);

				/* remove non-existed files, update tags for changed files */
				cmus_update_tis(sel.tis, sel.tis_nr, 0);

				/* we don't own sel.tis anymore! */
				return;
			}
		}
	}
	free_str_array(av);
	free(argv);
	for (i = 0; sel.tis[i]; i++)
		track_info_unref(sel.tis[i]);
	free(sel.tis);
}

static void cmd_shell(char *arg)
{
	const char * const argv[] = { "sh", "-c", arg, NULL };

	if (spawn((char **) argv, NULL, 0))
		error_msg("executing '%s': %s", arg, strerror(errno));
}

static int get_one_ti(void *data, struct track_info *ti)
{
	struct track_info **sel_ti = data;

	track_info_ref(ti);
	*sel_ti = ti;
	/* stop the for each loop, we need only the first selected track */
	return 1;
}

static void cmd_echo(char *arg)
{
	struct track_info *sel_ti;
	char *ptr = arg;

	while (1) {
		ptr = strchr(ptr, '{');
		if (ptr == NULL)
			break;
		if (ptr[1] == '}')
			break;
		ptr++;
	}

	if (ptr == NULL) {
		info_msg("%s", arg);
		return;
	}

	if (cur_view > QUEUE_VIEW) {
		info_msg("echo with {} in its arguments is supported only in views 1-4");
		return;
	}

	*ptr = 0;
	ptr += 2;

	/* get only the first selected track */
	sel_ti = NULL;

	switch (cur_view) {
	case TREE_VIEW:
		_tree_for_each_sel(get_one_ti, &sel_ti, 0);
		break;
	case SORTED_VIEW:
		_editable_for_each_sel(&lib_editable, get_one_ti, &sel_ti, 0);
		break;
	case PLAYLIST_VIEW:
		_pl_for_each_sel(get_one_ti, &sel_ti, 0);
		break;
	case QUEUE_VIEW:
		_editable_for_each_sel(&pq_editable, get_one_ti, &sel_ti, 0);
		break;
	}

	if (sel_ti == NULL)
		return;

	info_msg("%s%s%s", arg, sel_ti->filename, ptr);
	track_info_unref(sel_ti);
}

static int parse_vol_arg(const char *arg, int *value, unsigned int *flags)
{
	unsigned int f = 0;
	int ch, val = 0, digits = 0, sign = 1;

	if (*arg == '-') {
		arg++;
		f |= VF_RELATIVE;
		sign = -1;
	} else if (*arg == '+') {
		arg++;
		f |= VF_RELATIVE;
	}

	while (1) {
		ch = *arg++;
		if (ch < '0' || ch > '9')
			break;
		val *= 10;
		val += ch - '0';
		digits++;
	}
	if (digits == 0)
		goto err;

	if (ch == '%') {
		f |= VF_PERCENTAGE;
		ch = *arg;
	}
	if (ch)
		goto err;

	*value = sign * val;
	*flags = f;
	return 0;
err:
	return -1;
}

static void cmd_mute(char *arg)
{
	int l = 0, r = 0;

	if (volume_l == 0 && volume_r == 0) {
		// unmute
		l = mute_vol_l;
		r = mute_vol_r;
	} else {
		mute_vol_l = volume_l;
		mute_vol_r = volume_r;
	}

	int rc = player_set_vol(l, 0, r, 0);
	if (rc != OP_ERROR_SUCCESS) {
		char *msg = op_get_error_msg(rc, "can't change volume");
		error_msg("%s", msg);
		free(msg);
	} else {
		mpris_volume_changed();
	}
	update_statusline();
}


/*
 * :vol value [value]
 *
 * where value is [-+]?[0-9]+%?
 */
static void cmd_vol(char *arg)
{
	char **values = get_words(arg);
	unsigned int lf, rf;
	int l, r;

	if (values[1] && values[2])
		goto err;

	if (parse_vol_arg(values[0], &l, &lf))
		goto err;

	r = l;
	rf = lf;
	if (values[1] && parse_vol_arg(values[1], &r, &rf))
		goto err;

	free_str_array(values);

	int rc = player_set_vol(l, lf, r, rf);
	if (rc != OP_ERROR_SUCCESS) {
		char *msg = op_get_error_msg(rc, "can't change volume");
		error_msg("%s", msg);
		free(msg);
	} else {
		mpris_volume_changed();
	}
	update_statusline();
	return;
err:
	free_str_array(values);
	error_msg("expecting 1 or 2 arguments (total or L and R volumes [+-]INTEGER[%%])\n");
}

static void cmd_prev_view(char *arg)
{
	if (prev_view >= 0) {
		set_view(prev_view);
	}
}

static void cmd_left_view(char *arg)
{
	if (cur_view == TREE_VIEW) {
		set_view(HELP_VIEW);
	} else {
		set_view(cur_view - 1);
	}
}

static void cmd_right_view(char *arg)
{
	if (cur_view == HELP_VIEW) {
		set_view(TREE_VIEW);
	} else {
		set_view(cur_view + 1);
	}
}

static void cmd_pl_create(char *arg)
{
	pl_create(arg);
}

static void cmd_pl_export(char *arg)
{
	if (cur_view == PLAYLIST_VIEW)
		pl_export_selected_pl(arg);
	else
		info_msg(":pl-export only works in view 3");
}

static char *get_browser_add_file(void)
{
	char *sel = browser_get_sel();

	if (sel && (ends_with(sel, "/../") || ends_with(sel, "/.."))) {
		info_msg("For convenience, you can not add \"..\" directory from the browser view");
		free(sel);
		sel = NULL;
	}

	return sel;
}

static void cmd_pl_import(char *arg)
{
	char *name = NULL;

	if (arg)
		name = view_load_prepare(arg);
	else if (cur_view == BROWSER_VIEW)
		name = get_browser_add_file();
	else
		error_msg("not enough arguments");

	if (name) {
		pl_import(name);
		free(name);
	}
}

static void cmd_pl_rename(char *arg)
{
	if (cur_view == PLAYLIST_VIEW)
		pl_rename_selected_pl(arg);
	else
		info_msg(":pl-rename only works in view 3");
}

static void cmd_version(char *arg)
{
	info_msg(VERSION);
}

static void cmd_view(char *arg)
{
	int view;

	if (parse_enum(arg, 1, NR_VIEWS, view_names, &view) && (view - 1) != cur_view) {
		set_view(view - 1);
	}
}

static void cmd_push(char *arg)
{
	if (arg)
		cmdline_set_text(arg);
	enter_command_mode();
}

static void cmd_p_next(char *arg)
{
	cmus_next();
}

static void cmd_p_pause(char *arg)
{
	player_pause();
}

static void cmd_p_pause_playback(char *arg)
{
	player_pause_playback();
}

static void cmd_p_play(char *arg)
{
	if (arg) {
		char *tmp = expand_filename(arg);
		cmus_play_file(tmp);
		free(tmp);
	} else {
		player_play();
	}
}

static void cmd_p_prev(char *arg)
{
	if (rewind_offset < 0 || player_info.pos < rewind_offset) {
		cmus_prev();
	} else {
		player_play();
	}
}

static void cmd_p_next_album(char *arg)
{
	cmus_next_album();
}

static void cmd_p_prev_album(char *arg)
{
	cmus_prev_album();
}

static void cmd_p_stop(char *arg)
{
	player_stop();
}

static void cmd_pwd(char *arg)
{
	char buf[4096];
	if (getcwd(buf, sizeof buf)) {
		info_msg("%s", buf);
	}
}

static void cmd_raise_vte(char *arg)
{
	cmus_raise_vte();
}

static void cmd_rand(char *arg)
{
	switch (cur_view) {
	case TREE_VIEW:
		break;
	case SORTED_VIEW:
		editable_rand(&lib_editable);
		break;
	case PLAYLIST_VIEW:
		pl_rand();
		break;
	case QUEUE_VIEW:
		editable_rand(&pq_editable);
		break;
	}
}

static void cmd_search_next(char *arg)
{
	if (search_str) {
		if (!search_next(searchable, search_str, search_direction))
			search_not_found();
	}
}

static void cmd_search_prev(char *arg)
{
	if (search_str) {
		if (!search_next(searchable, search_str, !search_direction))
			search_not_found();
	}
}

static void cmd_search_start(char *arg)
{
	enter_search_mode();
}

static void cmd_search_b_start(char *arg)
{
	enter_search_backward_mode();
}

static int sorted_for_each_sel(track_info_cb cb, void *data, int reverse, int advance)
{
	return editable_for_each_sel(&lib_editable, cb, data, reverse, advance);
}

static int pq_for_each_sel(track_info_cb cb, void *data, int reverse, int advance)
{
	return editable_for_each_sel(&pq_editable, cb, data, reverse, advance);
}

static for_each_sel_ti_cb view_for_each_sel[4] = {
	tree_for_each_sel,
	sorted_for_each_sel,
	pl_for_each_sel,
	pq_for_each_sel
};

/* wrapper for add_ti_cb, (void *) can't store function pointers */
struct wrapper_cb_data {
	add_ti_cb cb;
};

/* wrapper for void lib_add_track(struct track_info *) etc. */
static int wrapper_cb(void *data, struct track_info *ti)
{
	struct wrapper_cb_data *add = data;

	add->cb(ti, NULL);
	return 0;
}

static void add_from_browser(add_ti_cb add, int job_type, int advance)
{
	char *sel = get_browser_add_file();

	if (sel) {
		enum file_type ft;
		char *ret;

		ft = cmus_detect_ft(sel, &ret);
		if (ft != FILE_TYPE_INVALID) {
			cmus_add(add, ret, ft, job_type, 0, NULL);
			if (advance)
				window_down(browser_win, 1);
		}
		free(ret);
		free(sel);
	}
}

static void cmd_win_add_l(char *arg)
{
	int flag = parse_flags((const char **)&arg, "n");
	if (flag == -1)
		return;

	if (cur_view == TREE_VIEW || cur_view == SORTED_VIEW)
		return;

	if (cur_view <= QUEUE_VIEW) {
		struct wrapper_cb_data add = { lib_add_track };
		view_for_each_sel[cur_view](wrapper_cb, &add, 0, flag != 'n');
	} else if (cur_view == BROWSER_VIEW) {
		add_from_browser(lib_add_track, JOB_TYPE_LIB, flag != 'n');
	}
}

static void cmd_win_add_p(char *arg)
{
	int flag = parse_flags((const char **)&arg, "n");
	if (flag == -1)
		return;

	if (cur_view == PLAYLIST_VIEW && pl_visible_is_marked())
		return;

	if (cur_view <= QUEUE_VIEW) {
		struct wrapper_cb_data add = { pl_add_track_to_marked_pl2 };
		view_for_each_sel[cur_view](wrapper_cb, &add, 0, flag != 'n');
	} else if (cur_view == BROWSER_VIEW) {
		char *sel = get_browser_add_file();
		if (sel) {
			if (pl_add_file_to_marked_pl(sel) && flag != 'n')
				window_down(browser_win, 1);
			free(sel);
		}
	}
}

static void cmd_win_add_Q(char *arg)
{
	int flag = parse_flags((const char **)&arg, "n");
	if (flag == -1)
		return;

	if (cur_view == QUEUE_VIEW)
		return;

	if (cur_view <= QUEUE_VIEW) {
		struct wrapper_cb_data add = { play_queue_prepend };
		view_for_each_sel[cur_view](wrapper_cb, &add, 1, flag != 'n');
	} else if (cur_view == BROWSER_VIEW) {
		add_from_browser(play_queue_prepend, JOB_TYPE_QUEUE, flag != 'n');
	}
}

static void cmd_win_add_q(char *arg)
{
	int flag = parse_flags((const char **)&arg, "n");
	if (flag == -1)
		return;

	if (cur_view == QUEUE_VIEW)
		return;

	if (cur_view <= QUEUE_VIEW) {
		struct wrapper_cb_data add = { play_queue_append };
		view_for_each_sel[cur_view](wrapper_cb, &add, 0, flag != 'n');
	} else if (cur_view == BROWSER_VIEW) {
		add_from_browser(play_queue_append, JOB_TYPE_QUEUE, flag != 'n');
	}
}

static void cmd_win_activate(char *arg)
{
	struct track_info *info = NULL;
	struct shuffle_info *previous = NULL, *next = NULL;
	struct rb_root *shuffle_root = NULL;

	if (cur_view == TREE_VIEW || cur_view == SORTED_VIEW) {
		if (shuffle == SHUFFLE_TRACKS) {
			if (lib_cur_track)
				previous = &lib_cur_track->simple_track.shuffle_info;
			shuffle_root = &lib_shuffle_root;
		} else if (shuffle == SHUFFLE_ALBUMS) {
			if (lib_cur_track)
				previous = &lib_cur_track->album->shuffle_info;
			shuffle_root = &lib_album_shuffle_root;
		}
	}

	switch (cur_view) {
	case TREE_VIEW:
		info = tree_activate_selected();
		if (shuffle == SHUFFLE_TRACKS)
			next = &lib_cur_track->simple_track.shuffle_info;
		else if (shuffle == SHUFFLE_ALBUMS)
			next = &lib_cur_track->album->shuffle_info;
		break;
	case SORTED_VIEW:
		info = sorted_activate_selected();
		if (shuffle == SHUFFLE_TRACKS)
			next = &lib_cur_track->simple_track.shuffle_info;
		else if (shuffle == SHUFFLE_ALBUMS)
			next = &lib_cur_track->album->shuffle_info;
		break;
	case PLAYLIST_VIEW:
		info = pl_play_selected_row();
		break;
	case QUEUE_VIEW:
		break;
	case BROWSER_VIEW:
		browser_enter();
		break;
	case FILTERS_VIEW:
		filters_activate(1);
		break;
	case HELP_VIEW:
		help_select();
		break;
	}

	if (info) {
		if (shuffle && next)
			shuffle_insert(shuffle_root, previous, next);
		/* update lib/pl mode */
		if (cur_view < 2)
			play_library = 1;
		if (cur_view == 2)
			play_library = 0;

		player_play_file(info);
	}
}

static void cmd_win_mv_after(char *arg)
{
	switch (cur_view) {
	case SORTED_VIEW:
		editable_move_after(&lib_editable);
		break;
	case PLAYLIST_VIEW:
		pl_win_mv_after();
		break;
	case QUEUE_VIEW:
		editable_move_after(&pq_editable);
		break;
	}
}

static void cmd_win_mv_before(char *arg)
{
	switch (cur_view) {
	case SORTED_VIEW:
		editable_move_before(&lib_editable);
		break;
	case PLAYLIST_VIEW:
		pl_win_mv_before();
		break;
	case QUEUE_VIEW:
		editable_move_before(&pq_editable);
		break;
	}
}

static void cmd_win_remove(char *arg)
{
	switch (cur_view) {
	case TREE_VIEW:
		tree_remove_sel();
		break;
	case SORTED_VIEW:
		editable_remove_sel(&lib_editable);
		break;
	case PLAYLIST_VIEW:
		pl_win_remove();
		break;
	case QUEUE_VIEW:
		editable_remove_sel(&pq_editable);
		break;
	case BROWSER_VIEW:
		browser_delete();
		break;
	case FILTERS_VIEW:
		filters_delete_filter();
		break;
	case HELP_VIEW:
		help_remove();
		break;
	}
}

static void cmd_win_sel_cur(char *arg)
{
	switch (cur_view) {
	case TREE_VIEW:
		tree_sel_current(auto_expand_albums_selcur);
		break;
	case SORTED_VIEW:
		sorted_sel_current();
		break;
	case PLAYLIST_VIEW:
		pl_select_playing_track();
		break;
	}
}

static void cmd_win_toggle(char *arg)
{
	switch (cur_view) {
	case TREE_VIEW:
		tree_toggle_expand_artist();
		break;
	case SORTED_VIEW:
		editable_toggle_mark(&lib_editable);
		break;
	case PLAYLIST_VIEW:
		pl_win_toggle();
		break;
	case QUEUE_VIEW:
		editable_toggle_mark(&pq_editable);
		break;
	case FILTERS_VIEW:
		filters_toggle_filter();
		break;
	case HELP_VIEW:
		help_toggle();
		break;
	}
}

static void cmd_win_scroll_down(char *arg)
{
	window_scroll_down(current_win());
}

static void cmd_win_scroll_up(char *arg)
{
	window_scroll_up(current_win());
}

static void cmd_win_bottom(char *arg)
{
	window_goto_bottom(current_win());
}

static void cmd_win_down(char *arg)
{
	unsigned num_rows = 1;
	char *end;

	if (arg) {
		if ((num_rows = get_number(arg, &end)) == 0 || *end) {
			error_msg("invalid argument\n");
			return;
		}
	}

	window_down(current_win(), num_rows);
}

static void cmd_win_next(char *arg)
{
	if (cur_view == TREE_VIEW)
		tree_toggle_active_window();
	else if (cur_view == PLAYLIST_VIEW)
		pl_win_next();
}

static void cmd_win_pg_down(char *arg)
{
	window_page_down(current_win());
}

static void cmd_win_pg_up(char *arg)
{
	window_page_up(current_win());
}

static void cmd_win_hf_pg_down(char *arg)
{
	window_half_page_down(current_win());
}

static void cmd_win_hf_pg_up(char *arg)
{
	window_half_page_up(current_win());
}

static void cmd_win_pg_top(char *arg)
{
	window_page_top(current_win());
}

static void cmd_win_pg_bottom(char *arg)
{
	window_page_bottom(current_win());
}

static void cmd_win_pg_middle(char *arg)
{
	window_page_middle(current_win());
}

static void cmd_win_update_cache(char *arg)
{
	struct track_info_selection sel = { .tis = NULL };
	int flag = parse_flags((const char **)&arg, "f");

	if (cur_view != TREE_VIEW && cur_view != SORTED_VIEW)
		return;

	view_for_each_sel[cur_view](add_ti, &sel, 0, 1);
	if (sel.tis_nr == 0)
		return;
	sel.tis[sel.tis_nr] = NULL;
	cmus_update_tis(sel.tis, sel.tis_nr, flag == 'f');
}

static void cmd_win_top(char *arg)
{
	window_goto_top(current_win());
}

static void cmd_win_up(char *arg)
{
	unsigned num_rows = 1;
	char *end;

	if (arg) {
		if ((num_rows = get_number(arg, &end)) == 0 || *end) {
			error_msg("invalid argument\n");
			return;
		}
	}

	window_up(current_win(), num_rows);
}

static void cmd_win_update(char *arg)
{
	switch (cur_view) {
	case TREE_VIEW:
	case SORTED_VIEW:
		cmus_update_lib();
		break;
	case PLAYLIST_VIEW:
		pl_win_update();
		break;
	case BROWSER_VIEW:
		browser_reload();
		break;
	}
}

static void cmd_browser_up(char *arg)
{
	browser_up();
}

static void cmd_refresh(char *arg)
{
	clearok(curscr, TRUE);
	refresh();
}

static int cmp_intp(const void *ap, const void *bp)
{
	int a = *(int *)ap;
	int b = *(int *)bp;
	return a - b;
}

static int *rand_array(int size, int nmax)
{
	int *r = xnew(int, size + 1);
	int i, offset = 0;
	int count = size;

	if (count > nmax / 2) {
		/*
		 * Imagine that there are 1000 tracks in library and we want to
		 * add 998 random tracks to queue.  After we have added 997
		 * random numbers to the array it would be quite hard to find a
		 * random number that isn't already in the array (3/1000
		 * probability).
		 *
		 * So we invert the logic:
		 *
		 * Find two (1000 - 998) random numbers in 0..999 range and put
		 * them at end of the array.  Sort the numbers and then fill
		 * the array starting at index 0 with incrementing values that
		 * are not in the set of random numbers.
		 */
		count = nmax - count;
		offset = size - count;
	}

	for (i = 0; i < count; ) {
		int v, j;
found:
		v = rand() % nmax;
		for (j = 0; j < i; j++) {
			if (r[offset + j] == v)
				goto found;
		}
		r[offset + i++] = v;
	}
	qsort(r + offset, count, sizeof(*r), cmp_intp);

	if (offset) {
		int j, n;

		/* simplifies next loop */
		r[size] = nmax;

		/* convert the indexes we don't want to those we want */
		i = 0;
		j = offset;
		n = 0;
		do {
			while (n < r[j])
				r[i++] = n++;
			j++;
			n++;
		} while (i < size);
	}
	return r;
}

static int count_albums(void)
{
	struct artist *artist;
	struct rb_node *tmp1, *tmp2;
	int count = 0;

	rb_for_each_entry(artist, tmp1, &lib_artist_root, tree_node) {
		rb_for_each(tmp2, &artist->album_root)
			count++;
	}
	return count;
}

struct album_list {
	struct list_head node;
	const struct album *album;
};

static void cmd_lqueue(char *arg)
{
	LIST_HEAD(head);
	const struct list_head *item;
	const struct album *album;
	int count = 1, nmax, i, pos;
	int *r;

	if (arg) {
		long int val;

		if (str_to_int(arg, &val) || val <= 0) {
			error_msg("argument must be positive integer");
			return;
		}
		count = val;
	}
	nmax = count_albums();
	if (count > nmax)
		count = nmax;
	if (!count)
		return;

	r = rand_array(count, nmax);
	album = to_album(rb_first(&to_artist(rb_first(&lib_artist_root))->album_root));
	pos = 0;
	for (i = 0; i < count; i++) {
		struct album_list *a;

		while (pos < r[i]) {
			struct artist *artist = album->artist;
			if (!rb_next(&album->tree_node)) {
				artist = to_artist(rb_next(&artist->tree_node));
				album = to_album(rb_first(&artist->album_root));
			} else {
				album = to_album(rb_next(&album->tree_node));
			}
			pos++;
		}
		a = xnew(struct album_list, 1);
		a->album = album;
		list_add_rand(&head, &a->node, i);
	}
	free(r);

	item = head.next;
	do {
		struct list_head *next = item->next;
		struct album_list *a = container_of(item, struct album_list, node);
		struct tree_track *t;
		struct rb_node *tmp;

		rb_for_each_entry(t, tmp, &a->album->track_root, tree_node)
			play_queue_append(tree_track_info(t), NULL);
		free(a);
		item = next;
	} while (item != &head);
}

struct track_list {
	struct list_head node;
	const struct simple_track *track;
};

static void cmd_tqueue(char *arg)
{
	LIST_HEAD(head);
	struct list_head *item;
	int count = 1, i, pos;
	int *r;

	if (arg) {
		long int val;

		if (str_to_int(arg, &val) || val <= 0) {
			error_msg("argument must be positive integer");
			return;
		}
		count = val;
	}
	if (count > lib_editable.nr_tracks)
		count = lib_editable.nr_tracks;
	if (!count)
		return;

	r = rand_array(count, lib_editable.nr_tracks);
	item = lib_editable.head.next;
	pos = 0;
	for (i = 0; i < count; i++) {
		struct track_list *t;

		while (pos < r[i]) {
			item = item->next;
			pos++;
		}
		t = xnew(struct track_list, 1);
		t->track = to_simple_track(item);
		list_add_rand(&head, &t->node, i);
	}
	free(r);

	item = head.next;
	do {
		struct list_head *next = item->next;
		struct track_list *t = container_of(item, struct track_list, node);
		play_queue_append(t->track->info, NULL);
		free(t);
		item = next;
	} while (item != &head);
}

/* tab exp {{{
 *
 * these functions fill tabexp struct, which is resetted beforehand
 */

/* buffer used for tab expansion */
static char expbuf[512];

static int filter_directories(const char *name, const struct stat *s)
{
	return S_ISDIR(s->st_mode);
}

static int filter_executable_files(const char *name, const struct stat *s)
{
	return S_ISREG(s->st_mode) && (s->st_mode & 0111);
}

static int filter_any(const char *name, const struct stat *s)
{
	return 1;
}

static int filter_playable(const char *name, const struct stat *s)
{
	return S_ISDIR(s->st_mode) || cmus_is_playable(name);
}

static int filter_playlist(const char *name, const struct stat *s)
{
	return S_ISDIR(s->st_mode) || cmus_is_playlist(name);
}

static int filter_supported(const char *name, const struct stat *s)
{
	return S_ISDIR(s->st_mode) || cmus_is_supported(name);
}

static void expand_files(const char *str)
{
	expand_files_and_dirs(str, filter_any);
}

static void expand_directories(const char *str)
{
	expand_files_and_dirs(str, filter_directories);
}

static void expand_playable(const char *str)
{
	expand_files_and_dirs(str, filter_playable);
}

static void expand_playlist(const char *str)
{
	expand_files_and_dirs(str, filter_playlist);
}

static void expand_supported(const char *str)
{
	expand_files_and_dirs(str, filter_supported);
}

static void expand_add(const char *str)
{
	int flag = parse_flags(&str, "lpqQ");

	if (flag == -1)
		return;
	if (str == NULL)
		str = "";
	expand_supported(str);

	if (tabexp.head && flag) {
		snprintf(expbuf, sizeof(expbuf), "-%c %s", flag, tabexp.head);
		free(tabexp.head);
		tabexp.head = xstrdup(expbuf);
	}
}

static void expand_program_paths(const char *str)
{
	if (str == NULL)
		str = "";
	if (str[0] == '~' || strchr(str, '/'))
		expand_files(str);
	else
		expand_env_path(str, filter_executable_files);
}

static void expand_program_paths_option(const char *str, const char *opt)
{
	expand_program_paths(str);

	if (tabexp.head && opt) {
		snprintf(expbuf, sizeof(expbuf), "%s=%s", opt, tabexp.head);
		free(tabexp.head);
		tabexp.head = xstrdup(expbuf);
	}
}

static void expand_load_save(const char *str)
{
	int flag = parse_flags(&str, "lp");

	if (flag == -1)
		return;
	if (str == NULL)
		str = "";
	expand_playlist(str);

	if (tabexp.head && flag) {
		snprintf(expbuf, sizeof(expbuf), "-%c %s", flag, tabexp.head);
		free(tabexp.head);
		tabexp.head = xstrdup(expbuf);
	}
}

static void expand_key_context(const char *str, const char *force)
{
	int pos, i, len = strlen(str);
	char **tails;

	tails = xnew(char *, NR_CTXS);
	pos = 0;
	for (i = 0; key_context_names[i]; i++) {
		int cmp = strncmp(str, key_context_names[i], len);
		if (cmp > 0)
			continue;
		if (cmp < 0)
			break;
		tails[pos++] = xstrdup(key_context_names[i] + len);
	}

	if (pos == 0) {
		free(tails);
		return;
	}
	if (pos == 1) {
		char *tmp = xstrjoin(tails[0], " ");
		free(tails[0]);
		tails[0] = tmp;
	}
	snprintf(expbuf, sizeof(expbuf), "%s%s", force, str);
	tabexp.head = xstrdup(expbuf);
	tabexp.tails = tails;
	tabexp.count = pos;
}

static int get_context(const char *str, int len)
{
	int i, c = -1, count = 0;

	for (i = 0; key_context_names[i]; i++) {
		if (strncmp(str, key_context_names[i], len) == 0) {
			if (key_context_names[i][len] == 0) {
				/* exact */
				return i;
			}
			c = i;
			count++;
		}
	}
	if (count == 1)
		return c;
	return -1;
}

static void expand_command_line(const char *str);

static void expand_bind_args(const char *str)
{
	/* :bind context key function
	 *
	 * possible values for str:
	 *   c
	 *   context k
	 *   context key f
	 *
	 * you need to know context before you can expand function
	 */
	/* start and end pointers for context, key and function */
	const char *cs, *ce, *ks, *ke, *fs;
	int i, c, k, count;
	int flag = parse_flags((const char **)&str, "f");
	const char *force = "";

	if (flag == -1)
		return;
	if (str == NULL)
		str = "";

	if (flag == 'f')
		force = "-f ";

	cs = str;
	ce = strchr(cs, ' ');
	if (ce == NULL) {
		expand_key_context(cs, force);
		return;
	}

	/* context must be expandable */
	c = get_context(cs, ce - cs);
	if (c == -1) {
		/* context is ambiguous or invalid */
		return;
	}

	ks = ce;
	while (*ks == ' ')
		ks++;
	ke = strchr(ks, ' ');
	if (ke == NULL) {
		/* expand key */
		int len = strlen(ks);
		PTR_ARRAY(array);

		for (i = 0; key_table[i].name; i++) {
			int cmp = strncmp(ks, key_table[i].name, len);
			if (cmp > 0)
				continue;
			if (cmp < 0)
				break;
			ptr_array_add(&array, xstrdup(key_table[i].name + len));
		}

		if (!array.count)
			return;

		if (array.count == 1) {
			char **ptrs = array.ptrs;
			char *tmp = xstrjoin(ptrs[0], " ");
			free(ptrs[0]);
			ptrs[0] = tmp;
		}

		snprintf(expbuf, sizeof(expbuf), "%s%s %s", force, key_context_names[c], ks);

		tabexp.head = xstrdup(expbuf);
		tabexp.tails = array.ptrs;
		tabexp.count = array.count;
		return;
	}

	/* key must be expandable */
	k = -1;
	count = 0;
	for (i = 0; key_table[i].name; i++) {
		if (strncmp(ks, key_table[i].name, ke - ks) == 0) {
			if (key_table[i].name[ke - ks] == 0) {
				/* exact */
				k = i;
				count = 1;
				break;
			}
			k = i;
			count++;
		}
	}
	if (count != 1) {
		/* key is ambiguous or invalid */
		return;
	}

	fs = ke;
	while (*fs == ' ')
		fs++;

	if (*fs == ':')
		fs++;

	/* expand com [arg...] */
	expand_command_line(fs);
	if (tabexp.head == NULL) {
		/* command expand failed */
		return;
	}

	/*
	 * tabexp.head is now "com"
	 * tabexp.tails is [ mand1 mand2 ... ]
	 *
	 * need to change tabexp.head to "context key com"
	 */

	snprintf(expbuf, sizeof(expbuf), "%s%s %s %s", force, key_context_names[c],
			key_table[k].name, tabexp.head);
	free(tabexp.head);
	tabexp.head = xstrdup(expbuf);
}

static void expand_unbind_args(const char *str)
{
	/* :unbind context key */
	/* start and end pointers for context and key */
	const char *cs, *ce, *ks;
	const struct binding *b;
	PTR_ARRAY(array);
	int c, len;

	cs = str;
	ce = strchr(cs, ' ');
	if (ce == NULL) {
		expand_key_context(cs, "");
		return;
	}

	/* context must be expandable */
	c = get_context(cs, ce - cs);
	if (c == -1) {
		/* context is ambiguous or invalid */
		return;
	}

	ks = ce;
	while (*ks == ' ')
		ks++;

	/* expand key */
	len = strlen(ks);
	b = key_bindings[c];
	while (b) {
		if (!strncmp(ks, b->key->name, len))
			ptr_array_add(&array, xstrdup(b->key->name + len));
		b = b->next;
	}
	if (!array.count)
		return;

	snprintf(expbuf, sizeof(expbuf), "%s %s", key_context_names[c], ks);

	tabexp.head = xstrdup(expbuf);
	tabexp.tails = array.ptrs;
	tabexp.count = array.count;
}

static void expand_factivate(const char *str)
{
	/* "name1 name2 name3", expand only name3 */
	struct filter_entry *e;
	const char *name;
	PTR_ARRAY(array);
	int str_len, len, i;

	str_len = strlen(str);
	i = str_len;
	while (i > 0) {
		if (str[i - 1] == ' ')
			break;
		i--;
	}
	len = str_len - i;
	name = str + i;

	list_for_each_entry(e, &filters_head, node) {
		if (!strncmp(name, e->name, len))
			ptr_array_add(&array, xstrdup(e->name + len));
	}
	if (!array.count)
		return;

	tabexp.head = xstrdup(str);
	tabexp.tails = array.ptrs;
	tabexp.count = array.count;
}

static void expand_fset(const char *str)
{
	struct filter_entry *e;
	PTR_ARRAY(array);

	list_for_each_entry(e, &filters_head, node) {
		char *line = xnew(char, strlen(e->name) + strlen(e->filter) + 2);
		sprintf(line, "%s=%s", e->name, e->filter);
		if (!strncmp(str, line, strlen(str)))
			ptr_array_add(&array, xstrdup(line + strlen(str)));
		free(line);
	}
	if (!array.count)
		return;

	tabexp.head = xstrdup(str);
	tabexp.tails = array.ptrs;
	tabexp.count = array.count;
}

static void expand_options(const char *str)
{
	struct cmus_opt *opt;
	int len;
	char **tails, *sep;

	/* tabexp is resetted */
	len = strlen(str);
	sep = strchr(str, '=');
	if (len > 1 && sep) {
		/* expand value */
		char *var = xstrndup(str, sep - str);

		list_for_each_entry(opt, &option_head, node) {
			if (strcmp(var, opt->name) == 0) {
				if (str[len - 1] == '=') {
					char buf[OPTION_MAX_SIZE];

					tails = xnew(char *, 1);

					buf[0] = 0;
					opt->get(opt->data, buf, OPTION_MAX_SIZE);
					tails[0] = xstrdup(buf);

					tabexp.head = xstrdup(str);
					tabexp.tails = tails;
					tabexp.count = 1;
				} else if (opt->flags & OPT_PROGRAM_PATH) {
					expand_program_paths_option(sep + 1, var);
				}
				break;
			}
		}
		free(var);
	} else {
		/* expand variable */
		int pos;

		tails = xnew(char *, nr_options);
		pos = 0;
		list_for_each_entry(opt, &option_head, node) {
			if (strncmp(str, opt->name, len) == 0)
				tails[pos++] = xstrdup(opt->name + len);
		}
		if (pos > 0) {
			if (pos == 1) {
				/* only one variable matches, add '=' */
				char *tmp = xstrjoin(tails[0], "=");

				free(tails[0]);
				tails[0] = tmp;
			}

			tabexp.head = xstrdup(str);
			tabexp.tails = tails;
			tabexp.count = pos;
		} else {
			free(tails);
		}
	}
}

static void expand_toptions(const char *str)
{
	struct cmus_opt *opt;
	int len, pos;
	char **tails;

	tails = xnew(char *, nr_options);
	len = strlen(str);
	pos = 0;
	list_for_each_entry(opt, &option_head, node) {
		if (opt->toggle == NULL)
			continue;
		if (strncmp(str, opt->name, len) == 0)
			tails[pos++] = xstrdup(opt->name + len);
	}
	if (pos > 0) {
		tabexp.head = xstrdup(str);
		tabexp.tails = tails;
		tabexp.count = pos;
	} else {
		free(tails);
	}
}

static void load_themes(const char *dirname, const char *str, struct ptr_array *array)
{
	struct directory dir;
	const char *name, *dot;
	int len = strlen(str);

	if (dir_open(&dir, dirname))
		return;

	while ((name = dir_read(&dir))) {
		if (!S_ISREG(dir.st.st_mode))
			continue;
		if (strncmp(name, str, len))
			continue;
		dot = strrchr(name, '.');
		if (dot == NULL || strcmp(dot, ".theme"))
			continue;
		if (dot - name < len)
			/* str is  "foo.th"
			 * matches "foo.theme"
			 * which also ends with ".theme"
			 */
			continue;
		ptr_array_add(array, xstrndup(name + len, dot - name - len));
	}
	dir_close(&dir);
}

static void expand_colorscheme(const char *str)
{
	PTR_ARRAY(array);

	load_themes(cmus_config_dir, str, &array);
	load_themes(cmus_data_dir, str, &array);

	if (array.count) {
		ptr_array_sort(&array, strptrcmp);

		tabexp.head = xstrdup(str);
		tabexp.tails = array.ptrs;
		tabexp.count = array.count;
	}
}

static void expand_commands(const char *str);

/* tab exp }}} */

/* sort by name */
struct command commands[] = {
	{ "add",                   cmd_add,              1, 1,  expand_add,           0, 0          },
	{ "bind",                  cmd_bind,             1, 1,  expand_bind_args,     0, CMD_UNSAFE },
	{ "browser-up",            cmd_browser_up,       0, 0,  NULL,                 0, 0          },
	{ "cd",                    cmd_cd,               0, 1,  expand_directories,   0, 0          },
	{ "clear",                 cmd_clear,            0, 1,  NULL,                 0, 0          },
	{ "colorscheme",           cmd_colorscheme,      1, 1,  expand_colorscheme,   0, 0          },
	{ "echo",                  cmd_echo,             1, -1, NULL,                 0, 0          },
	{ "factivate",             cmd_factivate,        0, 1,  expand_factivate,     0, 0          },
	{ "filter",                cmd_filter,           0, 1,  NULL,                 0, 0          },
	{ "fset",                  cmd_fset,             1, 1,  expand_fset,          0, 0          },
	{ "help",                  cmd_help,             0, 0,  NULL,                 0, 0          },
	{ "invert",                cmd_invert,           0, 0,  NULL,                 0, 0          },
	{ "live-filter",           cmd_live_filter,      0, 1,  NULL,                 0, CMD_LIVE   },
	{ "load",                  cmd_load,             1, 1,  expand_load_save,     0, 0          },
	{ "lqueue",                cmd_lqueue,           0, 1,  NULL,                 0, 0          },
	{ "mark",                  cmd_mark,             0, 1,  NULL,                 0, 0          },
	{ "mute",                  cmd_mute,             0, 0,  NULL,                 0, 0          },
	{ "player-next",           cmd_p_next,           0, 0,  NULL,                 0, 0          },
	{ "player-next-album",     cmd_p_next_album,     0, 0,  NULL,                 0, 0          },
	{ "player-pause",          cmd_p_pause,          0, 0,  NULL,                 0, 0          },
	{ "player-pause-playback", cmd_p_pause_playback, 0, 0,  NULL,                 0, 0          },
	{ "player-play",           cmd_p_play,           0, 1,  expand_playable,      0, 0          },
	{ "player-prev",           cmd_p_prev,           0, 0,  NULL,                 0, 0          },
	{ "player-prev-album",     cmd_p_prev_album,     0, 0,  NULL,                 0, 0          },
	{ "player-stop",           cmd_p_stop,           0, 0,  NULL,                 0, 0          },
	{ "prev-view",             cmd_prev_view,        0, 0,  NULL,                 0, 0          },
	{ "left-view",             cmd_left_view,        0, 0,  NULL,                 0, 0          },
	{ "right-view",            cmd_right_view,       0, 0,  NULL,                 0, 0          },
	{ "pl-create",             cmd_pl_create,        1, -1, NULL,                 0, 0          },
	{ "pl-export",             cmd_pl_export,        1, -1, NULL,                 0, 0          },
	{ "pl-import",             cmd_pl_import,        0, -1, NULL,                 0, 0          },
	{ "pl-rename",             cmd_pl_rename,        1, -1, NULL,                 0, 0          },
	{ "push",                  cmd_push,             0, -1, expand_commands,      0, 0          },
	{ "pwd",                   cmd_pwd,              0, 0,  NULL,                 0, 0          },
	{ "raise-vte",             cmd_raise_vte,        0, 0,  NULL,                 0, 0          },
	{ "rand",                  cmd_rand,             0, 0,  NULL,                 0, 0          },
	{ "quit",                  cmd_quit,             0, 1,  NULL,                 0, 0          },
	{ "refresh",               cmd_refresh,          0, 0,  NULL,                 0, 0          },
	{ "reshuffle",             cmd_reshuffle,        0, 0,  NULL,                 0, 0          },
	{ "run",                   cmd_run,              1, -1, expand_program_paths, 0, CMD_UNSAFE },
	{ "save",                  cmd_save,             0, 1,  expand_load_save,     0, CMD_UNSAFE },
	{ "search-b-start",        cmd_search_b_start,   0, 0,  NULL,                 0, 0          },
	{ "search-next",           cmd_search_next,      0, 0,  NULL,                 0, 0          },
	{ "search-prev",           cmd_search_prev,      0, 0,  NULL,                 0, 0          },
	{ "search-start",          cmd_search_start,     0, 0,  NULL,                 0, 0          },
	{ "seek",                  cmd_seek,             1, 1,  NULL,                 0, 0          },
	{ "set",                   cmd_set,              1, 1,  expand_options,       0, 0          },
	{ "shell",                 cmd_shell,            1, -1, expand_program_paths, 0, CMD_UNSAFE },
	{ "showbind",              cmd_showbind,         1, 1,  expand_unbind_args,   0, 0          },
	{ "shuffle",               cmd_reshuffle,        0, 0,  NULL,                 0, CMD_HIDDEN },
	{ "source",                cmd_source,           1, 1,  expand_files,         0, CMD_UNSAFE },
	{ "toggle",                cmd_toggle,           1, 1,  expand_toptions,      0, 0          },
	{ "tqueue",                cmd_tqueue,           0, 1,  NULL,                 0, 0          },
	{ "unbind",                cmd_unbind,           1, 1,  expand_unbind_args,   0, 0          },
	{ "unmark",                cmd_unmark,           0, 0,  NULL,                 0, 0          },
	{ "update-cache",          cmd_update_cache,     0, 1,  NULL,                 0, 0          },
	{ "version",               cmd_version,          0, 0,  NULL,                 0, 0          },
	{ "view",                  cmd_view,             1, 1,  NULL,                 0, 0          },
	{ "vol",                   cmd_vol,              1, 2,  NULL,                 0, 0          },
	{ "w",                     cmd_save,             0, 1,  expand_load_save,     0, CMD_UNSAFE },
	{ "win-activate",          cmd_win_activate,     0, 0,  NULL,                 0, 0          },
	{ "win-add-l",             cmd_win_add_l,        0, 1,  NULL,                 0, 0          },
	{ "win-add-p",             cmd_win_add_p,        0, 1,  NULL,                 0, 0          },
	{ "win-add-Q",             cmd_win_add_Q,        0, 1,  NULL,                 0, 0          },
	{ "win-add-q",             cmd_win_add_q,        0, 1,  NULL,                 0, 0          },
	{ "win-bottom",            cmd_win_bottom,       0, 0,  NULL,                 0, 0          },
	{ "win-down",              cmd_win_down,         0, 1,  NULL,                 0, 0          },
	{ "win-half-page-down",    cmd_win_hf_pg_down,   0, 0,  NULL,                 0, 0          },
	{ "win-half-page-up",      cmd_win_hf_pg_up,     0, 0,  NULL,                 0, 0          },
	{ "win-mv-after",          cmd_win_mv_after,     0, 0,  NULL,                 0, 0          },
	{ "win-mv-before",         cmd_win_mv_before,    0, 0,  NULL,                 0, 0          },
	{ "win-next",              cmd_win_next,         0, 0,  NULL,                 0, 0          },
	{ "win-page-bottom",       cmd_win_pg_bottom,    0, 0,  NULL,                 0, 0          },
	{ "win-page-down",         cmd_win_pg_down,      0, 0,  NULL,                 0, 0          },
	{ "win-page-middle",       cmd_win_pg_middle,    0, 0,  NULL,                 0, 0          },
	{ "win-page-top",          cmd_win_pg_top,       0, 0,  NULL,                 0, 0          },
	{ "win-page-up",           cmd_win_pg_up,        0, 0,  NULL,                 0, 0          },
	{ "win-remove",            cmd_win_remove,       0, 0,  NULL,                 0, CMD_UNSAFE },
	{ "win-scroll-down",       cmd_win_scroll_down,  0, 0,  NULL,                 0, 0          },
	{ "win-scroll-up",         cmd_win_scroll_up,    0, 0,  NULL,                 0, 0          },
	{ "win-sel-cur",           cmd_win_sel_cur,      0, 0,  NULL,                 0, 0          },
	{ "win-toggle",            cmd_win_toggle,       0, 0,  NULL,                 0, 0          },
	{ "win-top",               cmd_win_top,          0, 0,  NULL,                 0, 0          },
	{ "win-up",                cmd_win_up,           0, 1,  NULL,                 0, 0          },
	{ "win-update",            cmd_win_update,       0, 0,  NULL,                 0, 0          },
	{ "win-update-cache",      cmd_win_update_cache, 0, 1,  NULL,                 0, 0          },
	{ "wq",                    cmd_quit,             0, 1,  NULL,                 0, 0          },
	{ NULL,                    NULL,                 0, 0,  0,                    0, 0          }
};

/* fills tabexp struct */
static void expand_commands(const char *str)
{
	int i, len, pos;
	char **tails;

	/* tabexp is resetted */
	tails = xnew(char *, N_ELEMENTS(commands) - 1);
	len = strlen(str);
	pos = 0;
	for (i = 0; commands[i].name; i++) {
		if (strncmp(str, commands[i].name, len) == 0 && !(commands[i].flags & CMD_HIDDEN))
			tails[pos++] = xstrdup(commands[i].name + len);
	}
	if (pos > 0) {
		if (pos == 1) {
			/* only one command matches, add ' ' */
			char *tmp = xstrjoin(tails[0], " ");

			free(tails[0]);
			tails[0] = tmp;
		}
		tabexp.head = xstrdup(str);
		tabexp.tails = tails;
		tabexp.count = pos;
	} else {
		free(tails);
	}
}

struct command *get_command(const char *str)
{
	int i, len;

	while (*str == ' ')
		str++;
	for (len = 0; str[len] && str[len] != ' '; len++)
		;

	for (i = 0; commands[i].name; i++) {
		if (strncmp(str, commands[i].name, len))
			continue;

		if (commands[i].name[len] == 0) {
			/* exact */
			return &commands[i];
		}

		if (commands[i + 1].name && strncmp(str, commands[i + 1].name, len) == 0) {
			/* ambiguous */
			return NULL;
		}
		return &commands[i];
	}
	return NULL;
}

/* fills tabexp struct */
static void expand_command_line(const char *str)
{
	/* :command [arg]...
	 *
	 * examples:
	 *
	 * str      expanded value (tabexp.head)
	 * -------------------------------------
	 *   fs     fset
	 *   b c    bind common
	 *   se     se          (tabexp.tails = [ ek t ])
	 */
	/* command start/end, argument start */
	const char *cs, *ce, *as;
	const struct command *cmd;

	cs = str;
	ce = strchr(cs, ' ');
	if (ce == NULL) {
		/* expand command */
		expand_commands(cs);
		return;
	}

	/* command must be expandable */
	cmd = get_command(cs);
	if (cmd == NULL) {
		/* command ambiguous or invalid */
		return;
	}

	if (cmd->expand == NULL) {
		/* can't expand argument */
		return;
	}

	as = ce;
	while (*as == ' ')
		as++;

	/* expand argument */
	cmd->expand(as);
	if (tabexp.head == NULL) {
		/* argument expansion failed */
		return;
	}

	/* tabexp.head is now start of the argument string */
	snprintf(expbuf, sizeof(expbuf), "%s %s", cmd->name, tabexp.head);
	free(tabexp.head);
	tabexp.head = xstrdup(expbuf);
}

static void tab_expand(int direction)
{
	char *s1, *s2, *tmp;
	int pos;

	/* strip white space */
	pos = 0;
	while (cmdline.line[pos] == ' ' && pos < cmdline.bpos)
		pos++;

	/* string to expand */
	s1 = xstrndup(cmdline.line + pos, cmdline.bpos - pos);

	/* tail */
	s2 = xstrdup(cmdline.line + cmdline.bpos);

	tmp = tabexp_expand(s1, expand_command_line, direction);
	if (tmp) {
		/* tmp.s2 */
		int l1, l2;

		l1 = strlen(tmp);
		l2 = strlen(s2);
		cmdline.blen = l1 + l2;
		if (cmdline.blen >= cmdline.size) {
			while (cmdline.blen >= cmdline.size)
				cmdline.size *= 2;
			cmdline.line = xrenew(char, cmdline.line, cmdline.size);
		}
		sprintf(cmdline.line, "%s%s", tmp, s2);
		cmdline.bpos = l1;
		cmdline.cpos = u_strlen_safe(tmp);
		cmdline.clen = u_strlen_safe(cmdline.line);
		free(tmp);
	}
	free(s1);
	free(s2);
}

static void reset_tab_expansion(void)
{
	tabexp_reset();
	arg_expand_cmd = -1;
}

static void cmdline_modified(void)
{
	char *cmd, *arg;
	struct command *c;

	if (!parse_command(cmdline.line, &cmd, &arg))
		return;

	c = get_command(cmd);
	if (!c)
		goto end;

	if (c->flags & CMD_LIVE)
		run_parsed_command(cmd, arg);

end:
	free(cmd);
	free(arg);
}

int parse_command(const char *buf, char **cmdp, char **argp)
{
	int cmd_start, cmd_end, cmd_len;
	int arg_start, arg_end;
	int i;

	i = 0;
	while (buf[i] && buf[i] == ' ')
		i++;

	if (buf[i] == '#')
		return 0;

	cmd_start = i;
	while (buf[i] && buf[i] != ' ')
		i++;
	cmd_end = i;
	while (buf[i] && buf[i] == ' ')
		i++;
	arg_start = i;
	while (buf[i])
		i++;
	arg_end = i;

	cmd_len = cmd_end - cmd_start;
	if (cmd_len == 0)
		return 0;

	*cmdp = xstrndup(buf + cmd_start, cmd_len);
	if (arg_start == arg_end) {
		*argp = NULL;
	} else {
		*argp = xstrndup(buf + arg_start, arg_end - arg_start);
	}
	return 1;
}

int run_only_safe_commands;

void run_parsed_command(char *cmd, char *arg)
{
	int cmd_len = strlen(cmd);
	int i = 0;

	while (1) {
		const struct command *c = &commands[i];

		if (c->name == NULL) {
			error_msg("unknown command\n");
			break;
		}
		if (strncmp(cmd, c->name, cmd_len) == 0) {
			const char *next = commands[i + 1].name;
			int exact = c->name[cmd_len] == 0;

			if (!exact && next && strncmp(cmd, next, cmd_len) == 0) {
				error_msg("ambiguous command\n");
				break;
			}
			if (c->min_args > 0 && arg == NULL) {
				error_msg("not enough arguments\n");
				break;
			}
			if (c->max_args == 0 && arg) {
				error_msg("too many arguments\n");
				break;
			}
			if (run_only_safe_commands && (c->flags & CMD_UNSAFE)) {
				if (c->func != cmd_save || !is_stdout_filename(arg)) {
					d_print("trying to execute unsafe command over net\n");
					break;
				}
			}
			c->func(arg);
			break;
		}
		i++;
	}
}

void run_command(const char *buf)
{
	char *cmd, *arg;

	if (!parse_command(buf, &cmd, &arg))
		return;

	run_parsed_command(cmd, arg);
	free(arg);
	free(cmd);
}

static void reset_history_search(void)
{
	history_reset_search(&cmd_history);
	free(history_search_text);
	history_search_text = NULL;
}

static void backspace(void)
{
	if (cmdline.clen > 0) {
		cmdline_backspace();
	} else {
		input_mode = NORMAL_MODE;
	}
}

void command_mode_ch(uchar ch)
{
	switch (ch) {
	case 0x01: // ^A
		cmdline_move_home();
		break;
	case 0x02: // ^B
		cmdline_move_left();
		break;
	case 0x04: // ^D
		cmdline_delete_ch();
		cmdline_modified();
		break;
	case 0x05: // ^E
		cmdline_move_end();
		break;
	case 0x06: // ^F
		cmdline_move_right();
		break;
	case 0x03: // ^C
	case 0x07: // ^G
	case 0x1B: // ESC
		if (cmdline.blen) {
			history_add_line(&cmd_history, cmdline.line);
			cmdline_clear();
		}
		input_mode = NORMAL_MODE;
		break;
	case 0x10: // ^P
		command_mode_key(KEY_UP);
		return;
	case 0xE: // ^N
		command_mode_key(KEY_DOWN);
		return;
	case 0x0A:
		if (cmdline.blen) {
			run_command(cmdline.line);
			history_add_line(&cmd_history, cmdline.line);
			cmdline_clear();
		}
		input_mode = NORMAL_MODE;
		break;
	case 0x0B:
		cmdline_clear_end();
		cmdline_modified();
		break;
	case 0x09:
		tab_expand(1);
		break;
	case 0x15:
		cmdline_backspace_to_bol();
		cmdline_modified();
		break;
	case 0x17: // ^W
		cmdline_backward_delete_word(cmdline_word_delimiters);
		cmdline_modified();
		break;
	case 0x08: // ^H
	case 127:
		backspace();
		cmdline_modified();
		break;
	default:
		cmdline_insert_ch(ch);
		cmdline_modified();
	}
	reset_history_search();
	if (ch != 0x09)
		reset_tab_expansion();
}

void command_mode_escape(int c)
{
	switch (c) {
	case 98:
		cmdline_backward_word(cmdline_filename_delimiters);
		break;
	case 100:
		cmdline_delete_word(cmdline_filename_delimiters);
		cmdline_modified();
		break;
	case 102:
		cmdline_forward_word(cmdline_filename_delimiters);
		break;
	case 127:
	case KEY_BACKSPACE:
		cmdline_backward_delete_word(cmdline_filename_delimiters);
		cmdline_modified();
		break;
	}
	reset_history_search();
}

void command_mode_key(int key)
{
	if (key != KEY_BTAB)
		reset_tab_expansion();
	switch (key) {
	case KEY_DC:
		cmdline_delete_ch();
		cmdline_modified();
		break;
	case KEY_BACKSPACE:
		backspace();
		cmdline_modified();
		break;
	case KEY_LEFT:
		cmdline_move_left();
		return;
	case KEY_RIGHT:
		cmdline_move_right();
		return;
	case KEY_HOME:
		cmdline_move_home();
		return;
	case KEY_END:
		cmdline_move_end();
		return;
	case KEY_UP:
		{
			const char *s;

			if (history_search_text == NULL)
				history_search_text = xstrdup(cmdline.line);
			s = history_search_forward(&cmd_history, history_search_text);
			if (s)
				cmdline_set_text(s);
		}
		return;
	case KEY_DOWN:
		if (history_search_text) {
			const char *s;

			s = history_search_backward(&cmd_history, history_search_text);
			if (s) {
				cmdline_set_text(s);
			} else {
				cmdline_set_text(history_search_text);
			}
		}
		return;
	case KEY_BTAB:
		tab_expand(-1);
		break;
	default:
		d_print("key = %c (%d)\n", key, key);
	}
	reset_history_search();
}

void command_mode_mouse(MEVENT *event)
{
	if ((event->bstate & BUTTON1_PRESSED) || (event->bstate & BUTTON3_PRESSED)) {
		if (event->y <= window_get_nr_rows(current_win()) + 2) {
			if (cmdline.blen) {
				history_add_line(&cmd_history, cmdline.line);
				cmdline_clear();
			}
			input_mode = NORMAL_MODE;
			normal_mode_mouse(event);
			return;
		}
		if (event->x == 0)
			return;
		int i = event->x > cmdline.clen ? cmdline.clen : event->x - 1;
		while (i < cmdline.cpos)
			cmdline_move_left();
		while (i > cmdline.cpos)
			cmdline_move_right();
	} else if (event->bstate & BUTTON4_PRESSED) {
		command_mode_key(KEY_UP);
	} else if (event->bstate & BUTTON5_PRESSED) {
		command_mode_key(KEY_DOWN);
	}
}

void commands_init(void)
{
	cmd_history_filename = xstrjoin(cmus_config_dir, "/command-history");
	history_load(&cmd_history, cmd_history_filename, 2000);
}

void commands_exit(void)
{
	view_clear(TREE_VIEW);
	view_clear(SORTED_VIEW);
	view_clear(PLAYLIST_VIEW);
	view_clear(QUEUE_VIEW);
	history_save(&cmd_history);
	history_free(&cmd_history);
	free(cmd_history_filename);
	tabexp_reset();
}
#include "comment.h"
#include "xmalloc.h"
#include "utils.h"
#include "uchar.h"

#include <string.h>
#include <strings.h>

static int is_various_artists(const char *a)
{
	return strcasecmp(a, "Various Artists") == 0 ||
	       strcasecmp(a, "Various")         == 0 ||
	       strcasecmp(a, "VA")              == 0 ||
	       strcasecmp(a, "V/A")             == 0;
}

int track_is_compilation(const struct keyval *comments)
{
	const char *c, *a, *aa;

	c = keyvals_get_val(comments, "compilation");
	if (c && is_freeform_true(c))
		return 1;

	c = keyvals_get_val(comments, "partofacompilation");
	if (c && is_freeform_true(c))
		return 1;

	aa = keyvals_get_val(comments, "albumartist");
	if (aa && is_various_artists(aa))
		return 1;

	a = keyvals_get_val(comments, "artist");
	if (a && is_various_artists(a))
		return 1;

	if (aa && a && !u_strcase_equal(aa, a))
		return 1;

	return 0;
}

int track_is_va_compilation(const struct keyval *comments)
{
	const char *c, *a, *aa;

	aa = keyvals_get_val(comments, "albumartist");
	if (aa)
		return is_various_artists(aa);

	a = keyvals_get_val(comments, "artist");
	if (a && is_various_artists(a))
		return 1;

	c = keyvals_get_val(comments, "compilation");
	if (c && is_freeform_true(c))
		return 1;

	c = keyvals_get_val(comments, "partofacompilation");
	if (c && is_freeform_true(c))
		return 1;

	return 0;
}

const char *comments_get_albumartist(const struct keyval *comments)
{
	const char *val = keyvals_get_val(comments, "albumartist");

	if (!val || strcmp(val, "") == 0)
		val = keyvals_get_val(comments, "artist");

	return val;
}

const char *comments_get_artistsort(const struct keyval *comments)
{
	const char *val;

	if (track_is_va_compilation(comments))
		return NULL;

	val = keyvals_get_val(comments, "albumartistsort");
	if (!track_is_compilation(comments)) {
		if (!val || strcmp(val, "") == 0)
			val = keyvals_get_val(comments, "artistsort");
	}

	if (!val || strcmp(val, "") == 0)
		return NULL;

	return val;
}

int comments_get_int(const struct keyval *comments, const char *key)
{
	const char *val;
	long int ival;

	val = keyvals_get_val(comments, key);
	if (val == NULL)
		return -1;
	while (*val && !(*val >= '0' && *val <= '9'))
		val++;
	if (str_to_int(val, &ival) == -1)
		return -1;
	return ival;
}

int comments_get_signed_int(const struct keyval *comments, const char *key, long int *ival)
{
	const char *val;

	val = keyvals_get_val(comments, key);
	if (val == NULL)
		return -1;
	while (*val && !(*val == '+' || *val == '-' || (*val >= '0' && *val <= '9')))
		val++;
	return str_to_int(val, ival);
}

double comments_get_double(const struct keyval *comments, const char *key)
{
	const char *val;
	char *end;
	double d;

	val = keyvals_get_val(comments, key);
	if (!val || strcmp(val, "") == 0)
		goto error;

	d = strtod(val, &end);
	if (val == end)
		goto error;

	return d;

error:
	return strtod("NAN", NULL);
}

/* Return date as an integer in the form YYYYMMDD, for sorting purposes.
 * This function is not year 10000 compliant. */
int comments_get_date(const struct keyval *comments, const char *key)
{
	const char *val;
	char *endptr;
	int year, month, day;
	long int ival;

	val = keyvals_get_val(comments, key);
	if (val == NULL)
		return -1;

	year = strtol(val, &endptr, 10);
	/* Looking for a four-digit number */
	if (year < 1000 || year > 9999)
		return -1;
	ival = year * 10000;

	if (*endptr == '-' || *endptr == ' ' || *endptr == '/') {
		month = strtol(endptr+1, &endptr, 10);
		if (month < 1 || month > 12)
			return ival;
		ival += month * 100;
	}

	if (*endptr == '-' || *endptr == ' ' || *endptr == '/') {
		day = strtol(endptr+1, &endptr, 10);
		if (day < 1 || day > 31)
			return ival;
		ival += day;
	}


	return ival;
}

static const char *interesting[] = {
	"artist", "album", "title", "tracknumber", "discnumber", "genre",
	"date", "compilation", "partofacompilation", "albumartist", "artistsort", "albumartistsort",
	"albumsort",
	"originaldate",
	"r128_track_gain",
	"r128_album_gain",
	"replaygain_track_gain",
	"replaygain_track_peak",
	"replaygain_album_gain",
	"replaygain_album_peak",
	"musicbrainz_trackid",
	"comment",
	"bpm",
	"arranger", "composer", "conductor", "lyricist", "performer",
	"remixer", "label", "publisher", "work", "opus", "partnumber", "part",
	"subtitle", "media",
	NULL
};

static struct {
	const char *old;
	const char *new;
} key_map[] = {
	{ "album_artist", "albumartist" },
	{ "album artist", "albumartist" },
	{ "disc", "discnumber" },
	{ "tempo", "bpm" },
	{ "track", "tracknumber" },
	{ "WM/Year", "date" },
	{ "WM/ArtistSortOrder", "artistsort" },
	{ "WM/AlbumArtistSortOrder", "albumartistsort" },
	{ "WM/AlbumSortOrder", "albumsort" },
	{ "WM/OriginalReleaseYear", "originaldate" },
	{ "WM/Media", "media" },
	{ "sourcemedia", "media" },
	{ "MusicBrainz Track Id", "musicbrainz_trackid" },
	{ "version", "subtitle" },
	/* ffmpeg id3 */
	{ "artist-sort", "artistsort" },
	{ "TSO2", "albumartistsort" },
	{ "album-sort", "albumsort" },
	/* ffmpeg mp4 */
	{ "sort_artist", "artistsort" },
	{ "sort_album_artist", "albumartistsort" },
	{ "sort_album", "albumsort" },
	{ NULL, NULL }
};

static const char *fix_key(const char *key)
{
	int i;

	for (i = 0; interesting[i]; i++) {
		if (!strcasecmp(key, interesting[i]))
			return interesting[i];
	}
	for (i = 0; key_map[i].old; i++) {
		if (!strcasecmp(key, key_map[i].old))
			return key_map[i].new;
	}
	return NULL;
}

int comments_add(struct growing_keyvals *c, const char *key, char *val)
{
	if (!strcasecmp(key, "songwriter")) {
		int r = comments_add_const(c, "lyricist", val);
		return comments_add(c, "composer", val) && r;
	}

	key = fix_key(key);
	if (!key) {
		free(val);
		return 0;
	}

	if (!strcmp(key, "tracknumber") || !strcmp(key, "discnumber")) {
		char *slash = strchr(val, '/');
		if (slash)
			*slash = 0;
	}

	/* don't add duplicates */
	if (keyvals_get_val_growing(c, key)) {
		free(val);
		return 0;
	}

	keyvals_add(c, key, val);
	return 1;
}

int comments_add_const(struct growing_keyvals *c, const char *key, const char *val)
{
	return comments_add(c, key, xstrdup(val));
}
#include "convert.h"
#include "xmalloc.h"
#include "uchar.h"
#ifdef HAVE_CONFIG
#include "config/iconv.h"
#endif

#ifdef HAVE_ICONV
#include <iconv.h>
#endif
#include <string.h>
#include <errno.h>

ssize_t convert(const char *inbuf, ssize_t inbuf_size,
		char **outbuf, ssize_t outbuf_estimate,
		const char *tocode, const char *fromcode)
{
#ifdef HAVE_ICONV
	const char *in;
	char *out;
	size_t rc, outbuf_size, inbytesleft, outbytesleft;
	iconv_t cd;
	int finished = 0, err_save;

	cd = iconv_open(tocode, fromcode);
	if (cd == (iconv_t) -1)
		return -1;

	if (inbuf_size < 0)
		inbuf_size = strlen(inbuf);
	inbytesleft = inbuf_size;

	if (outbuf_estimate < 0)
		outbuf_size = inbuf_size;
	else
		outbuf_size = outbuf_estimate;
	outbytesleft = outbuf_size;

	in = inbuf;
	out = *outbuf = xnew(char, outbuf_size + 1);

	while (!finished) {
		finished = 1;
		rc = iconv(cd, (char **)&in, &inbytesleft, &out, &outbytesleft);
		if (rc == (size_t) -1) {
			if (errno == E2BIG) {
				size_t used = out - *outbuf;
				outbytesleft += outbuf_size;
				outbuf_size *= 2;
				*outbuf = xrenew(char, *outbuf, outbuf_size + 1);
				out = *outbuf + used;
				continue;
			} else if (errno != EINVAL)
				goto error;
		}
	}
	/* NUL-terminate for safety reasons */
	*out = '\0';
	iconv_close(cd);
	return outbuf_size - outbytesleft;

error:
	err_save = errno;
	free(*outbuf);
	*outbuf = NULL;
	iconv_close(cd);
	errno = err_save;
	return -1;

#else
	if (inbuf_size < 0)
		inbuf_size = strlen(inbuf);
	*outbuf = xnew(char, inbuf_size + 1);
	memcpy(*outbuf, inbuf, inbuf_size);
	(*outbuf)[inbuf_size] = '\0';
	return inbuf_size;
#endif
}

int utf8_encode(const char *inbuf, const char *encoding, char **outbuf)
{
	size_t inbuf_size, outbuf_size, i;
	int rc;

	inbuf_size = strlen(inbuf);
	outbuf_size = inbuf_size;
	for (i = 0; i < inbuf_size; i++) {
		unsigned char ch;

		ch = inbuf[i];
		if (ch > 127)
			outbuf_size++;
	}

	rc = convert(inbuf, inbuf_size, outbuf, outbuf_size, "UTF-8", encoding);

	return rc < 0 ? -1 : 0;
}

char *to_utf8(const char *str, const char *enc)
{
	char *outbuf = NULL;
	int rc;

	if (u_is_valid(str)) {
		return xstrdup(str);
	} else {
		rc = utf8_encode(str, enc, &outbuf);
		return rc < 0 ? xstrdup(str) : outbuf;
	}
}
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

#include "cue.h"
#include "xmalloc.h"
#include "file.h"
#include "list.h"

#define ASCII_LOWER_TO_UPPER(c) ((c) & ~0x20)

struct cue_track_proto {
	struct list_head node;

	uint32_t nr;
	int32_t pregap;
	int32_t postgap;
	int32_t index0;
	int32_t index1;

	struct cue_meta meta;
};

struct cue_parser {
	const char *src;
	size_t len;
	bool err;

	char *file;
	struct list_head tracks;
	size_t num_tracks;

	struct cue_meta meta;
};

struct cue_switch {
	const char *cmd;
	void (*parser)(struct cue_parser *p);
};

static struct cue_track_proto *cue_proto_from_node(struct list_head *n)
{
	return container_of(n, struct cue_track_proto, node);
}

static struct cue_track_proto *cue_last_proto(struct cue_parser *p)
{
	if (p->num_tracks == 0)
		return NULL;
	return cue_proto_from_node(p->tracks.prev);
}

static inline void cue_consume(struct cue_parser *p)
{
	p->len--;
	p->src++;
}

static void cue_set_err(struct cue_parser *p)
{
	p->err = true;
}

static bool cue_str_eq(const char *a, size_t a_len, const char *b, size_t b_len)
{
	if (a_len != b_len)
		return false;
	for (size_t i = 0; i < a_len; i++) {
		if (ASCII_LOWER_TO_UPPER(a[i]) != ASCII_LOWER_TO_UPPER(b[i]))
			return false;
	}
	return true;
}

static void cue_skip_spaces(struct cue_parser *p)
{
	while (p->len > 0 && (*p->src == ' ' || *p->src == '\t'))
		cue_consume(p);
}

static size_t cue_extract_token(struct cue_parser *p, const char **start)
{
	cue_skip_spaces(p);

	bool quoted = p->len > 0 && *p->src == '"';
	if (quoted)
		cue_consume(p);

	*start = p->src;

	while (p->len > 0) {
		char c = *p->src;
		if (c == '\n' || c == '\r')
			break;
		if (quoted) {
			if (c == '"')
				break;
		} else {
			if (c == ' ' || c == '\t')
				break;
		}
		cue_consume(p);
	}

	if (quoted) {
		size_t len = p->src - *start;
		if (p->len > 0 && *p->src == '"')
			cue_consume(p);
		return len;
	}

	return p->src - *start;
}

static void cue_skip_line(struct cue_parser *p)
{
	while (p->len > 0 && *p->src != '\n' && *p->src != '\r')
		cue_consume(p);

	if (p->len > 0) {
		char c = *p->src;
		cue_consume(p);
		if (p->len > 0 && c == '\r' && *p->src == '\n')
			cue_consume(p);
	}
}

static char *cue_strdup(const char *start, size_t len)
{
	char *s = xnew(char, len + 1);
	s[len] = 0;
	memcpy(s, start, len);
	return s;
}

static uint32_t cue_parse_int(struct cue_parser *p, const char *start, size_t len)
{
	uint32_t val = 0;
	for (size_t i = 0; i < len; i++) {
		if (!isdigit(start[i])) {
			cue_set_err(p);
			return 0;
		}
		val = val * 10 + start[i] - '0';
	}
	return val;
}

static void cue_parse_str(struct cue_parser *p, char **dst)
{
	const char *start;
	size_t len = cue_extract_token(p, &start);
	if (!*dst)
		*dst = cue_strdup(start, len);
}

#define CUE_PARSE_STR(field) \
	static void cue_parse_##field(struct cue_parser *p) \
	{ \
		struct cue_track_proto *t = cue_last_proto(p); \
		if (t) \
			cue_parse_str(p, &t->meta.field); \
		else \
			cue_parse_str(p, &p->meta.field); \
	}

CUE_PARSE_STR(performer)
CUE_PARSE_STR(songwriter)
CUE_PARSE_STR(title)
CUE_PARSE_STR(genre)
CUE_PARSE_STR(date)
CUE_PARSE_STR(comment)
CUE_PARSE_STR(compilation);
CUE_PARSE_STR(discnumber);

static void cue_parse_file(struct cue_parser *p)
{
	cue_parse_str(p, &p->file);
}

static void cue_parse_track(struct cue_parser *p)
{
	const char *nr;
	size_t len = cue_extract_token(p, &nr);

	uint32_t d = cue_parse_int(p, nr, len);
	if (p->err)
		return;

	struct cue_track_proto *t = xnew(struct cue_track_proto, 1);
	*t = (struct cue_track_proto) {
		.nr = d,
		.pregap = -1,
		.postgap = -1,
		.index0 = -1,
		.index1 = -1,
	};

	list_add_tail(&t->node, &p->tracks);
	p->num_tracks++;
}

static uint32_t cue_parse_time(struct cue_parser *p, const char *start, size_t len)
{
	uint32_t vals[] = { 0, 0, 0 };
	uint32_t *val = vals;
	for (size_t i = 0; i < len; i++) {
		if (start[i] == ':') {
			if (val != &vals[2]) {
				val++;
				continue;
			}
			break;
		}
		if (!isdigit(start[i])) {
			cue_set_err(p);
			return 0;
		}
		*val = *val * 10 + start[i] - '0';
	}
	return (vals[0] * 60 + vals[1]) * 75 + vals[2];
}

static void cue_parse_index(struct cue_parser *p)
{
	const char *nr;
	size_t nr_len = cue_extract_token(p, &nr);

	uint32_t d = cue_parse_int(p, nr, nr_len);
	if (p->err || d > 1)
		return;

	const char *offset_str;
	size_t offset_len = cue_extract_token(p, &offset_str);

	uint32_t offset = cue_parse_time(p, offset_str, offset_len);
	if (p->err)
		return;

	struct cue_track_proto *last = cue_last_proto(p);
	if (!last)
		return;

	if (d == 0)
		last->index0 = offset;
	else
		last->index1 = offset;
}

static void cue_parse_cmd(struct cue_parser *p, struct cue_switch *s)
{
	const char *start;
	size_t len = cue_extract_token(p, &start);

	while (s->cmd) {
		if (cue_str_eq(start, len, s->cmd, strlen(s->cmd))) {
			s->parser(p);
			return;
		}
		s++;
	}
}

static void cue_parse_rem(struct cue_parser *p)
{
	struct cue_switch cmds[] = {
		{ "DATE",        cue_parse_date        },
		{ "GENRE",       cue_parse_genre       },
		{ "COMMENT",     cue_parse_comment     },
		{ "COMPILATION", cue_parse_compilation },
		{ "DISCNUMBER",  cue_parse_discnumber  },
		{ 0 },
	};

	cue_parse_cmd(p, cmds);
}

static void cue_parse_gap(struct cue_parser *p, bool post)
{
	const char *gap_str;
	size_t gap_len = cue_extract_token(p, &gap_str);

	uint32_t gap = cue_parse_time(p, gap_str, gap_len);
	if (p->err)
		return;

	struct cue_track_proto *last = cue_last_proto(p);
	if (!last)
		return;

	if (post)
		last->postgap = gap;
	else
		last->pregap = gap;
}

static void cue_parse_pregap(struct cue_parser *p)
{
	cue_parse_gap(p, false);
}

static void cue_parse_postgap(struct cue_parser *p)
{
	cue_parse_gap(p, true);
}

static void cue_parse_line(struct cue_parser *p)
{
	struct cue_switch cmds[] = {
		{ "FILE",       cue_parse_file       },
		{ "PERFORMER",  cue_parse_performer  },
		{ "SONGWRITER", cue_parse_songwriter },
		{ "TITLE",      cue_parse_title      },
		{ "TRACK",      cue_parse_track      },
		{ "INDEX",      cue_parse_index      },
		{ "REM",        cue_parse_rem        },
		{ "PREGAP",     cue_parse_pregap     },
		{ "POSTGAP",    cue_parse_postgap    },
		{ 0 },
	};

	cue_parse_cmd(p, cmds);
	cue_skip_line(p);
}

static void cue_post_process(struct cue_parser *p)
{
	if (!p->file || p->num_tracks == 0) {
		cue_set_err(p);
		return;
	}

	struct cue_track_proto *t;

	int32_t last = -1;

	list_for_each_entry(t, &p->tracks, node) {
		if (last != -1 && t->nr != last + 1) {
			cue_set_err(p);
			return;
		}
		last = t->nr;
	}

	last = -1;

	list_for_each_entry(t, &p->tracks, node) {
		if (t->index0 == -1 && t->index1 == -1) {
			cue_set_err(p);
			return;
		}
		if (t->index0 == -1 || t->index1 == -1) {
			int32_t pregap = t->pregap != -1 ? t->pregap : 0;
			if (t->index1 != -1)
				t->index0 = t->index1 - pregap;
			else
				t->index1 = t->index0 + pregap;
		}
		if (last != -1 && t->index0 < last) {
			cue_set_err(p);
			return;
		}
		int32_t postgap = t->postgap != -1 ? t->postgap : 0;
		last = t->index1 + postgap;
	}
}

static void cue_meta_move(struct cue_meta *l, struct cue_meta *r)
{
	*l = *r;
	*r = (struct cue_meta) { 0 };
}

static struct cue_sheet *cue_parser_to_sheet(struct cue_parser *p)
{
	struct cue_sheet *s = xnew(struct cue_sheet, 1);

	s->file = p->file;
	p->file = NULL;

	s->tracks = xnew(struct cue_track, p->num_tracks);
	s->num_tracks = p->num_tracks;
	s->track_base = cue_last_proto(p)->nr + 1 - p->num_tracks;

	cue_meta_move(&s->meta, &p->meta);

	size_t idx = 0;
	struct cue_track_proto *t, *prev;
	list_for_each_entry(t, &p->tracks, node) {
		s->tracks[idx].offset = t->index1 / 75.0;
		s->tracks[idx].length = -1;

		if (idx > 0) {
			int32_t postgap = prev->postgap != -1 ? prev->postgap : 0;
			s->tracks[idx - 1].length =
				(t->index1 - prev->index1 - postgap) / 75.0;
		}

		cue_meta_move(&s->tracks[idx].meta, &t->meta);

		prev = t;
		idx++;
	}

	return s;
}

static void cue_meta_free(struct cue_meta *m)
{
	free(m->performer);
	free(m->songwriter);
	free(m->title);
	free(m->genre);
	free(m->date);
	free(m->comment);
	free(m->compilation);
}

static void cue_parser_free(struct cue_parser *p)
{
	struct cue_track_proto *t, *next;
	list_for_each_entry_safe(t, next, &p->tracks, node) {
		cue_meta_free(&t->meta);
		free(t);
	}

	free(p->file);
	cue_meta_free(&p->meta);
}

struct cue_sheet *cue_parse(const char *src, size_t len)
{
	struct cue_sheet *res = NULL;

	struct cue_parser p = {
		.src = src,
		.len = len,
	};
	list_init(&p.tracks);

	while (p.len > 0 && !p.err)
		cue_parse_line(&p);

	if (p.err)
		goto out;

	cue_post_process(&p);

	if (p.err)
		goto out;

	res = cue_parser_to_sheet(&p);

out:
	cue_parser_free(&p);
	return res;
}

struct cue_sheet *cue_from_file(const char *file)
{
	ssize_t size;
	char *buf = mmap_file(file, &size);
	if (size == -1)
		return NULL;
	struct cue_sheet *rv;

	// Check for UTF-8 BOM, and skip ahead if found
	if (size >= 3 && memcmp(buf, "\xEF\xBB\xBF", 3) == 0) {
		rv = cue_parse(buf + 3, size - 3);
	} else {
		rv = cue_parse(buf, size);
	}

	munmap(buf, size);
	return rv;
}

void cue_free(struct cue_sheet *s)
{
	free(s->file);

	for (size_t i = 0; i < s->num_tracks; i++)
		cue_meta_free(&s->tracks[i].meta);
	free(s->tracks);

	cue_meta_free(&s->meta);
	free(s);
}
#include "path.h"
#include "utils.h"
#include "cue_utils.h"
#include "xmalloc.h"
#include "cue.h"

#include <stdio.h>

char *associated_cue(const char *filename)
{
	FILE *fp;
	const char *ext;
	char buf[4096] = {0};
	const char *dot;

	ext = get_extension(filename);
	if (ext != NULL && strcmp(ext, "cue") == 0)
		return NULL;

	dot = strrchr(filename, '.');
	if (dot == NULL)
		return NULL;

	snprintf(buf, sizeof buf, "%.*s.cue", (int) (dot - filename), filename);
	fp = fopen(buf, "r");
	if (!fp)
		snprintf(buf, sizeof buf, "%s.cue", filename);
	else
		fclose(fp);

	return xstrdup(buf);
}


int cue_get_ntracks(const char *filename)
{
	struct cue_sheet *cd = cue_from_file(filename);
	if (!cd)
		return -1;
	size_t n = cd->num_tracks;
	cue_free(cd);
	return n;
}


char *construct_cue_url(const char *cue_filename, int track_n)
{
	char buf[4096] = {0};

	snprintf(buf, sizeof buf, "cue://%s/%d", cue_filename, track_n);

	return xstrdup(buf);
}
#include "debug.h"
#include "prog.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <sys/time.h>

#if DEBUG > 1
static FILE *debug_stream = NULL;
#endif

void debug_init(void)
{
#if DEBUG > 1
	char filename[512];
	const char *dir = getenv("CMUS_HOME");

	if (!dir || !dir[0]) {
		dir = getenv("HOME");
		if (!dir)
			die("error: environment variable HOME not set\n");
	}
	snprintf(filename, sizeof(filename), "%s/cmus-debug.txt", dir);

	debug_stream = fopen(filename, "w");
	if (debug_stream == NULL)
		die_errno("error opening `%s' for writing", filename);
#endif
}

/* This function must be defined even if debugging is disabled in the program
 * because debugging might still be enabled in some plugin.
 */
void _debug_bug(const char *function, const char *fmt, ...)
{
	const char *format = "\n%s: BUG: ";
	va_list ap;

	/* debug_stream exists only if debugging is enabled */
#if DEBUG > 1
	fprintf(debug_stream, format, function);
	va_start(ap, fmt);
	vfprintf(debug_stream, fmt, ap);
	va_end(ap);
#endif

	/* always print bug message to stderr */
	fprintf(stderr, format, function);
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	exit(127);
}

void _debug_print(const char *function, const char *fmt, ...)
{
#if DEBUG > 1
	va_list ap;

	fprintf(debug_stream, "%s: ", function);
	va_start(ap, fmt);
	vfprintf(debug_stream, fmt, ap);
	va_end(ap);
	fflush(debug_stream);
#endif
}

uint64_t timer_get(void)
{
#if DEBUG > 1
	struct timeval tv;

	gettimeofday(&tv, NULL);
	return tv.tv_sec * 1e6L + tv.tv_usec;
#else
	return 0;
#endif
}

void timer_print(const char *what, uint64_t usec)
{
#if DEBUG > 1
	uint64_t a = usec / 1e6;
	uint64_t b = usec - a * 1e6;

	_debug_print("TIMER", "%s: %11u.%06u\n", what, (unsigned int)a, (unsigned int)b);
#endif
}
#include "discid.h"
#include "xmalloc.h"
#include "path.h"
#include "utils.h"
#include "debug.h"

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <limits.h>

#ifdef HAVE_DISCID
#include <discid/discid.h>
#endif

char *get_default_cdda_device(void)
{
	const char *dev = NULL;
#ifdef HAVE_DISCID
	dev = discid_get_default_device();
#endif
	if (!dev)
		dev = "/dev/cdrom";
	return xstrdup(dev);
}

int parse_cdda_url(const char *url, char **disc_id, int *start_track, int *end_track)
{
	char *slash, *dash;
	long int t;

	if (!is_cdda_url(url))
		return 0;
	url += 7;

	slash = strrchr(url, '/');
	if (slash) {
		*disc_id = xstrndup(url, slash - url);
		url = slash + 1;
	}
	dash = strchr(url, '-');
	if (dash) {
		char *tmp = xstrndup(url, dash - url);
		if (str_to_int(tmp, &t) == 0)
			*start_track = t;
		if (end_track) {
			if (str_to_int(dash + 1, &t) == 0)
				*end_track = t;
			else
				*end_track = INT_MAX;
		}
		free(tmp);
	} else {
		if (str_to_int(url, &t) == 0)
			*start_track = t;
	}

	return 1;
}

char *gen_cdda_url(const char *disc_id, int start_track, int end_track)
{
	char buf[256];
	if (end_track != -1)
		snprintf(buf, sizeof(buf), "cdda://%s/%d-%d", disc_id, start_track, end_track);
	else
		snprintf(buf, sizeof(buf), "cdda://%s/%d", disc_id, start_track);
	return xstrdup(buf);
}

char *complete_cdda_url(const char *device, const char *url)
{
	char *new_url, *url_disc_id = NULL, *disc_id = NULL;
	int is_range, start_track = -1, end_track = -1, num_tracks = -1;

	parse_cdda_url(url, &url_disc_id, &start_track, &end_track);
	is_range = (start_track == -1 && end_track == -1) || end_track == INT_MAX;
	if (!url_disc_id || is_range) {
		if (url_disc_id && strchr(url_disc_id, '/'))
			device = url_disc_id;
		get_disc_id(device, &disc_id, &num_tracks);
		if (is_range)
			end_track = num_tracks;
		if (!url_disc_id)
			url_disc_id = disc_id;
	}
	if (start_track == -1)
		start_track = 1;

	new_url = gen_cdda_url(url_disc_id, start_track, end_track);
	free(disc_id);

	return new_url;
}

static int get_device_disc_id(const char *device, char **disc_id, int *num_tracks)
{
#ifdef HAVE_DISCID
	DiscId *disc = discid_new();
	if (!disc)
		return 0;

	if (!discid_read(disc, device)) {
		d_print("%s\n", discid_get_error_msg(disc));
		discid_free(disc);
		return 0;
	}

	*disc_id = xstrdup(discid_get_id(disc));
	if (num_tracks)
		*num_tracks = discid_get_last_track_num(disc);

	discid_free(disc);
	return 1;
#else
	return 0;
#endif
}

int get_disc_id(const char *device, char **disc_id, int *num_tracks)
{
	struct stat st;

	if (stat(device, &st) == -1)
		return 0;

	if (S_ISBLK(st.st_mode))
		return get_device_disc_id(device, disc_id, num_tracks);

	*disc_id = path_absolute(device);
	return 1;
}
#include "editable.h"
#include "search.h"
#include "track.h"
#include "track_info.h"
#include "expr.h"
#include "filters.h"
#include "locking.h"
#include "mergesort.h"
#include "xmalloc.h"

static const struct searchable_ops simple_search_ops = {
	.get_prev = simple_track_get_prev,
	.get_next = simple_track_get_next,
	.get_current = simple_track_search_get_current,
	.matches = simple_track_search_matches
};

static struct simple_track *get_selected(struct editable *e)
{
	struct iter sel;

	if (window_get_sel(e->shared->win, &sel))
		return iter_to_simple_track(&sel);
	return NULL;
}

void editable_shared_init(struct editable_shared *shared,
		editable_free_track free_track)
{
	shared->win = window_new(simple_track_get_prev, simple_track_get_next);
	shared->sort_keys = xnew(sort_key_t, 1);
	shared->sort_keys[0] = SORT_INVALID;
	shared->sort_str[0] = 0;
	shared->free_track = free_track;
	shared->owner = NULL;

	struct iter iter = { 0 };
	shared->searchable = searchable_new(shared->win, &iter,
			&simple_search_ops);
}

void editable_init(struct editable *e, struct editable_shared *shared,
		int take_ownership)
{
	list_init(&e->head);
	e->tree_root = RB_ROOT;
	e->nr_tracks = 0;
	e->nr_marked = 0;
	e->total_time = 0;
	e->shared = shared;


	if (take_ownership)
		editable_take_ownership(e);
}

static int editable_owns_shared(struct editable *e)
{
	return e->shared->owner == e;
}

void editable_take_ownership(struct editable *e)
{
	if (!editable_owns_shared(e)) {
		e->shared->owner = e;
		window_set_contents(e->shared->win, &e->head);
		e->shared->win->changed = 1;

		struct iter iter = { .data0 = &e->head };
		searchable_set_head(e->shared->searchable, &iter);
	}
}

static void do_editable_add(struct editable *e, struct simple_track *track, int tiebreak)
{
	sorted_list_add_track(&e->head, &e->tree_root, track,
			e->shared->sort_keys, tiebreak);
	e->nr_tracks++;
	if (track->info->duration != -1)
		e->total_time += track->info->duration;
	if (editable_owns_shared(e))
		window_changed(e->shared->win);
}

void editable_add(struct editable *e, struct simple_track *track)
{
	do_editable_add(e, track, +1);
}

void editable_add_before(struct editable *e, struct simple_track *track)
{
	do_editable_add(e, track, -1);
}

void editable_remove_track(struct editable *e, struct simple_track *track)
{
	struct track_info *ti = track->info;
	struct iter iter;

	editable_track_to_iter(e, track, &iter);
	if (editable_owns_shared(e))
		window_row_vanishes(e->shared->win, &iter);

	e->nr_tracks--;
	e->nr_marked -= track->marked;
	if (ti->duration != -1)
		e->total_time -= ti->duration;

	sorted_list_remove_track(&e->head, &e->tree_root, track);
	e->shared->free_track(e, &track->node);
}

void editable_remove_sel(struct editable *e)
{
	struct simple_track *t;

	if (e->nr_marked) {
		/* treat marked tracks as selected */
		struct list_head *next, *item = e->head.next;

		while (item != &e->head) {
			next = item->next;
			t = to_simple_track(item);
			if (t->marked)
				editable_remove_track(e, t);
			item = next;
		}
	} else {
		t = get_selected(e);
		if (t)
			editable_remove_track(e, t);
	}
}

void editable_sort(struct editable *e)
{
	if (e->nr_tracks <= 1)
		return;
	sorted_list_rebuild(&e->head, &e->tree_root, e->shared->sort_keys);

	if (editable_owns_shared(e)) {
		window_changed(e->shared->win);
		window_goto_top(e->shared->win);
	}
}

void editable_shared_set_sort_keys(struct editable_shared *shared,
		sort_key_t *keys)
{
	free(shared->sort_keys);
	shared->sort_keys = keys;
}

void editable_toggle_mark(struct editable *e)
{
	struct simple_track *t;

	t = get_selected(e);
	if (t) {
		e->nr_marked -= t->marked;
		t->marked ^= 1;
		e->nr_marked += t->marked;
		if (editable_owns_shared(e)) {
			e->shared->win->changed = 1;
			window_down(e->shared->win, 1);
		}
	}
}

static void move_item(struct editable *e, struct list_head *head, struct list_head *item)
{
	struct simple_track *t = to_simple_track(item);
	struct iter iter;

	editable_track_to_iter(e, t, &iter);
	if (editable_owns_shared(e))
		window_row_vanishes(e->shared->win, &iter);

	list_del(item);
	list_add(item, head);
}

static void reset_tree(struct editable *e)
{
	struct simple_track *old, *first_track;

	old = tree_node_to_simple_track(rb_first(&e->tree_root));
	first_track = to_simple_track(e->head.next);
	if (old != first_track) {
		rb_replace_node(&old->tree_node, &first_track->tree_node, &e->tree_root);
		RB_CLEAR_NODE(&old->tree_node);
	}
}

static void move_sel(struct editable *e, struct list_head *after)
{
	struct simple_track *t;
	struct list_head *item, *next;
	struct iter iter;
	LIST_HEAD(tmp_head);

	if (e->nr_marked) {
		/* collect marked */
		item = e->head.next;
		while (item != &e->head) {
			t = to_simple_track(item);
			next = item->next;
			if (t->marked)
				move_item(e, &tmp_head, item);
			item = next;
		}
	} else {
		/* collect the selected track */
		t = get_selected(e);
		if (t)
			move_item(e, &tmp_head, &t->node);
	}

	/* put them back to the list after @after */
	item = tmp_head.next;
	while (item != &tmp_head) {
		next = item->next;
		list_add(item, after);
		item = next;
	}
	reset_tree(e);

	/* select top-most of the moved tracks */
	editable_track_to_iter(e, to_simple_track(after->next), &iter);

	if (editable_owns_shared(e)) {
		window_changed(e->shared->win);
		window_set_sel(e->shared->win, &iter);
	}
}

static struct list_head *find_insert_after_point(struct editable *e, struct list_head *item)
{
	if (e->nr_marked == 0) {
		/* move the selected track down one row */
		return item->next;
	}

	/* move marked after the selected
	 *
	 * if the selected track itself is marked we find the first unmarked
	 * track (or head) before the selected one
	 */
	while (item != &e->head) {
		struct simple_track *t = to_simple_track(item);

		if (!t->marked)
			break;
		item = item->prev;
	}
	return item;
}

static struct list_head *find_insert_before_point(struct editable *e, struct list_head *item)
{
	item = item->prev;
	if (e->nr_marked == 0) {
		/* move the selected track up one row */
		return item->prev;
	}

	/* move marked before the selected
	 *
	 * if the selected track itself is marked we find the first unmarked
	 * track (or head) before the selected one
	 */
	while (item != &e->head) {
		struct simple_track *t = to_simple_track(item);

		if (!t->marked)
			break;
		item = item->prev;
	}
	return item;
}

void editable_move_after(struct editable *e)
{
	struct simple_track *sel;

	if (e->nr_tracks <= 1 || e->shared->sort_keys[0] != SORT_INVALID)
		return;

	sel = get_selected(e);
	if (sel)
		move_sel(e, find_insert_after_point(e, &sel->node));
}

void editable_move_before(struct editable *e)
{
	struct simple_track *sel;

	if (e->nr_tracks <= 1 || e->shared->sort_keys[0] != SORT_INVALID)
		return;

	sel = get_selected(e);
	if (sel)
		move_sel(e, find_insert_before_point(e, &sel->node));
}

void editable_clear(struct editable *e)
{
	struct list_head *item, *tmp;

	list_for_each_safe(item, tmp, &e->head)
		editable_remove_track(e, to_simple_track(item));
}

void editable_remove_matching_tracks(struct editable *e,
		int (*cb)(void *data, struct track_info *ti), void *data)
{
	struct list_head *item, *tmp;

	list_for_each_safe(item, tmp, &e->head) {
		struct simple_track *t = to_simple_track(item);
		if (cb(data, t->info))
			editable_remove_track(e, t);
	}
}

void editable_mark(struct editable *e, const char *filter)
{
	struct expr *expr = NULL;
	struct simple_track *t;

	if (filter) {
		expr = parse_filter(filter);
		if (expr == NULL)
			return;
	}

	list_for_each_entry(t, &e->head, node) {
		e->nr_marked -= t->marked;
		t->marked = 0;
		if (expr == NULL || expr_eval(expr, t->info)) {
			t->marked = 1;
			e->nr_marked++;
		}
	}

	if (editable_owns_shared(e))
		e->shared->win->changed = 1;
}

void editable_unmark(struct editable *e)
{
	struct simple_track *t;

	list_for_each_entry(t, &e->head, node) {
		e->nr_marked -= t->marked;
		t->marked = 0;
	}

	if (editable_owns_shared(e))
		e->shared->win->changed = 1;
}

void editable_invert_marks(struct editable *e)
{
	struct simple_track *t;

	list_for_each_entry(t, &e->head, node) {
		e->nr_marked -= t->marked;
		t->marked ^= 1;
		e->nr_marked += t->marked;
	}

	if (editable_owns_shared(e))
		e->shared->win->changed = 1;
}

int _editable_for_each_sel(struct editable *e, track_info_cb cb, void *data,
		int reverse)
{
	int rc = 0;

	if (e->nr_marked) {
		/* treat marked tracks as selected */
		rc = simple_list_for_each_marked(&e->head, cb, data, reverse);
	} else {
		struct simple_track *t = get_selected(e);

		if (t)
			rc = cb(data, t->info);
	}
	return rc;
}

int editable_for_each_sel(struct editable *e, track_info_cb cb, void *data,
		int reverse, int advance)
{
	int rc;

	rc = _editable_for_each_sel(e, cb, data, reverse);
	if (advance && e->nr_marked == 0 && editable_owns_shared(e))
		window_down(e->shared->win, 1);
	return rc;
}

int editable_for_each(struct editable *e, track_info_cb cb, void *data,
		int reverse)
{
	return simple_list_for_each(&e->head, cb, data, reverse);
}

void editable_update_track(struct editable *e, struct track_info *old, struct track_info *new)
{
	struct list_head *item, *tmp;
	int changed = 0;

	list_for_each_safe(item, tmp, &e->head) {
		struct simple_track *track = to_simple_track(item);
		if (track->info == old) {
			if (new) {
				track_info_unref(old);
				track_info_ref(new);
				track->info = new;
			} else {
				editable_remove_track(e, track);
			}
			changed = 1;
		}
	}
	if (editable_owns_shared(e))
		e->shared->win->changed |= changed;
}

void editable_rand(struct editable *e)
{
	if (e->nr_tracks <=1)
		return;
	rand_list_rebuild(&e->head, &e->tree_root);

	if (editable_owns_shared(e)) {
		window_changed(e->shared->win);
		window_goto_top(e->shared->win);
	}
}

int editable_empty(struct editable *e)
{
	return list_empty(&e->head);
}
#include "expr.h"
#include "glob.h"
#include "uchar.h"
#include "track_info.h"
#include "comment.h"
#include "xmalloc.h"
#include "utils.h"
#include "debug.h"
#include "list.h"
#include "ui_curses.h" /* using_utf8, charset */
#include "convert.h"

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdarg.h>
#include <limits.h>

enum token_type {
	/* special chars */
	TOK_NOT,
	TOK_LT,
	TOK_GT,

#define NR_COMBINATIONS TOK_EQ

	/* special chars */
	TOK_EQ,
	TOK_AND,
	TOK_OR,
	TOK_LPAREN,
	TOK_RPAREN,

#define NR_SPECIALS TOK_NE
#define COMB_BASE TOK_NE

	/* same as the first 3 + '=' */
	TOK_NE,
	TOK_LE,
	TOK_GE,

	TOK_KEY,
	TOK_INT_OR_KEY,
	TOK_STR
};
#define NR_TOKS (TOK_STR + 1)

struct token {
	struct list_head node;
	enum token_type type;
	/* for TOK_KEY, TOK_INT_OR_KEY and TOK_STR */
	char str[];
};

/* same order as TOK_* */
static const char specials[NR_SPECIALS] = "!<>=&|()";

static const int tok_to_op[NR_TOKS] = {
	-1, OP_LT, OP_GT, OP_EQ, -1, -1, -1, -1, OP_NE, OP_LE, OP_GE, -1, -1, -1
};

static const char * const op_names[NR_OPS] = { "<", "<=", "=", ">=", ">", "!=" };
static const char * const expr_names[NR_EXPRS] = {
	"&", "|", "!", "a string", "an integer", "a boolean"
};

static char error_buf[64] = { 0, };


static void set_error(const char *format, ...)
{
	va_list ap;

	va_start(ap, format);
	vsnprintf(error_buf, sizeof(error_buf), format, ap);
	va_end(ap);
}

static struct token *get_str(const char *str, int *idxp)
{
	struct token *tok;
	int s = *idxp + 1;
	int e = s;

	/* can't remove all backslashes here => don't remove any */
	while (str[e] != '"') {
		int c = str[e];

		if (c == 0)
			goto err;
		if (c == '\\') {
			if (str[e + 1] == 0)
				goto err;
			e += 2;
			continue;
		}
		e++;
	}

	tok = xmalloc(sizeof(struct token) + e - s + 1);
	memcpy(tok->str, str + s, e - s);
	tok->str[e - s] = 0;
	tok->type = TOK_STR;
	*idxp = e + 1;
	return tok;
err:
	set_error("end of expression at middle of string");
	return NULL;
}

static struct token *get_int_or_key(const char *str, int *idxp)
{
	int s = *idxp;
	int e = s;
	int digits_only = 1;
	struct token *tok;

	if (str[e] == '-')
		e++;
	while (str[e]) {
		int i, c = str[e];

		if (isspace(c))
			goto out;
		for (i = 0; i < NR_SPECIALS; i++) {
			if (c == specials[i])
				goto out;
		}
		if (c < '0' || c > '9') {
			digits_only = 0;
			if (!isalpha(c) && c != '_' && c != '-') {
				set_error("unexpected '%c'", c);
				return NULL;
			}
		}
		e++;
	}
out:
	tok = xmalloc(sizeof(struct token) + e - s + 1);
	memcpy(tok->str, str + s, e - s);
	tok->str[e - s] = 0;
	tok->type = TOK_KEY;
	if (digits_only)
		tok->type = TOK_INT_OR_KEY;
	*idxp = e;
	return tok;
}

static struct token *get_token(const char *str, int *idxp)
{
	int idx = *idxp;
	int c, i;

	c = str[idx];
	for (i = 0; i < NR_SPECIALS; i++) {
		struct token *tok;

		if (c != specials[i])
			continue;

		idx++;
		tok = xnew(struct token, 1);
		tok->type = i;
		if (i < NR_COMBINATIONS && str[idx] == '=') {
			tok->type = COMB_BASE + i;
			idx++;
		}
		*idxp = idx;
		return tok;
	}
	if (c == '"')
		return get_str(str, idxp);
	return get_int_or_key(str, idxp);
}

static void free_tokens(struct list_head *head)
{
	struct list_head *item = head->next;

	while (item != head) {
		struct list_head *next = item->next;
		struct token *tok = container_of(item, struct token, node);

		free(tok);
		item = next;
	}
}

static int tokenize(struct list_head *head, const char *str)
{
	struct token *tok;
	int idx = 0;

	while (1) {
		while (isspace(str[idx]))
			++idx;
		if (str[idx] == 0)
			break;
		tok = get_token(str, &idx);
		if (tok == NULL) {
			free_tokens(head);
			return -1;
		}
		list_add_tail(&tok->node, head);
	}
	return 0;
}

static struct expr *expr_new(int type)
{
	struct expr *new = xnew0(struct expr, 1);

	new->type = type;

	return new;
}

static int parse(struct expr **rootp, struct list_head *head, struct list_head **itemp, int level);

static int parse_one(struct expr **exprp, struct list_head *head, struct list_head **itemp)
{
	struct list_head *item = *itemp;
	struct token *tok;
	enum token_type type;
	int rc;

	*exprp = NULL;
	if (item == head) {
		set_error("expression expected");
		return -1;
	}

	tok = container_of(item, struct token, node);
	type = tok->type;
	if (type == TOK_NOT) {
		struct expr *new, *tmp;

		*itemp = item->next;
		rc = parse_one(&tmp, head, itemp);
		if (rc)
			return rc;
		new = expr_new(EXPR_NOT);
		new->left = tmp;
		*exprp = new;
		return 0;
	} else if (type == TOK_LPAREN) {
		*itemp = item->next;
		*exprp = NULL;
		return parse(exprp, head, itemp, 1);
		/* ')' already eaten */
	} else if (type == TOK_KEY || type == TOK_INT_OR_KEY) {
		const char *key = tok->str;
		struct expr *new;
		int op = -1;

		item = item->next;
		if (item != head) {
			tok = container_of(item, struct token, node);
			op = tok_to_op[tok->type];
		}
		if (item == head || op == -1) {
			/* must be a bool */
			new = expr_new(EXPR_BOOL);
			new->key = xstrdup(key);
			*itemp = item;
			*exprp = new;
			return 0;
		}
		item = item->next;
		if (item == head) {
			set_error("right side of expression expected");
			return -1;
		}
		tok = container_of(item, struct token, node);
		type = tok->type;
		*itemp = item->next;
		if (type == TOK_STR) {
			if (op != OP_EQ && op != OP_NE) {
				set_error("invalid string operator '%s'", op_names[op]);
				return -1;
			}
			new = expr_new(EXPR_STR);
			new->key = xstrdup(key);
			glob_compile(&new->estr.glob_head, tok->str);
			new->estr.op = op;
			*exprp = new;
			return 0;
		} else if (type == TOK_INT_OR_KEY) {
			long int val = 0;

			if (str_to_int(tok->str, &val)) {
			}
			new = expr_new(EXPR_INT);
			new->key = xstrdup(key);
			new->eint.val = val;
			new->eint.op = op;
			*exprp = new;
			return 0;
		} else if (type == TOK_KEY) {
			new = expr_new(EXPR_ID);
			new->key = xstrdup(key);
			new->eid.key = xstrdup(tok->str);
			new->eid.op = op;
			*exprp = new;
			return 0;
		}
		if (op == OP_EQ || op == OP_NE) {
			set_error("integer or string expected");
		} else {
			set_error("integer expected");
		}
		return -1;
	}
	set_error("key expected");
	return -1;
}

static void add(struct expr **rootp, struct expr *expr)
{
	struct expr *tmp, *root = *rootp;

	if (root == NULL) {
		*rootp = expr;
		return;
	}

	tmp = root;
	while (tmp->right)
		tmp = tmp->right;
	if (tmp->type <= EXPR_OR) {
		/* tmp is binary, tree is incomplete */
		tmp->right = expr;
		expr->parent = tmp;
		return;
	}

	/* tmp is unary, tree is complete
	 * expr must be a binary operator */
	BUG_ON(expr->type > EXPR_OR);

	expr->left = root;
	root->parent = expr;
	*rootp = expr;
}

static int parse(struct expr **rootp, struct list_head *head, struct list_head **itemp, int level)
{
	struct list_head *item = *itemp;

	while (1) {
		struct token *tok;
		struct expr *expr;
		int rc, type;

		rc = parse_one(&expr, head, &item);
		if (rc)
			return rc;
		add(rootp, expr);
		if (item == head) {
			if (level > 0) {
				set_error("')' expected");
				return -1;
			}
			*itemp = item;
			return 0;
		}
		tok = container_of(item, struct token, node);
		if (tok->type == TOK_RPAREN) {
			if (level == 0) {
				set_error("unexpected ')'");
				return -1;
			}
			*itemp = item->next;
			return 0;
		}

		if (tok->type == TOK_AND) {
			type = EXPR_AND;
		} else if (tok->type == TOK_OR) {
			type = EXPR_OR;
		} else {
			set_error("'&' or '|' expected");
			return -1;
		}
		expr = expr_new(type);
		add(rootp, expr);
		item = item->next;
	}
}

static const struct {
	char short_key;
	const char *long_key;
} map_short2long[] = {
	{ 'A',	"albumartist"	},
	{ 'D',	"discnumber"	},
	{ 'T',	"tag",		},
	{ 'a',	"artist"	},
	{ 'c',	"comment"	},
	{ 'd',	"duration"	},
	{ 'f',	"filename"	},
	{ 'g',	"genre"		},
	{ 'l',	"album"		},
	{ 'n',	"tracknumber"	},
	{ 'X',	"play_count"	},
	{ 's',	"stream"	},
	{ 't',	"title"		},
	{ 'y',	"date"		},
	{ '\0',	NULL		},
};

static const struct {
	const char *key;
	enum expr_type type;
} builtin[] = {
	{ "album",	EXPR_STR	},
	{ "albumartist",EXPR_STR	},
	{ "artist",	EXPR_STR	},
	{ "bitrate",	EXPR_INT	},
	{ "bpm",	EXPR_INT	},
	{ "codec",	EXPR_STR	},
	{ "codec_profile",EXPR_STR	},
	{ "comment",	EXPR_STR	},
	{ "date",	EXPR_INT	},
	{ "discnumber", EXPR_INT	},
	{ "duration",	EXPR_INT	},
	{ "filename",	EXPR_STR	},
	{ "genre",	EXPR_STR	},
	{ "media",	EXPR_STR	},
	{ "originaldate",EXPR_INT	},
	{ "play_count", EXPR_INT	},
	{ "stream",	EXPR_BOOL	},
	{ "tag",	EXPR_BOOL	},
	{ "title",	EXPR_STR	},
	{ "tracknumber",EXPR_INT	},
	{ NULL,		-1		},
};

static const char *lookup_long_key(char c)
{
	int i;
	for (i = 0; map_short2long[i].short_key; i++) {
		if (map_short2long[i].short_key == c)
			return map_short2long[i].long_key;
	}
	return NULL;
}

static enum expr_type lookup_key_type(const char *key)
{
	int i;
	for (i = 0; builtin[i].key; i++) {
		int cmp = strcmp(key, builtin[i].key);
		if (cmp == 0)
			return builtin[i].type;
		if (cmp < 0)
			break;
	}
	return -1;
}

static unsigned long stack4_new(void)
{
	return 0;
}
static void stack4_push(unsigned long *s, unsigned long e)
{
	*s = (*s << 4) | e;
}
static void stack4_pop(unsigned long *s)
{
	*s = *s >> 4;
}
static unsigned long stack4_top(unsigned long s)
{
	return s & 0xf;
}
static void stack4_replace_top(unsigned long *s, unsigned long e)
{
	*s = (*s & ~0xf) | e;
}

static char *expand_short_expr(const char *expr_short)
{
	/* state space, can contain maximal 15 states */
	enum state_type {
		ST_SKIP_SPACE = 1,
		ST_TOP,
		ST_EXPECT_KEY,
		ST_EXPECT_OP,
		ST_EXPECT_INT,
		ST_IN_INT,
		ST_MEM_INT,
		ST_IN_2ND_INT,
		ST_EXPECT_STR,
		ST_IN_QUOTE_STR,
		ST_IN_STR,
	};

	size_t len_expr_short = strlen(expr_short);
	/* worst case blowup of expr_short is 31/5 (e.g. ~n1-2), so take x7:
	 * strlen("~n1-2") == 5
	 * strlen("(tracknumber>=1&tracknumber<=2)") == 31
	 */
	char *out = xnew(char, len_expr_short * 7);
	char *num = NULL;
	size_t i, i_num = 0, k = 0;
	const char *key = NULL;
	int level = 0;
	enum expr_type etype;
	/* used as state-stack, can contain at least 32/4 = 8 states */
	unsigned long state_stack = stack4_new();
	stack4_push(&state_stack, ST_TOP);
	stack4_push(&state_stack, ST_SKIP_SPACE);

	/* include terminal '\0' to recognize end of string */
	for (i = 0; i <= len_expr_short; i++) {
		unsigned char c = expr_short[i];
		switch (stack4_top(state_stack)) {
		case ST_SKIP_SPACE:
			if (c != ' ') {
				stack4_pop(&state_stack);
				i--;
			}
			break;
		case ST_TOP:
			switch (c) {
			case '~':
				stack4_push(&state_stack, ST_EXPECT_OP);
				stack4_push(&state_stack, ST_SKIP_SPACE);
				stack4_push(&state_stack, ST_EXPECT_KEY);
				break;
			case '(':
				level++;
			/* Fall through */
			case '!':
			case '|':
				out[k++] = c;
				stack4_push(&state_stack, ST_SKIP_SPACE);
				break;
			case ')':
				level--;
				out[k++] = c;
				stack4_push(&state_stack, ST_EXPECT_OP);
				stack4_push(&state_stack, ST_SKIP_SPACE);
				break;
			case '\0':
				if (level > 0) {
					set_error("')' expected");
					goto error_exit;
				}
				out[k++] = c;
				break;
			default:
				set_error("unexpected '%c'", c);
				goto error_exit;
			}
			break;
		case ST_EXPECT_KEY:
			stack4_pop(&state_stack);
			key = lookup_long_key(c);
			if (!key) {
				set_error("unknown short key %c", c);
				goto error_exit;
			}
			etype = lookup_key_type(key);
			if (etype == EXPR_INT) {
				stack4_push(&state_stack, ST_EXPECT_INT);
				out[k++] = '(';
			} else if (etype == EXPR_STR) {
				stack4_push(&state_stack, ST_EXPECT_STR);
			} else if (etype != EXPR_BOOL) {
				BUG("wrong etype: %d\n", etype);
			}
			strcpy(out+k, key);
			k += strlen(key);
			stack4_push(&state_stack, ST_SKIP_SPACE);
			break;
		case ST_EXPECT_OP:
			if (c == '~' || c == '(' || c == '!')
				out[k++] = '&';
			i--;
			stack4_replace_top(&state_stack, ST_SKIP_SPACE);
			break;
		case ST_EXPECT_INT:
			if (c == '<' || c == '>') {
				out[k++] = c;
				stack4_replace_top(&state_stack, ST_IN_INT);
			} else if (c == '-') {
				out[k++] = '<';
				out[k++] = '=';
				stack4_replace_top(&state_stack, ST_IN_INT);
			} else if (isdigit(c)) {
				if (!num)
					num = xnew(char, len_expr_short);
				num[i_num++] = c;
				stack4_replace_top(&state_stack, ST_MEM_INT);
			} else {
				set_error("integer expected", expr_short);
				goto error_exit;
			}
			break;
		case ST_IN_INT:
			if (isdigit(c)) {
				out[k++] = c;
			} else {
				i -= 1;
				stack4_pop(&state_stack);
				out[k++] = ')';
			}
			break;
		case ST_MEM_INT:
			if (isdigit(c)) {
				num[i_num++] = c;
			} else {
				if (c == '-') {
					out[k++] = '>';
					out[k++] = '=';
					stack4_replace_top(&state_stack, ST_IN_2ND_INT);
				} else {
					out[k++] = '=';
					i--;
					stack4_pop(&state_stack);
				}
				strncpy(out+k, num, i_num);
				k += i_num;
				i_num = 0;
				if (c != '-')
					out[k++] = ')';
			}
			break;
		case ST_IN_2ND_INT:
			if (isdigit(c)) {
				num[i_num++] = c;
			} else {
				i--;
				stack4_pop(&state_stack);
				if (i_num > 0) {
					out[k++] = '&';
					strcpy(out+k, key);
					k += strlen(key);
					out[k++] = '<';
					out[k++] = '=';
					strncpy(out+k, num, i_num);
					k += i_num;
				}
				out[k++] = ')';
			}
			break;
		case ST_EXPECT_STR:
			out[k++] = '=';
			if (c == '"') {
				stack4_replace_top(&state_stack, ST_IN_QUOTE_STR);
				out[k++] = c;
			} else {
				stack4_replace_top(&state_stack, ST_IN_STR);
				out[k++] = '"';
				out[k++] = '*';
				out[k++] = c;
			}
			break;
		case ST_IN_QUOTE_STR:
			if (c == '"' && expr_short[i-1] != '\\') {
				stack4_pop(&state_stack);
			}
			out[k++] = c;
			break;
		case ST_IN_STR:
			/* isalnum() doesn't work for multi-byte characters */
			if (c != '~' && c != '!' && c != '|' &&
					c != '(' && c != ')' && c != '\0') {
				out[k++] = c;
			} else {
				while (k > 0 && out[k-1] == ' ')
					k--;
				out[k++] = '*';
				out[k++] = '"';
				i--;
				stack4_pop(&state_stack);
			}
			break;
		default:
			BUG("state %ld not covered", stack4_top(state_stack));
			break;
		}
	}

	if (num)
		free(num);

	d_print("expanded \"%s\" to \"%s\"\n", expr_short, out);

	return out;

error_exit:
	if (num)
		free(num);
	free(out);
	return NULL;
}

int expr_is_short(const char *str)
{
	int i;
	for (i = 0; str[i]; i++) {
		if (str[i] == '~')
			return 1;
		if (str[i] != '!' && str[i] != '(' && str[i] != ' ')
			return 0;
	}
	return 0;
}

struct expr *expr_parse(const char *str)
{
	return expr_parse_i(str, "filter contains control characters", 1);
}

struct expr *expr_parse_i(const char *str, const char *err_msg, int check_short)
{
	LIST_HEAD(head);
	struct expr *root = NULL;
	struct list_head *item;
	char *long_str = NULL, *u_str = NULL;
	int i;

	for (i = 0; str[i]; i++) {
		unsigned char c = str[i];
		if (c < 0x20) {
			set_error(err_msg);
			goto out;
		}
	}
	if (!using_utf8 && utf8_encode(str, charset, &u_str) == 0) {
		str = u_str;
	}
	if (!u_is_valid(str)) {
		set_error("invalid UTF-8");
		goto out;
	}

	if (check_short && expr_is_short(str)) {
		str = long_str = expand_short_expr(str);
		if (!str)
			goto out;
	}

	if (tokenize(&head, str))
		goto out;

	item = head.next;
	if (parse(&root, &head, &item, 0))
		root = NULL;
	free_tokens(&head);

out:
	free(u_str);
	free(long_str);
	return root;
}

int expr_check_leaves(struct expr **exprp, const char *(*get_filter)(const char *name))
{
	struct expr *expr = *exprp;
	struct expr *e;
	const char *filter;
	int i, rc;

	if (expr->left) {
		if (expr_check_leaves(&expr->left, get_filter))
			return -1;
		if (expr->right)
			return expr_check_leaves(&expr->right, get_filter);
		return 0;
	}

	for (i = 0; builtin[i].key; i++) {
		int cmp = strcmp(expr->key, builtin[i].key);

		if (cmp > 0)
			continue;
		if (cmp < 0)
			break;

		if (builtin[i].type != expr->type) {
			/* type mismatch */
			set_error("%s is %s", builtin[i].key, expr_names[builtin[i].type]);
			return -1;
		}
		return 0;
	}

	if (expr->type != EXPR_BOOL) {
		/* unknown key */
		set_error("unknown key %s", expr->key);
		return -1;
	}

	/* user defined filter */
	filter = get_filter(expr->key);
	if (filter == NULL) {
		set_error("unknown filter or boolean %s", expr->key);
		return -1;
	}
	e = expr_parse(filter);
	if (e == NULL) {
		return -1;
	}
	rc = expr_check_leaves(&e, get_filter);
	if (rc) {
		expr_free(e);
		return rc;
	}

	/* replace */
	e->parent = expr->parent;
	expr_free(expr);

	/* this sets parents left pointer */
	*exprp = e;
	return 0;
}

unsigned int expr_get_match_type(struct expr *expr)
{
	const char *key;

	if (expr->left) {
		unsigned int left = expr_get_match_type(expr->left);
		if (expr->type == EXPR_AND || expr->type == EXPR_OR)
			return left | expr_get_match_type(expr->right);
		return left;
	}

	key = expr->key;
	if (strcmp(key, "artist") == 0 || strcmp(key, "albumartist") == 0)
		return TI_MATCH_ARTIST;
	if (strcmp(key, "album") == 0 || strcmp(key, "discnumber") == 0)
		return TI_MATCH_ALBUM;
	if (strcmp(key, "title") == 0 || strcmp(key, "tracknumber") == 0)
		return TI_MATCH_TITLE;

	return 0;
}

int expr_is_harmless(const struct expr *expr)
{
	switch (expr->type) {
	case EXPR_OR:
	case EXPR_NOT:
		return 0;
	case EXPR_AND:
		expr = expr->right;
	default:
		break;
	}
	if (expr->type == EXPR_INT) {
		switch (expr->eint.op) {
		case IOP_LT:
		case IOP_EQ:
		case IOP_LE:
			return 0;
		default:
			return 1;
		}
	}
	if (expr->type == EXPR_ID)
		return 0;
	return 1;
}

static const char *str_val(const char *key, struct track_info *ti, char **need_free)
{
	const char *val;
	*need_free = NULL;
	if (strcmp(key, "filename") == 0) {
		val = ti->filename;
		if (!using_utf8 && utf8_encode(val, charset, need_free) == 0) {
			val = *need_free;
		}
	} else if (strcmp(key, "codec") == 0) {
		val = ti->codec;
	} else if (strcmp(key, "codec_profile") == 0) {
		val = ti->codec_profile;
	} else {
		val = keyvals_get_val(ti->comments, key);
	}
	return val;
}

static int int_val(const char *key, struct track_info *ti)
{
	int val;
	if (strcmp(key, "duration") == 0) {
		val = ti->duration;
		/* duration of a stream is infinite (well, almost) */
		if (is_http_url(ti->filename))
			val = INT_MAX;
	} else if (strcmp(key, "date") == 0) {
		val = (ti->date >= 0) ? (ti->date / 10000) : -1;
	} else if (strcmp(key, "originaldate") == 0) {
		val = (ti->originaldate >= 0) ? (ti->originaldate / 10000) : -1;
	} else if (strcmp(key, "bitrate") == 0) {
		val = (ti->bitrate >= 0) ? (int) (ti->bitrate / 1000. + 0.5) : -1;
	} else if (strcmp(key, "play_count") == 0) {
		val = ti->play_count;
	} else if (strcmp(key, "bpm") == 0) {
		val = ti->bpm;
	} else {
		val = comments_get_int(ti->comments, key);
	}
	return val;
}

int expr_op_to_bool(int res, int op)
{
	switch (op) {
	case OP_LT:
		return res < 0;
	case OP_LE:
		return res <= 0;
	case OP_EQ:
		return res == 0;
	case OP_GE:
		return res >= 0;
	case OP_GT:
		return res > 0;
	case OP_NE:
		return res != 0;
	default:
		return 0;
	}
}

int expr_eval(struct expr *expr, struct track_info *ti)
{
	enum expr_type type = expr->type;
	const char *key;

	if (expr->left) {
		int left = expr_eval(expr->left, ti);

		if (type == EXPR_AND)
			return left && expr_eval(expr->right, ti);
		if (type == EXPR_OR)
			return left || expr_eval(expr->right, ti);
		/* EXPR_NOT */
		return !left;
	}

	key = expr->key;
	if (type == EXPR_STR) {
		int res;
		char *need_free;
		const char *val = str_val(key, ti, &need_free);
		if (!val)
			val = "";
		res = glob_match(&expr->estr.glob_head, val);
		free(need_free);
		if (expr->estr.op == SOP_EQ)
			return res;
		return !res;
	} else if (type == EXPR_INT) {
		int val = int_val(key, ti);
		int res;
		if (expr->eint.val == -1) {
			/* -1 is "not set"
			 * doesn't make sense to do 123 < "not set"
			 * but it makes sense to do date=-1 (date is not set)
			 */
			if (expr->eint.op == IOP_EQ)
				return val == -1;
			if (expr->eint.op == IOP_NE)
				return val != -1;
		}
		if (val == -1) {
			/* tag not set, can't compare */
			return 0;
		}
		res = val - expr->eint.val;
		return expr_op_to_bool(res, expr->eint.op);
	} else if (type == EXPR_ID) {
		int a = 0, b = 0;
		const char *sa, *sb;
		char *fa, *fb;
		int res = 0;
		if ((sa = str_val(key, ti, &fa))) {
			if ((sb = str_val(expr->eid.key, ti, &fb))) {
				res = strcmp(sa, sb);
				free(fa);
				free(fb);
				return expr_op_to_bool(res, expr->eid.op);
			}
			free(fa);
		} else {
			a = int_val(key, ti);
			b = int_val(expr->eid.key, ti);
			res = a - b;
			if (a == -1 || b == -1) {
				switch (expr->eid.op) {
				case KOP_EQ:
					return res == 0;
				case KOP_NE:
					return res != 0;
				default:
					return 0;
				}
			}
			return expr_op_to_bool(res, expr->eid.op);
		}
		return res;
	}
	if (strcmp(key, "stream") == 0)
		return is_http_url(ti->filename);
	return track_info_has_tag(ti);
}

void expr_free(struct expr *expr)
{
	if (expr->left) {
		expr_free(expr->left);
		if (expr->right)
			expr_free(expr->right);
	}
	free(expr->key);
	if (expr->type == EXPR_STR)
		glob_free(&expr->estr.glob_head);
	else if (expr->type == EXPR_ID)
		free(expr->eid.key);
	free(expr);
}

const char *expr_error(void)
{
	return error_buf;
}
#include "file.h"
#include "xmalloc.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>

ssize_t read_all(int fd, void *buf, size_t count)
{
	char *buffer = buf;
	ssize_t pos = 0;

	do {
		ssize_t rc;

		rc = read(fd, buffer + pos, count - pos);
		if (rc == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			return -1;
		}
		if (rc == 0) {
			/* eof */
			break;
		}
		pos += rc;
	} while (count - pos > 0);
	return pos;
}

ssize_t write_all(int fd, const void *buf, size_t count)
{
	const char *buffer = buf;
	int count_save = count;

	do {
		int rc;

		rc = write(fd, buffer, count);
		if (rc == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			return -1;
		}
		buffer += rc;
		count -= rc;
	} while (count > 0);
	return count_save;
}

char *mmap_file(const char *filename, ssize_t *size)
{
	struct stat st;
	char *buf;
	int fd;

	fd = open(filename, O_RDONLY);
	if (fd == -1)
		goto err;

	if (fstat(fd, &st) == -1)
		goto close_err;

	/* can't mmap empty files */
	buf = NULL;
	if (st.st_size) {
		buf = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
		if (buf == MAP_FAILED)
			goto close_err;
	}

	close(fd);
	*size = st.st_size;
	return buf;

close_err:
	close(fd);
err:
	*size = -1;
	return NULL;
}

void buffer_for_each_line(const char *buf, int size,
		int (*cb)(void *data, const char *line),
		void *data)
{
	char *line = NULL;
	int line_size = 0, pos = 0;

	while (pos < size) {
		int end, len;

		end = pos;
		while (end < size && buf[end] != '\n')
			end++;

		len = end - pos;
		if (end > pos && buf[end - 1] == '\r')
			len--;

		if (len >= line_size) {
			line_size = len + 1;
			line = xrenew(char, line, line_size);
		}
		memcpy(line, buf + pos, len);
		line[len] = 0;
		pos = end + 1;

		if (cb(data, line))
			break;
	}
	free(line);
}

void buffer_for_each_line_reverse(const char *buf, int size,
		int (*cb)(void *data, const char *line),
		void *data)
{
	char *line = NULL;
	int line_size = 0, end = size - 1;

	while (end >= 0) {
		int pos, len;

		if (end > 1 && buf[end] == '\n' && buf[end - 1] == '\r')
			end--;

		pos = end;
		while (pos > 0 && buf[pos - 1] != '\n')
			pos--;

		len = end - pos;
		if (len >= line_size) {
			line_size = len + 1;
			line = xrenew(char, line, line_size);
		}
		memcpy(line, buf + pos, len);
		line[len] = 0;
		end = pos - 1;

		if (cb(data, line))
			break;
	}
	free(line);
}

int file_for_each_line(const char *filename,
		int (*cb)(void *data, const char *line),
		void *data)
{
	char *buf;
	ssize_t size;

	buf = mmap_file(filename, &size);
	if (size == -1)
		return -1;

	if (buf) {
		buffer_for_each_line(buf, size, cb, data);
		munmap(buf, size);
	}
	return 0;
}
#include "filters.h"
#include "cmdline.h"
#include "expr.h"
#include "window.h"
#include "search.h"
#include "uchar.h"
#include "lib.h"
#include "misc.h"
#include "file.h"
#include "ui_curses.h"
#include "xmalloc.h"

#include <stdio.h>
#include <ctype.h>

struct window *filters_win;
struct searchable *filters_searchable;
LIST_HEAD(filters_head);

static const char *recursive_filter;

static inline void filter_entry_to_iter(struct filter_entry *e, struct iter *iter)
{
	iter->data0 = &filters_head;
	iter->data1 = e;
	iter->data2 = NULL;
}

static GENERIC_ITER_PREV(filters_get_prev, struct filter_entry, node)
static GENERIC_ITER_NEXT(filters_get_next, struct filter_entry, node)

static int filters_search_get_current(void *data, struct iter *iter)
{
	return window_get_sel(filters_win, iter);
}

static int filters_search_matches(void *data, struct iter *iter, const char *text)
{
	char **words = get_words(text);
	int matched = 0;

	if (words[0] != NULL) {
		struct filter_entry *e;
		int i;

		e = iter_to_filter_entry(iter);
		for (i = 0; ; i++) {
			if (words[i] == NULL) {
				window_set_sel(filters_win, iter);
				matched = 1;
				break;
			}
			if (u_strcasestr(e->name, words[i]) == NULL)
				break;
		}
	}
	free_str_array(words);
	return matched;
}

static const struct searchable_ops filters_search_ops = {
	.get_prev = filters_get_prev,
	.get_next = filters_get_next,
	.get_current = filters_search_get_current,
	.matches = filters_search_matches
};

static void free_filter(struct filter_entry *e)
{
	free(e->name);
	free(e->filter);
	free(e);
}

static struct filter_entry *find_filter(const char *name)
{
	struct filter_entry *e;

	list_for_each_entry(e, &filters_head, node) {
		if (strcmp(e->name, name) == 0)
			return e;
	}
	return NULL;
}

static const char *get_filter(const char *name)
{
	struct filter_entry *e = find_filter(name);

	if (e) {
		if (e->visited) {
			recursive_filter = e->name;
			return NULL;
		}
		e->visited = 1;
		return e->filter;
	}
	return NULL;
}

static void edit_sel_filter(void)
{
	struct iter sel;
	struct filter_entry *e;
	char buf[512];

	if (!window_get_sel(filters_win, &sel))
		return;

	e = iter_to_filter_entry(&sel);
	snprintf(buf, sizeof(buf), "fset %s=%s", e->name, e->filter);
	cmdline_set_text(buf);
	enter_command_mode();
}

void filters_activate(int win_activate)
{
	struct filter_entry *f;
	struct expr *e, *expr = NULL;
	int unchanged = 1;

	/* if no pending selection is to apply, edit currently select filter */
	list_for_each_entry(f, &filters_head, node) {
		if (f->act_stat != f->sel_stat)
			unchanged = 0;
	}

	if (unchanged) {
		if (win_activate)
			edit_sel_filter();
		else
			return;
	}

	/* mark visited and AND together all selected filters
	 * mark any other filters unvisited */
	list_for_each_entry(f, &filters_head, node) {
		f->visited = 0;
		if (f->sel_stat == FS_IGNORE)
			continue;

		f->visited = 1;
		e = expr_parse(f->filter);
		if (e == NULL) {
			error_msg("error parsing filter %s: %s", f->name, expr_error());
			if (expr)
				expr_free(expr);
			return;
		}

		if (f->sel_stat == FS_NO) {
			/* add ! */
			struct expr *not = xnew(struct expr, 1);

			not->type = EXPR_NOT;
			not->key = NULL;
			not->left = e;
			not->right = NULL;
			e = not;
		}
		if (expr == NULL) {
			expr = e;
		} else {
			struct expr *and = xnew(struct expr, 1);

			and->type = EXPR_AND;
			and->key = NULL;
			and->left = expr;
			and->right = e;
			expr->parent = and;
			e->parent = and;
			expr = and;
		}
	}

	recursive_filter = NULL;
	if (expr && expr_check_leaves(&expr, get_filter)) {
		if (recursive_filter) {
			error_msg("recursion detected in filter %s", recursive_filter);
		} else {
			error_msg("error parsing filter: %s", expr_error());
		}
		expr_free(expr);
		return;
	}

	/* update active flag */
	list_for_each_entry(f, &filters_head, node) {
		f->act_stat = f->sel_stat;
	}
	lib_set_filter(expr);
	filters_win->changed = 1;
}

static int for_each_name(const char *str, int (*cb)(const char *name, int sel_stat))
{
	char buf[64];
	int s, e, len;

	e = 0;
	do {
		int sel_stat = FS_YES;

		s = e;
		while (str[s] == ' ')
			s++;
		if (str[s] == '!') {
			sel_stat = FS_NO;
			s++;
		}
		e = s;
		while (str[e] && str[e] != ' ')
			e++;

		len = e - s;
		if (len == 0)
			return 0;
		if (len >= sizeof(buf)) {
			error_msg("filter name too long");
			return -1;
		}

		memcpy(buf, str + s, len);
		buf[len] = 0;

		if (cb(buf, sel_stat))
			return -1;
	} while (1);
}

static int ensure_filter_name(const char *name, int sel_stat)
{
	if (find_filter(name) == NULL) {
		error_msg("no such filter %s", name);
		return -1;
	}
	return 0;
}

static int select_filter(const char *name, int sel_stat)
{
	struct filter_entry *e = find_filter(name);

	e->sel_stat = sel_stat;
	return 0;
}

void filters_activate_names(const char *str)
{
	struct filter_entry *f;

	/* first validate all filter names */
	if (str && for_each_name(str, ensure_filter_name))
		return;

	/* mark all filters unselected  */
	list_for_each_entry(f, &filters_head, node)
		f->sel_stat = FS_IGNORE;

	/* select the filters */
	if (str)
		for_each_name(str, select_filter);

	/* activate selected */
	filters_activate(0);
}

void filters_toggle_filter(void)
{
	struct iter iter;

	if (window_get_sel(filters_win, &iter)) {
		struct filter_entry *e;

		e = iter_to_filter_entry(&iter);
		e->sel_stat = (e->sel_stat + 1) % 3;
		filters_win->changed = 1;
	}
}

void filters_delete_filter(void)
{
	struct iter iter;

	if (window_get_sel(filters_win, &iter)) {
		struct filter_entry *e;

		e = iter_to_filter_entry(&iter);
		if (yes_no_query("Delete filter '%s'? [y/N]", e->name) == UI_QUERY_ANSWER_YES) {
			window_row_vanishes(filters_win, &iter);
			list_del(&e->node);
			free_filter(e);
		}
	}
}

static int validate_filter_name(const char *name)
{
	int i;

	for (i = 0; name[i]; i++) {
		if (isalnum((unsigned char)name[i]))
			continue;
		if (name[i] == '_' || name[i] == '-')
			continue;
		return 0;
	}
	return i != 0;
}

static void do_filters_set_filter(const char *keyval)
{
	const char *eq = strchr(keyval, '=');
	char *key, *val;
	struct expr *expr;
	struct filter_entry *new;
	struct list_head *item;

	if (eq == NULL) {
		if (ui_initialized)
			error_msg("invalid argument ('key=value' expected)");
		return;
	}
	key = xstrndup(keyval, eq - keyval);
	val = xstrdup(eq + 1);
	if (!validate_filter_name(key)) {
		if (ui_initialized)
			error_msg("invalid filter name (can only contain 'a-zA-Z0-9_-' characters)");
		free(key);
		free(val);
		return;
	}
	expr = expr_parse(val);
	if (expr == NULL) {
		if (ui_initialized)
			error_msg("error parsing filter %s: %s", val, expr_error());
		free(key);
		free(val);
		return;
	}
	expr_free(expr);

	new = xnew(struct filter_entry, 1);
	new->name = key;
	new->filter = val;
	new->act_stat = FS_IGNORE;
	new->sel_stat = FS_IGNORE;

	/* add or replace filter */
	list_for_each(item, &filters_head) {
		struct filter_entry *e = container_of(item, struct filter_entry, node);
		int res = strcmp(key, e->name);

		if (res < 0)
			break;
		if (res == 0) {
			/* replace */
			struct iter iter;

			new->sel_stat = e->sel_stat;
			if (ui_initialized) {
				filter_entry_to_iter(e, &iter);
				window_row_vanishes(filters_win, &iter);
			}
			item = item->next;
			list_del(&e->node);
			free_filter(e);
			break;
		}
	}
	/* add before item */
	list_add_tail(&new->node, item);
	if (ui_initialized)
		window_changed(filters_win);
}

void filters_init(void)
{
	struct iter iter;

	filters_win = window_new(filters_get_prev, filters_get_next);
	window_set_contents(filters_win, &filters_head);
	window_changed(filters_win);

	iter.data0 = &filters_head;
	iter.data1 = NULL;
	iter.data2 = NULL;
	filters_searchable = searchable_new(NULL, &iter, &filters_search_ops);
}

void filters_exit(void)
{
	searchable_free(filters_searchable);
	window_free(filters_win);
}

void filters_set_filter(const char *keyval)
{
	do_filters_set_filter(keyval);
}

struct expr *parse_filter(const char *val)
{
	struct expr *e = NULL;
	struct filter_entry *f;

	if (val) {
		e = expr_parse(val);
		if (e == NULL) {
			error_msg("error parsing filter %s: %s", val, expr_error());
			return NULL;
		}
	}

	/* mark all unvisited so that we can check recursion */
	list_for_each_entry(f, &filters_head, node)
		f->visited = 0;

	recursive_filter = NULL;
	if (e && expr_check_leaves(&e, get_filter)) {
		if (recursive_filter) {
			error_msg("recursion detected in filter %s", recursive_filter);
		} else {
			error_msg("error parsing filter: %s", expr_error());
		}
		expr_free(e);
		return NULL;
	}
	return e;
}

void filters_set_anonymous(const char *val)
{
	struct filter_entry *f;
	struct expr *e = NULL;

	if (val) {
		e = parse_filter(val);
		if (e == NULL)
			return;
	}

	/* deactive all filters */
	list_for_each_entry(f, &filters_head, node)
		f->act_stat = FS_IGNORE;

	lib_set_filter(e);

	filters_win->changed = 1;
}

void filters_set_live(const char *val)
{
	lib_set_live_filter(val);
	update_filterline();
}

			val = fo->fo_int;
	}
	return val;
}

static int format_eval_cond(struct expr* expr, const struct format_option *fopts)
{
	if (!expr)
		return -1;
	enum expr_type type = expr->type;
	const char *key;
	const struct format_option *fo;
	const struct cmus_opt *opt;
	char buf[OPTION_MAX_SIZE];

	if (expr->left) {
		int left = format_eval_cond(expr->left, fopts);

		if (type == EXPR_AND)
			return left && format_eval_cond(expr->right, fopts);
		if (type == EXPR_OR)
			return left || format_eval_cond(expr->right, fopts);
		/* EXPR_NOT */
		return !left;
	}

	key = expr->key;
	if (type == EXPR_STR) {
		const char *val = str_val(key, fopts, buf);
		int res;

		if (!val)
			val = "";
		res = glob_match(&expr->estr.glob_head, val);
		if (expr->estr.op == SOP_EQ)
			return res;
		return !res;
	} else if (type == EXPR_INT) {
		int val = int_val(key, fopts, buf);
		int res = val - expr->eint.val;
		if (val == -1 || expr->eint.val == -1) {
			switch (expr->eid.op) {
			case KOP_EQ:
				return res == 0;
			case KOP_NE:
				return res != 0;
			default:
				return 0;
			}
		}
		return expr_op_to_bool(res, expr->eint.op);
	} else if (type == EXPR_ID) {
		int a = 0, b = 0;
		const char *sa, *sb;
		int res = 0;
		if ((sa = str_val(key, fopts, buf)) && (sb = str_val(expr->eid.key, fopts, buf))) {
			res = strcmp(sa, sb);
			return expr_op_to_bool(res, expr->eid.op);
		} else {
			a = int_val(key, fopts, buf);
			b = int_val(expr->eid.key, fopts, buf);
			res = a - b;
			if (a == -1 || b == -1) {
				switch (expr->eid.op) {
				case KOP_EQ:
					return res == 0;
				case KOP_NE:
					return res != 0;
				default:
					return 0;
				}
			}
			return expr_op_to_bool(res, expr->eid.op);
		}
		return res;
	}
	if (strcmp(key, "stream") == 0) {
		fo = find_fopt(fopts, "filename");
		return fo && is_http_url(fo->fo_str);
	}
	fo = find_fopt(fopts, key);
	if (fo)
		return !fo->empty;
	opt = option_find_silent(key);
	if (opt) {
		opt->get(opt->data, buf, OPTION_MAX_SIZE);
		if (strcmp(buf, "false") != 0 && strlen(buf) != 0)
			return 1;
	}
	return 0;
}

static struct expr *format_parse_cond(const char* format, int size)
{
	gbuf_clear(&cond_buffer);
	gbuf_add_bytes(&cond_buffer, format, size);
	return expr_parse_i(cond_buffer.buffer, "condition contains control characters", 0);
}

static uchar format_skip_cond_expr(const char *format, int *s)
{
	uchar r = 0;
	while (format[*s]) {
		uchar u = u_get_char(format, s);
		if (u == '}' || u == '?') {
			return u;
		}
		if (u != '%') {
			continue;
		}
		u = u_get_char(format, s);
		if (u == '%' || u == '?' || u == '!' || u == '=') {
			continue;
		}
		if (u == '-') {
			u = u_get_char(format, s);
		}
		if (u == '.')
			u = u_get_char(format, s);
		while (isdigit(u)) {
			u = u_get_char(format, s);
		}
		if (u == '{') {
			unsigned level = 1;
			while (level) {
				u = u_get_char(format, s);
				if (u == 0)
					return 0;
				if (u == '}')
					--level;
				if (u != '%')
					continue;
				u = u_get_char(format, s);
				if (u == '%' || u == '?' || u == '!' || u == '=')
					continue;
				if (u == '-')
					u = u_get_char(format, s);
				if (u == '.')
					u = u_get_char(format, s);
				while (isdigit(u))
					u = u_get_char(format, s);
				if (u == 0)
					return 0;
				if (u == '{')
					++level;
			}
		}
	}
	return r;
}

static int format_read_cond(const char *format, int *s, int *a, int *b, int *end)
{
	uchar t = format_skip_cond_expr(format, s);
	if (t != '?')
		return 1;
	*a = *s - 1;
	t = format_skip_cond_expr(format, s);
	if (t == 0)
		return 1;
	if (t == '?') {
		*b = *s - 1;
		t = format_skip_cond_expr(format, s);
		if (t != '}')
			return 1;
	}
	*end = *s - 1;
	return 0;
}

static void format_parse(int str_width, const char *format, const struct format_option *fopts, int f_size);

static void format_parse_if(int str_width, const char *format, const struct format_option *fopts, int *s)
{
	int cond_pos = *s, then_pos = -1, else_pos = -1, end_pos = -1, cond_res = -1;
	BUG_ON(format_read_cond(format, s, &then_pos, &else_pos, &end_pos) != 0);

	struct expr *cond = format_parse_cond(format + cond_pos, then_pos - cond_pos);
	cond_res = format_eval_cond(cond, fopts);
	if (cond)
		expr_free(cond);

	BUG_ON(cond_res < 0);
	if (cond_res) {
		format_parse(str_width, format + then_pos + 1, fopts,
				(else_pos > 0 ? else_pos : end_pos) - then_pos - 1);
	} else if (else_pos > 0) {
		format_parse(str_width, format + else_pos + 1, fopts, end_pos - else_pos - 1);
	}

	*s = end_pos + 1;
}

static void format_parse(int str_width, const char *format, const struct format_option *fopts, int f_size)
{
	int s = 0;

	while (s < f_size) {
		const struct format_option *fo;
		int long_len = 0;
		const char *long_begin = NULL;
		uchar u;

		u = u_get_char(format, &s);
		if (u != '%') {
			gbuf_add_uchar(str, u);
			(*len) += u_char_width(u);
			continue;
		}
		u = u_get_char(format, &s);
		if (u == '%' || u == '?') {
			gbuf_add_ch(str, u);
			++(*len);
			continue;
		}
		if (u == '!') {
			/* middle (priority) text starts */
			str = &m_str;
			len = &str_len.mlen;
			continue;
		}
		if (u == '=') {
			/* right aligned text starts */
			str = &r_str;
			len = &str_len.rlen;
			continue;
		}
		align_left = 0;
		if (u == '-') {
			align_left = 1;
			u = u_get_char(format, &s);
		}
		width_is_exact = true;
		if (u == '.') {
			width_is_exact = false;
			u = u_get_char(format, &s);
		}
		pad = ' ';
		if (u == '0') {
			pad = '0';
			u = u_get_char(format, &s);
		}
		width = 0;
		while (isdigit(u)) {
			/* minimum length of this field */
			width *= 10;
			width += u - '0';
			u = u_get_char(format, &s);
		}
		if (u == '%') {
			width = (width * str_width) / 100.0 + 0.5;
			u = u_get_char(format, &s);
		}
		if (u == '{') {
			long_begin = format + s;
			if (*long_begin == '?') {
				++s;
				format_parse_if(str_width, format, fopts, &s);
				BUG_ON(s > f_size);
				continue;
			}
			while (1) {
				BUG_ON(s >= f_size);
				u = u_get_char(format, &s);
				if (u == '}')
					break;
				long_len++;
			}
		}
		for (fo = fopts; ; fo++) {
			BUG_ON(fo->type == 0);
			if (long_len ? strnequal(fo->str, long_begin, long_len)
				     : (fo->ch == u)) {

				int type = fo->type;

				if (fo->empty) {
					gbuf_set(str, ' ', width);
					*len += width;
				} else if (type == FO_STR) {
					print_str(fo->fo_str);
				} else if (type == FO_INT) {
					print_num(fo->fo_int);
				} else if (type == FO_TIME) {
					print_time(fo->fo_time);
				} else if (type == FO_DOUBLE) {
					print_double(fo->fo_double);
				}
				break;
			}
		}
	}
}

static void format_read(int str_width, const char *format, const struct format_option *fopts)
{
	gbuf_clear(&l_str);
	gbuf_clear(&m_str);
	gbuf_clear(&r_str);
	str_len.llen = 0;
	str_len.mlen = 0;
	str_len.rlen = 0;
	str = &l_str;
	len = &str_len.llen;
	format_parse(str_width, format, fopts, strlen(format));
}

static void format_write(struct gbuf *buf, int str_width)
{
	if (str_width == 0)
		str_width = str_len.llen + str_len.mlen + str_len.rlen + (str_len.rlen > 0);

	/* NOTE: any invalid UTF-8 bytes have already been converted to <xx>
	 *       (ASCII) where x is hex digit
	 */

	if (str_len.llen + str_len.mlen + str_len.rlen <= str_width) {
		/* all fit */
		int ws_len = str_width - (str_len.llen + str_len.mlen + str_len.rlen);

		gbuf_add_bytes(buf, l_str.buffer, l_str.len);
		gbuf_add_bytes(buf, m_str.buffer, m_str.len);
		gbuf_set(buf, ' ', ws_len);
		gbuf_add_bytes(buf, r_str.buffer, r_str.len);
	} else {
		/* keep first character since it's almost always padding */
		int clipped_mark_len = min_u(u_str_width(clipped_text_internal) + 1, str_width);
		int r_space = str_width - clipped_mark_len;
		int r_width = min_i(r_space, str_len.rlen);
		int m_space = r_space - r_width;
		int m_width = min_i(m_space, str_len.mlen);
		int l_space = m_space - m_width;
		int l_width = l_space + clipped_mark_len;
		int r_idx = 0, ws_pad = 0;

		gbuf_add_ustr(buf, l_str.buffer, &l_width);
		ws_pad += l_width;
		gbuf_add_ustr(buf, m_str.buffer, &m_width);
		ws_pad += m_width;

		int r_skip = str_len.rlen - r_width;
		r_idx = u_skip_chars(r_str.buffer, &r_skip, true);
		ws_pad += -r_skip;
		gbuf_set(buf, ' ', ws_pad);
		gbuf_add_bytes(buf, r_str.buffer + r_idx, r_str.len - r_idx);
	}
}

struct fp_len format_print(struct gbuf *buf, int str_width, const char *format, const struct format_option *fopts)
{
	format_read(str_width, format, fopts);

#if DEBUG > 1
	if (str_len.llen > 0) {
		int ul = u_str_width(l_str.buffer);
		if (ul != str_len.llen)
			d_print("L %d != %d: size=%zu '%s'\n", ul, str_len.llen, l_str.len, l_str.buffer);
	}

	if (str_len.rlen > 0) {
		int ul = u_str_width(r_str.buffer);
		if (ul != str_len.rlen)
			d_print("R %d != %d: size=%zu '%s'\n", ul, str_len.rlen, r_str.len, r_str.buffer);
	}
#endif

	format_write(buf, str_width);
	return str_len;
}

static int format_valid_sub(const char *format, const struct format_option *fopts, int f_size);

static int format_valid_if(const char *format, const struct format_option *fopts, int *s)
{
	int cond_pos = *s, then_pos = -1, else_pos = -1, end_pos = -1;
	if (format_read_cond(format, s, &then_pos, &else_pos, &end_pos) != 0)
		return 0;

	struct expr *cond = format_parse_cond(format + cond_pos, then_pos - cond_pos);
	if (cond == NULL)
		return 0;
	expr_free(cond);

	if (!format_valid_sub(format + then_pos + 1, fopts,
				(else_pos > 0 ? else_pos : end_pos) - then_pos - 1))
		return 0;
	if (else_pos > 0)
		if (!format_valid_sub(format + else_pos + 1, fopts, end_pos - else_pos - 1))
			return 0;

	*s = end_pos + 1;
	return 1;
}

static int format_valid_sub(const char *format, const struct format_option *fopts, int f_size)
{
	int s = 0;

	while (s < f_size) {
		uchar u;

		u = u_get_char(format, &s);
		if (u == '%') {
			int pad_zero = 0, long_len = 0;
			const struct format_option *fo;
			const char *long_begin = NULL;

			u = u_get_char(format, &s);
			if (u == '%' || u == '?' || u == '!' || u == '=')
				continue;
			if (u == '-')
				u = u_get_char(format, &s);
			if (u == '.')
				u = u_get_char(format, &s);
			if (u == '0') {
				pad_zero = 1;
				u = u_get_char(format, &s);
			}
			while (isdigit(u))
				u = u_get_char(format, &s);
			if (u == '%')
				u = u_get_char(format, &s);
			if (u == '{') {
				long_begin = format + s;
				if (*long_begin == '?') {
					++s;
					if (!format_valid_if(format, fopts, &s))
						return 0;
					if (s > f_size)
						return 0;
					continue;
				}

				while (1) {
					if (s >= f_size)
						return 0;
					u = u_get_char(format, &s);
					if (u == '}')
						break;
					long_len++;
				}
			}
			for (fo = fopts; fo->type; fo++) {
				if (long_len ? strnequal(fo->str, long_begin, long_len)
					     : (fo->ch == u)) {
					if (pad_zero && !fo->pad_zero)
						return 0;
					break;
				}
			}
			if (! fo->type)
				return 0;
		}
	}
	return 1;
}

int format_valid(const char *format, const struct format_option *fopts)
{
	return format_valid_sub(format, fopts, strlen(format));
}
#include "gbuf.h"
#include "options.h"
#include "utils.h"
#include "xmalloc.h"

#include <stdio.h>
#include <stdarg.h>

char gbuf_empty_buffer[1];

static inline void gbuf_init(struct gbuf *buf)
{
	buf->buffer = gbuf_empty_buffer;
	buf->alloc = 0;
	buf->len = 0;
}

void gbuf_grow(struct gbuf *buf, size_t more)
{
	size_t align = 64 - 1;
	size_t alloc = (buf->len + more + 1 + align) & ~align;

	if (alloc > buf->alloc) {
		if (!buf->alloc)
			buf->buffer = NULL;
		buf->alloc = alloc;
		buf->buffer = xrealloc(buf->buffer, buf->alloc);
		// gbuf is not NUL terminated if this was first alloc
		buf->buffer[buf->len] = 0;
	}
}

void gbuf_used(struct gbuf *buf, size_t used)
{
	buf->len += used;
	buf->buffer[buf->len] = 0;
}

void gbuf_free(struct gbuf *buf)
{
	if (buf->alloc)
		free(buf->buffer);
	gbuf_init(buf);
}

void gbuf_add_ch(struct gbuf *buf, char ch)
{
	gbuf_grow(buf, 1);
	buf->buffer[buf->len] = ch;
	gbuf_used(buf, 1);
}

void gbuf_add_uchar(struct gbuf *buf, uchar u)
{
	size_t uchar_len = 0;
	gbuf_grow(buf, 4);
	u_set_char(buf->buffer + buf->len, &uchar_len, u);
	gbuf_used(buf, uchar_len);
}

void gbuf_add_bytes(struct gbuf *buf, const void *data, size_t len)
{
	gbuf_grow(buf, len);
	memcpy(buf->buffer + buf->len, data, len);
	gbuf_used(buf, len);
}

void gbuf_add_str(struct gbuf *buf, const char *str)
{
	int len = strlen(str);

	if (!len)
		return;
	gbuf_grow(buf, len);
	memcpy(buf->buffer + buf->len, str, len);
	gbuf_used(buf, len);
}

static int gbuf_mark_clipped_text(struct gbuf *buf)
{
	int buf_width = u_str_width(buf->buffer);
	int clipped_mark_len = min_u(u_str_width(clipped_text_internal), buf_width);
	int skip = buf_width - clipped_mark_len;
	buf->len = u_skip_chars(buf->buffer, &skip, false);
	gbuf_grow(buf, strlen(clipped_text_internal));
	gbuf_used(buf, u_copy_chars(buf->buffer + buf->len, clipped_text_internal, &clipped_mark_len));
	return skip;
}

void gbuf_add_ustr(struct gbuf *buf, const char *src, int *width)
{
	gbuf_grow(buf, strlen(src));
	size_t copy_bytes = u_copy_chars(buf->buffer + buf->len, src, width);
	gbuf_used(buf, copy_bytes);
	if (src[copy_bytes] != '\0') {
		gbuf_set(buf, ' ', *width);
		*width = gbuf_mark_clipped_text(buf);
	}
}

void gbuf_addf(struct gbuf *buf, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	gbuf_vaddf(buf, fmt, ap);
	va_end(ap);
}

void gbuf_vaddf(struct gbuf *buf, const char *fmt, va_list ap)
{
	va_list ap2;
	int slen;

	va_copy(ap2, ap);
	slen = vsnprintf(buf->buffer + buf->len, buf->alloc - buf->len, fmt, ap);

	if (slen > gbuf_avail(buf)) {
		gbuf_grow(buf, slen);
		slen = vsnprintf(buf->buffer + buf->len, buf->alloc - buf->len, fmt, ap2);
	}
	va_end(ap2);
	gbuf_used(buf, slen);
}

void gbuf_set(struct gbuf *buf, int c, size_t count)
{
	gbuf_grow(buf, count);
	memset(buf->buffer + buf->len, c, count);
	gbuf_used(buf, count);
}

char *gbuf_steal(struct gbuf *buf)
{
	char *b = buf->buffer;
	if (!buf->alloc)
		b = xnew0(char, 1);
	gbuf_init(buf);
	return b;
}
#include "glob.h"
#include "uchar.h"
#include "list.h"
#include "xmalloc.h"
#include "debug.h"

#include <string.h>

struct glob_item {
	struct list_head node;
	enum {
		GLOB_STAR,
		GLOB_QMARK,
		GLOB_TEXT
	} type;
	char text[];
};

/* simplification:
 *
 *   ??*? => ???*
 *   *?*  => ?*
 *   *?   => ?*
 *   ...
 */
static void simplify(struct list_head *head)
{
	struct list_head *item;

	item = head->next;
	while (item != head) {
		struct list_head *i, *next;
		int qcount = 0;
		int scount = 0;

		i = item;
		do {
			struct glob_item *gi;

			gi = container_of(i, struct glob_item, node);
			if (gi->type == GLOB_STAR) {
				scount++;
			} else if (gi->type == GLOB_QMARK) {
				qcount++;
			} else {
				i = i->next;
				break;
			}
			i = i->next;
		} while (i != head);

		next = i;

		if (scount) {
			/* move all qmarks to front and
			 * if there are >1 stars remove all but the last */
			struct list_head *insert_after = item->prev;

			i = item;
			while (qcount) {
				struct glob_item *gi;

				gi = container_of(i, struct glob_item, node);
				i = i->next;
				if (gi->type == GLOB_QMARK) {
					list_del(&gi->node);
					list_add(&gi->node, insert_after);
					qcount--;
				}
			}

			i = item;
			while (scount > 1) {
				struct glob_item *gi;

				gi = container_of(i, struct glob_item, node);
				i = i->next;
				if (gi->type == GLOB_STAR) {
					list_del(&gi->node);
					free(gi);
					scount--;
				}
			}
		}

		item = next;
	}
}

void glob_compile(struct list_head *head, const char *pattern)
{
	int i = 0;

	list_init(head);
	while (pattern[i]) {
		struct glob_item *item;

		if (pattern[i] == '*') {
			item = xnew(struct glob_item, 1);
			item->type = GLOB_STAR;
			i++;
		} else if (pattern[i] == '?') {
			item = xnew(struct glob_item, 1);
			item->type = GLOB_QMARK;
			i++;
		} else {
			int start, len, j;
			char *str;

			start = i;
			len = 0;
			while (pattern[i]) {
				if (pattern[i] == '\\') {
					i++;
					len++;
					if (pattern[i])
						i++;
				} else if (pattern[i] == '*') {
					break;
				} else if (pattern[i] == '?') {
					break;
				} else {
					i++;
					len++;
				}
			}

			item = xmalloc(sizeof(struct glob_item) + len + 1);
			item->type = GLOB_TEXT;

			str = item->text;
			i = start;
			j = 0;
			while (j < len) {
				if (pattern[i] == '\\') {
					i++;
					if (pattern[i]) {
						str[j++] = pattern[i++];
					} else {
						str[j++] = '\\';
					}
				} else {
					str[j++] = pattern[i++];
				}
			}
			str[j] = 0;
		}
		list_add_tail(&item->node, head);
	}
	simplify(head);
}

void glob_free(struct list_head *head)
{
	struct list_head *item = head->next;

	while (item != head) {
		struct glob_item *gi;
		struct list_head *next = item->next;

		gi = container_of(item, struct glob_item, node);
		free(gi);
		item = next;
	}
}

static int do_glob_match(struct list_head *head, struct list_head *first, const char *text)
{
	struct list_head *item = first;

	while (item != head) {
		struct glob_item *gitem;

		gitem = container_of(item, struct glob_item, node);
		if (gitem->type == GLOB_TEXT) {
			int len = u_strlen(gitem->text);

			if (!u_strncase_equal_base(gitem->text, text, len))
				return 0;
			text += strlen(gitem->text);
		} else if (gitem->type == GLOB_QMARK) {
			uchar u;
			int idx = 0;

			u = u_get_char(text, &idx);
			if (u == 0)
				return 0;
			text += idx;
		} else if (gitem->type == GLOB_STAR) {
			/* after star there MUST be normal text (or nothing),
			 * question marks have been moved before this star and
			 * other stars have been stripped (see simplify)
			 */
			struct list_head *next;
			struct glob_item *next_gi;
			const char *t;
			int tlen;

			next = item->next;
			if (next == head) {
				/* this star was the last item => matched */
				return 1;
			}
			next_gi = container_of(next, struct glob_item, node);
			BUG_ON(next_gi->type != GLOB_TEXT);
			t = next_gi->text;
			tlen = strlen(t);
			while (1) {
				const char *pos;

				pos = u_strcasestr_base(text, t);
				if (pos == NULL)
					return 0;
				if (do_glob_match(head, next->next, pos + tlen))
					return 1;
				text = pos + 1;
			}
		}
		item = item->next;
	}
	return text[0] == 0;
}

int glob_match(struct list_head *head, const char *text)
{
	return do_glob_match(head, head->next, text);
}
#include "help.h"
#include "window.h"
#include "search.h"
#include "misc.h"
#include "xmalloc.h"
#include "keys.h"
#include "command_mode.h"
#include "ui_curses.h"
#include "options.h"
#include "cmdline.h"

#include <stdio.h>

struct window *help_win;
struct searchable *help_searchable;

static LIST_HEAD(help_head);
static struct list_head *bound_head;
static struct list_head *bound_tail;
static struct list_head *unbound_head;
static struct list_head *unbound_tail;

static inline void help_entry_to_iter(struct help_entry *e, struct iter *iter)
{
	iter->data0 = &help_head;
	iter->data1 = e;
	iter->data2 = NULL;
}

static GENERIC_ITER_PREV(help_get_prev, struct help_entry, node)
static GENERIC_ITER_NEXT(help_get_next, struct help_entry, node)

static int help_search_get_current(void *data, struct iter *iter)
{
	return window_get_sel(help_win, iter);
}

static int help_search_matches(void *data, struct iter *iter, const char *text)
{
	int matched = 0;
	char **words = get_words(text);

	if (words[0] != NULL) {
		struct help_entry *ent;
		int i;

		ent = iter_to_help_entry(iter);
		for (i = 0; ; i++) {
			if (words[i] == NULL) {
				window_set_sel(help_win, iter);
				matched = 1;
				break;
			}
			if (ent->type == HE_TEXT) {
				if (!u_strcasestr(ent->text, words[i]))
					break;
			} else if (ent->type == HE_BOUND) {
				if (!u_strcasestr(ent->binding->cmd, words[i]) &&
					!u_strcasestr(ent->binding->key->name, words[i]))
					break;
			} else if (ent->type == HE_UNBOUND) {
				if (!u_strcasestr(ent->command->name, words[i]))
					break;
			} else if (ent->type == HE_OPTION) {
				if (!u_strcasestr(ent->option->name, words[i]))
					break;
			}
		}
	}
	free_str_array(words);
	return matched;
}

static const struct searchable_ops help_search_ops = {
	.get_prev = help_get_prev,
	.get_next = help_get_next,
	.get_current = help_search_get_current,
	.matches = help_search_matches
};

static void help_add_text(const char *s)
{
	struct help_entry *ent;
	ent = xnew(struct help_entry, 1);
	ent->type = HE_TEXT;
	ent->text = s;
	list_add_tail(&ent->node, &help_head);
}

static void help_add_defaults(void)
{
	struct cmus_opt *opt;

	help_add_text("Keybindings");
	help_add_text("-----------");
	bound_head = help_head.prev;
	help_add_text("");
	help_add_text("Unbound Commands");
	help_add_text("----------------");
	unbound_head = help_head.prev;
	help_add_text("");
	help_add_text("Options");
	help_add_text("-------");

	list_for_each_entry(opt, &option_head, node) {
		struct help_entry *ent = xnew(struct help_entry, 1);

		ent->type = HE_OPTION;
		ent->option = opt;
		list_add_tail(&ent->node, &help_head);
	}

	bound_tail = bound_head->next;
	unbound_tail = unbound_head->next;
}

void help_remove_unbound(struct command *cmd)
{
	struct help_entry *ent;
	struct iter i;
	list_for_each_entry(ent, &help_head, node) {
		if (ent->type != HE_UNBOUND)
			continue;
		if (ent->command == cmd) {
			help_entry_to_iter(ent, &i);
			window_row_vanishes(help_win, &i);
			list_del(&ent->node);
			free(ent);
			return;
		}
	}
}

static void list_add_sorted(struct list_head *new, struct list_head *head,
		struct list_head *tail,
		int (*cmp)(struct list_head *, struct list_head *))
{
	struct list_head *item = tail->prev;

	while (item != head) {
		if (cmp(new, item) >= 0)
			break;
		item = item->prev;
	}
	/* add after item */
	list_add(new, item);
}

static int bound_cmp(struct list_head *ai, struct list_head *bi)
{
	struct help_entry *a = container_of(ai, struct help_entry, node);
	struct help_entry *b = container_of(bi, struct help_entry, node);
	int ret = a->binding->ctx - b->binding->ctx;

	if (!ret)
		ret = strcmp(a->binding->key->name, b->binding->key->name);
	return ret;
}

static int unbound_cmp(struct list_head *ai, struct list_head *bi)
{
	struct help_entry *a = container_of(ai, struct help_entry, node);
	struct help_entry *b = container_of(bi, struct help_entry, node);

	return strcmp(a->command->name, b->command->name);
}

void help_add_unbound(struct command *cmd)
{
	struct help_entry *ent;

	ent = xnew(struct help_entry, 1);
	ent->type = HE_UNBOUND;
	ent->command = cmd;
	list_add_sorted(&ent->node, unbound_head, unbound_tail, unbound_cmp);
}

void help_add_all_unbound(void)
{
	int i;
	for (i = 0; commands[i].name; ++i)
		if (!commands[i].bc)
			help_add_unbound(&commands[i]);
}

void help_select(void)
{
	struct iter sel;
	struct help_entry *ent;
	char buf[OPTION_MAX_SIZE];

	if (!window_get_sel(help_win, &sel))
		return;

	ent = iter_to_help_entry(&sel);
	switch (ent->type) {
	case HE_BOUND:
		snprintf(buf, sizeof(buf), "bind -f %s %s %s",
				key_context_names[ent->binding->ctx],
				ent->binding->key->name,
				ent->binding->cmd);
		cmdline_set_text(buf);
		enter_command_mode();
		break;
	case HE_UNBOUND:
		snprintf(buf, sizeof(buf), "bind common <key> %s",
				ent->command->name);
		cmdline_set_text(buf);
		enter_command_mode();
		break;
	case HE_OPTION:
		snprintf(buf, sizeof(buf), "set %s=", ent->option->name);
		size_t len = strlen(buf);
		ent->option->get(ent->option->data, buf + len, sizeof(buf) - len);
		cmdline_set_text(buf);
		enter_command_mode();
		break;
	default:
		break;
	}
}

void help_toggle(void)
{
	struct iter sel;
	struct help_entry *ent;

	if (!window_get_sel(help_win, &sel))
		return;

	ent = iter_to_help_entry(&sel);
	switch (ent->type) {
	case HE_OPTION:
		if (ent->option->toggle) {
			ent->option->toggle(ent->option->data);
			help_win->changed = 1;
		}
		break;
	default:
		break;
	}
}

void help_remove(void)
{
	struct iter sel;
	struct help_entry *ent;

	if (!window_get_sel(help_win, &sel))
		return;

	ent = iter_to_help_entry(&sel);
	switch (ent->type) {
	case HE_BOUND:
		if (yes_no_query("Remove selected binding? [y/N]") == UI_QUERY_ANSWER_YES)
			key_unbind(key_context_names[ent->binding->ctx],
					ent->binding->key->name, 0);
		break;
	default:
		break;
	}
}

void help_add_bound(const struct binding *bind)
{
	struct help_entry *ent;
	ent = xnew(struct help_entry, 1);
	ent->type = HE_BOUND;
	ent->binding = bind;
	list_add_sorted(&ent->node, bound_head, bound_tail, bound_cmp);
}

void help_remove_bound(const struct binding *bind)
{
	struct help_entry *ent;
	struct iter i;
	list_for_each_entry(ent, &help_head, node) {
		if (ent->binding == bind) {
			help_entry_to_iter(ent, &i);
			window_row_vanishes(help_win, &i);
			list_del(&ent->node);
			free(ent);
			return;
		}
	}
}

void help_init(void)
{
	struct iter iter;

	help_win = window_new(help_get_prev, help_get_next);
	window_set_contents(help_win, &help_head);
	window_changed(help_win);
	help_add_defaults();

	iter.data0 = &help_head;
	iter.data1 = NULL;
	iter.data2 = NULL;
	help_searchable = searchable_new(NULL, &iter, &help_search_ops);
}

void help_exit(void)
{
	searchable_free(help_searchable);
	window_free(help_win);
}
#include "history.h"
#include "xmalloc.h"
#include "file.h"
#include "uchar.h"
#include "list.h"
#include "prog.h"

#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

struct history_entry {
	struct list_head node;
	char *text;
};

static struct history_entry *history_entry_new(const char *text)
{
	struct history_entry *new;
	new = xnew(struct history_entry, 1);
	new->text = xstrdup(text);
	return new;
}

static void history_entry_free(struct history_entry *history)
{
	free(history->text);
	free(history);
}

void history_free(struct history *history)
{
	struct list_head *item, *temp;
	list_for_each_safe(item, temp, &history->head) {
		struct history_entry *history_entry;
		history_entry = list_entry(item, struct history_entry, node);
		history_entry_free(history_entry);
	}
}

static int history_add_tail(void *data, const char *line)
{
	struct history *history = data;

	if (history->lines < history->max_lines) {
		struct history_entry *new;

		new = history_entry_new(line);
		list_add_tail(&new->node, &history->head);
		history->lines++;
	}
	return 0;
}

void history_load(struct history *history, char *filename, int max_lines)
{
	list_init(&history->head);
	history->max_lines = max_lines;
	history->lines = 0;
	history->search_pos = NULL;
	history->filename = filename;
	file_for_each_line(filename, history_add_tail, history);
}

void history_save(struct history *history)
{
	char filename_tmp[512];
	struct list_head *item;
	int fd;
	ssize_t rc;

	snprintf(filename_tmp, sizeof(filename_tmp), "%s.tmp", history->filename);
	fd = open(filename_tmp, O_CREAT | O_WRONLY | O_TRUNC, 0666);
	if (fd == -1)
		return;
	list_for_each(item, &history->head) {
		struct history_entry *history_entry;
		const char nl = '\n';

		history_entry = list_entry(item, struct history_entry, node);

		rc = write(fd, history_entry->text, strlen(history_entry->text));
		if (rc == -1)
			goto out;

		rc = write(fd, &nl, 1);
		if (rc == -1)
			goto out;
	}
out:
	close(fd);

	rc = rename(filename_tmp, history->filename);
	if (rc)
		warn_errno("renaming %s to %s", filename_tmp, history->filename);
}

void history_add_line(struct history *history, const char *line)
{
	struct history_entry *new;
	struct list_head *item;

	new = history_entry_new(line);
	list_add(&new->node, &history->head);
	history->lines++;

	/* remove identical */
	item = history->head.next->next;
	while (item != &history->head) {
		struct list_head *next = item->next;
		struct history_entry *hentry;

		hentry = container_of(item, struct history_entry, node);
		if (strcmp(hentry->text, new->text) == 0) {
			list_del(item);
			history_entry_free(hentry);
			history->lines--;
		}
		item = next;
	}

	/* remove oldest if history is 'full' */
	if (history->lines > history->max_lines) {
		struct list_head *node;
		struct history_entry *hentry;

		node = history->head.prev;
		list_del(node);
		hentry = list_entry(node, struct history_entry, node);
		history_entry_free(hentry);
		history->lines--;
	}
}

void history_reset_search(struct history *history)
{
	history->search_pos = NULL;
}

const char *history_search_forward(struct history *history, const char *text)
{
	struct list_head *item;
	int search_len;

	if (history->search_pos == NULL) {
		/* first time to search. set search */
		item = history->head.next;
	} else {
		item = history->search_pos->next;
	}
	search_len = strlen(text);
	while (item != &history->head) {
		struct history_entry *hentry;

		hentry = list_entry(item, struct history_entry, node);
		if (strncmp(text, hentry->text, search_len) == 0) {
			history->search_pos = item;
			return hentry->text;
		}
		item = item->next;
	}
	return NULL;
}

const char *history_search_backward(struct history *history, const char *text)
{
	struct list_head *item;
	int search_len;

	if (history->search_pos == NULL)
		return NULL;
	item = history->search_pos->prev;
	search_len = strlen(text);
	while (item != &history->head) {
		struct history_entry *hentry;

		hentry = list_entry(item, struct history_entry, node);
		if (strncmp(text, hentry->text, search_len) == 0) {
			history->search_pos = item;
			return hentry->text;
		}
		item = item->prev;
	}
	history->search_pos = NULL;
	return NULL;
}
) {
			d_print("Failed to parse HTTP proxy URI '%s'\n", proxy);
			return -1;
		}
	} else {
		hg->proxy = NULL;
	}

	snprintf(port, sizeof(port), "%d", hg->proxy ? hg->proxy->port : hg->uri.port);
	rc = getaddrinfo(hg->proxy ? hg->proxy->host : hg->uri.host, port, &hints, &result);
	if (rc != 0) {
		d_print("getaddrinfo: %s\n", gai_strerror(rc));
		return -1;
	}
	memcpy(&addr.sa, result->ai_addr, result->ai_addrlen);
	addrlen = result->ai_addrlen;
	freeaddrinfo(result);

	hg->fd = socket(addr.sa.sa_family, SOCK_STREAM, 0);
	if (hg->fd == -1)
		return -1;

	flags = fcntl(hg->fd, F_GETFL);
	if (fcntl(hg->fd, F_SETFL, O_NONBLOCK) == -1)
		goto close_exit;

	tv.tv_sec = timeout_ms / 1000;
	tv.tv_usec = (timeout_ms % 1000) * 1000;
	while (1) {
		fd_set wfds;

		d_print("connecting. timeout=%lld s %lld us\n", (long long)tv.tv_sec, (long long)tv.tv_usec);
		if (connect(hg->fd, &addr.sa, addrlen) == 0)
			break;
		if (errno == EISCONN)
			break;
		if (errno != EAGAIN && errno != EINPROGRESS)
			goto close_exit;

		FD_ZERO(&wfds);
		FD_SET(hg->fd, &wfds);
		while (1) {
			rc = select(hg->fd + 1, NULL, &wfds, NULL, &tv);
			if (rc == -1) {
				if (errno != EINTR)
					goto close_exit;
				/* signalled */
				continue;
			}
			if (rc == 1) {
				/* socket ready */
				break;
			}
			if (tv.tv_sec == 0 && tv.tv_usec == 0) {
				errno = ETIMEDOUT;
				goto close_exit;
			}
		}
	}

	/* restore old flags */
	if (fcntl(hg->fd, F_SETFL, flags) == -1)
		goto close_exit;
	return 0;
close_exit:
	save = errno;
	close(hg->fd);
	errno = save;
	return -1;
}

static int http_write(int fd, const char *buf, int count, int timeout_ms)
{
	struct timeval tv;
	int pos = 0;

	tv.tv_sec = timeout_ms / 1000;
	tv.tv_usec = (timeout_ms % 1000) * 1000;
	while (1) {
		fd_set wfds;
		int rc;

		d_print("timeout=%lld s %lld us\n", (long long)tv.tv_sec, (long long)tv.tv_usec);

		FD_ZERO(&wfds);
		FD_SET(fd, &wfds);
		rc = select(fd + 1, NULL, &wfds, NULL, &tv);
		if (rc == -1) {
			if (errno != EINTR)
				return -1;
			/* signalled */
			continue;
		}
		if (rc == 1) {
			rc = write(fd, buf + pos, count - pos);
			if (rc == -1) {
				if (errno == EINTR || errno == EAGAIN)
					continue;
				return -1;
			}
			pos += rc;
			if (pos == count)
				return 0;
		} else if (tv.tv_sec == 0 && tv.tv_usec == 0) {
			errno = ETIMEDOUT;
			return -1;
		}
	}
}

static int read_timeout(int fd, int timeout_ms)
{
	struct timeval tv;

	tv.tv_sec = timeout_ms / 1000;
	tv.tv_usec = (timeout_ms % 1000) * 1000;
	while (1) {
		fd_set rfds;
		int rc;

		FD_ZERO(&rfds);
		FD_SET(fd, &rfds);
		rc = select(fd + 1, &rfds, NULL, NULL, &tv);
		if (rc == -1) {
			if (errno != EINTR)
				return -1;
			/* signalled */
			continue;
		}
		if (rc == 1)
			return 0;
		if (tv.tv_sec == 0 && tv.tv_usec == 0) {
			errno = ETIMEDOUT;
			return -1;
		}
	}
}

/* reads response, ignores fscking carriage returns */
static int http_read_response(int fd, struct gbuf *buf, int timeout_ms)
{
	char prev = 0;

	if (read_timeout(fd, timeout_ms))
		return -1;
	while (1) {
		int rc;
		char ch;

		rc = read(fd, &ch, 1);
		if (rc == -1) {
			return -1;
		}
		if (rc == 0) {
			return -2;
		}
		if (ch == '\r')
			continue;
		if (ch == '\n' && prev == '\n')
			return 0;
		gbuf_add_ch(buf, ch);
		prev = ch;
	}
}

static int http_parse_response(char *str, struct http_get *hg)
{
	/* str is 0 terminated buffer of lines
	 * every line ends with '\n'
	 * no carriage returns
	 * no empty lines
	 */
	GROWING_KEYVALS(h);
	char *end;

	if (strncmp(str, "HTTP/", 5) == 0) {
		str += 5;
		while (*str != ' ') {
			if (*str == '\n') {
				return -2;
			}
			str++;
		}
	} else if (strncmp(str, "ICY", 3) == 0) {
		str += 3;
	} else {
		return -2;
	}
	while (*str == ' ')
		str++;

	hg->code = 0;
	while (*str >= '0' && *str <= '9') {
		hg->code *= 10;
		hg->code += *str - '0';
		str++;
	}
	if (!hg->code)
		return -2;
	while (*str == ' ')
		str++;

	end = strchr(str, '\n');
	hg->reason = xstrndup(str, end - str);
	str = end + 1;

	/* headers */
	while (*str) {
		char *ptr;

		end = strchr(str, '\n');
		ptr = strchr(str, ':');
		if (ptr == NULL || ptr > end) {
			free(hg->reason);
			hg->reason = NULL;
			keyvals_terminate(&h);
			keyvals_free(h.keyvals);
			return -2;
		}

		*ptr++ = 0;
		while (*ptr == ' ')
			ptr++;

		keyvals_add(&h, str, xstrndup(ptr, end - ptr));
		str = end + 1;
	}
	keyvals_terminate(&h);
	hg->headers = h.keyvals;
	return 0;
}

int http_get(struct http_get *hg, struct keyval *headers, int timeout_ms)
{
	GBUF(buf);
	int i, rc, save;

	gbuf_add_str(&buf, "GET ");
	gbuf_add_str(&buf, hg->proxy ? hg->uri.uri : hg->uri.path);
	gbuf_add_str(&buf, " HTTP/1.0\r\n");
	for (i = 0; headers[i].key; i++) {
		gbuf_add_str(&buf, headers[i].key);
		gbuf_add_str(&buf, ": ");
		gbuf_add_str(&buf, headers[i].val);
		gbuf_add_str(&buf, "\r\n");
	}
	gbuf_add_str(&buf, "\r\n");

	rc = http_write(hg->fd, buf.buffer, buf.len, timeout_ms);
	if (rc)
		goto out;

	gbuf_clear(&buf);
	rc = http_read_response(hg->fd, &buf, timeout_ms);
	if (rc)
		goto out;

	rc = http_parse_response(buf.buffer, hg);
out:
	save = errno;
	gbuf_free(&buf);
	errno = save;
	return rc;
}

char *http_read_body(int fd, size_t *size, int timeout_ms)
{
	GBUF(buf);

	if (read_timeout(fd, timeout_ms))
		return NULL;
	while (1) {
		int count = 1023;
		int rc;

		gbuf_grow(&buf, count);
		rc = read_all(fd, buf.buffer + buf.len, count);
		if (rc == -1) {
			gbuf_free(&buf);
			return NULL;
		}
		buf.len += rc;
		if (rc == 0) {
			*size = buf.len;
			return gbuf_steal(&buf);
		}
	}
}

void http_get_free(struct http_get *hg)
{
	http_free_uri(&hg->uri);
	if (hg->proxy) {
		http_free_uri(hg->proxy);
		free(hg->proxy);
	}
	if (hg->headers)
		keyvals_free(hg->headers);
	free(hg->reason);
}

char *base64_encode(const char *str)
{
	static const char t[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	int str_len, buf_len, i, s, d;
	char *buf;
	unsigned char b0, b1, b2;

	str_len = strlen(str);
	buf_len = (str_len + 2) / 3 * 4 + 1;
	buf = xnew(char, buf_len);
	s = 0;
	d = 0;
	for (i = 0; i < str_len / 3; i++) {
		b0 = str[s++];
		b1 = str[s++];
		b2 = str[s++];

		/* 6 ms bits of b0 */
		buf[d++] = t[b0 >> 2];

		/* 2 ls bits of b0 . 4 ms bits of b1 */
		buf[d++] = t[((b0 << 4) | (b1 >> 4)) & 0x3f];

		/* 4 ls bits of b1 . 2 ms bits of b2 */
		buf[d++] = t[((b1 << 2) | (b2 >> 6)) & 0x3f];

		/* 6 ls bits of b2 */
		buf[d++] = t[b2 & 0x3f];
	}
	switch (str_len % 3) {
	case 2:
		b0 = str[s++];
		b1 = str[s++];

		/* 6 ms bits of b0 */
		buf[d++] = t[b0 >> 2];

		/* 2 ls bits of b0 . 4 ms bits of b1 */
		buf[d++] = t[((b0 << 4) | (b1 >> 4)) & 0x3f];

		/* 4 ls bits of b1 */
		buf[d++] = t[(b1 << 2) & 0x3f];

		buf[d++] = '=';
		break;
	case 1:
		b0 = str[s++];

		/* 6 ms bits of b0 */
		buf[d++] = t[b0 >> 2];

		/* 2 ls bits of b0 */
		buf[d++] = t[(b0 << 4) & 0x3f];

		buf[d++] = '=';
		buf[d++] = '=';
		break;
	case 0:
		break;
	}
	buf[d] = 0;
	return buf;
}
#include "id3.h"
#include "xmalloc.h"
#include "convert.h"
#include "uchar.h"
#include "options.h"
#include "debug.h"
#include "utils.h"
#include "file.h"

#include <unistd.h>
#include <stdint.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <limits.h>

enum {
	ID3_ENCODING_ISO_8859_1 = 0x00,
	ID3_ENCODING_UTF_16     = 0x01,
	ID3_ENCODING_UTF_16_BE  = 0x02,
	ID3_ENCODING_UTF_8      = 0x03,

	ID3_ENCODING_MAX        = 0x03
};

/*
 * position:
 *
 *    0 "ID3"
 *  -10 "3DI"
 * -128 "TAG"
 * -138 "3DI"
 *
 * if v2 is at beginning _and_ at end then there must be a seek tag at beginning
 */

struct v2_header {
	unsigned char ver_major;
	unsigned char ver_minor;
	unsigned char flags;
	uint32_t size;
};

struct v2_extended_header {
	uint32_t size;
};

struct v2_frame_header {
	char id[4];
	uint32_t size;
	uint16_t flags;
};

#define V2_HEADER_UNSYNC	(1 << 7)
#define V2_HEADER_EXTENDED	(1 << 6)
#define V2_HEADER_EXPERIMENTAL	(1 << 5)
#define V2_HEADER_FOOTER	(1 << 4)

#define V2_FRAME_COMPRESSED	(1 << 3) /* great idea!!1 */
#define V2_FRAME_ENCRYPTHED	(1 << 2) /* wow, this is very neat! */
#define V2_FRAME_UNSYNC		(1 << 1)
#define V2_FRAME_LEN_INDICATOR	(1 << 0)

#define NR_GENRES 148
/* genres {{{ */
static const char *genres[NR_GENRES] = {
	"Blues",
	"Classic Rock",
	"Country",
	"Dance",
	"Disco",
	"Funk",
	"Grunge",
	"Hip-Hop",
	"Jazz",
	"Metal",
	"New Age",
	"Oldies",
	"Other",
	"Pop",
	"R&B",
	"Rap",
	"Reggae",
	"Rock",
	"Techno",
	"Industrial",
	"Alternative",
	"Ska",
	"Death Metal",
	"Pranks",
	"Soundtrack",
	"Euro-Techno",
	"Ambient",
	"Trip-Hop",
	"Vocal",
	"Jazz+Funk",
	"Fusion",
	"Trance",
	"Classical",
	"Instrumental",
	"Acid",
	"House",
	"Game",
	"Sound Clip",
	"Gospel",
	"Noise",
	"Alt",
	"Bass",
	"Soul",
	"Punk",
	"Space",
	"Meditative",
	"Instrumental Pop",
	"Instrumental Rock",
	"Ethnic",
	"Gothic",
	"Darkwave",
	"Techno-Industrial",
	"Electronic",
	"Pop-Folk",
	"Eurodance",
	"Dream",
	"Southern Rock",
	"Comedy",
	"Cult",
	"Gangsta Rap",
	"Top 40",
	"Christian Rap",
	"Pop/Funk",
	"Jungle",
	"Native American",
	"Cabaret",
	"New Wave",
	"Psychedelic",
	"Rave",
	"Showtunes",
	"Trailer",
	"Lo-Fi",
	"Tribal",
	"Acid Punk",
	"Acid Jazz",
	"Polka",
	"Retro",
	"Musical",
	"Rock & Roll",
	"Hard Rock",
	"Folk",
	"Folk/Rock",
	"National Folk",
	"Swing",
	"Fast-Fusion",
	"Bebob",
	"Latin",
	"Revival",
	"Celtic",
	"Bluegrass",
	"Avantgarde",
	"Gothic Rock",
	"Progressive Rock",
	"Psychedelic Rock",
	"Symphonic Rock",
	"Slow Rock",
	"Big Band",
	"Chorus",
	"Easy Listening",
	"Acoustic",
	"Humour",
	"Speech",
	"Chanson",
	"Opera",
	"Chamber Music",
	"Sonata",
	"Symphony",
	"Booty Bass",
	"Primus",
	"Porn Groove",
	"Satire",
	"Slow Jam",
	"Club",
	"Tango",
	"Samba",
	"Folklore",
	"Ballad",
	"Power Ballad",
	"Rhythmic Soul",
	"Freestyle",
	"Duet",
	"Punk Rock",
	"Drum Solo",
	"A Cappella",
	"Euro-House",
	"Dance Hall",
	"Goa",
	"Drum & Bass",
	"Club-House",
	"Hardcore",
	"Terror",
	"Indie",
	"BritPop",
	"Negerpunk",
	"Polsk Punk",
	"Beat",
	"Christian Gangsta Rap",
	"Heavy Metal",
	"Black Metal",
	"Crossover",
	"Contemporary Christian",
	"Christian Rock",
	"Merengue",
	"Salsa",
	"Thrash Metal",
	"Anime",
	"JPop",
	"Synthpop"
};
/* }}} */

#define id3_debug(...) d_print(__VA_ARGS__)

const char * const id3_key_names[NUM_ID3_KEYS] = {
	"artist",
	"album",
	"title",
	"date",
	"originaldate",
	"genre",
	"discnumber",
	"tracknumber",
	"albumartist",
	"artistsort",
	"albumartistsort",
	"albumsort",
	"compilation",
	"replaygain_track_gain",
	"replaygain_track_peak",
	"replaygain_album_gain",
	"replaygain_album_peak",
	"composer",
	"conductor",
	"lyricist",
	"remixer",
	"label",
	"publisher",
	"subtitle",
	"comment",
	"musicbrainz_trackid",
	"media",
	"bpm",
};

static int utf16_is_lsurrogate(uchar uch)
{
	return 0xdc00 <= uch && 0xdfff >= uch;
}

static int utf16_is_hsurrogate(uchar uch)
{
	return 0xd800 <= uch && 0xdbff >= uch;
}

static int utf16_is_bom(uchar uch)
{
	return uch == 0xfeff;
}

static int utf16_is_special(uchar uch)
{
	return utf16_is_hsurrogate(uch) || utf16_is_lsurrogate(uch) || utf16_is_bom(uch);
}

static char *utf16_to_utf8(const unsigned char *buf, size_t buf_size)
{
	char *out;
	size_t i, idx;
	int little_endian = 0;

	if (buf_size < 2)
		return NULL;

	if (buf[0] == 0xff && buf[1] == 0xfe)
		little_endian = 1;

	out = xnew(char, (buf_size / 2) * 4 + 1);
	i = idx = 0;

	while (buf_size - i >= 2) {
		uchar u;

		if (little_endian)
			u = buf[i] + (buf[i + 1] << 8);
		else
			u = buf[i + 1] + (buf[i] << 8);

		if (u_is_unicode(u)) {
			if (!utf16_is_special(u))
				u_set_char(out, &idx, u);
		} else {
			free(out);
			return NULL;
		}

		if (u == 0)
			return out;

		i += 2;
	}

	u_set_char(out, &idx, 0);
	return out;
}

static int is_v1(const char *buf)
{
	return buf[0] == 'T' && buf[1] == 'A' && buf[2] == 'G';
}

static int u32_unsync(const unsigned char *buf, uint32_t *up)
{
	uint32_t b, u = 0;
	int i;

	for (i = 0; i < 4; i++) {
		b = buf[i];
		if (b >= 0x80)
			return 0;
		u <<= 7;
		u |= b;
	}
	*up = u;
	return 1;
}

static void get_u32(const unsigned char *buf, uint32_t *up)
{
	uint32_t b, u = 0;
	int i;

	for (i = 0; i < 4; i++) {
		b = buf[i];
		u <<= 8;
		u |= b;
	}
	*up = u;
}

static void get_u24(const unsigned char *buf, uint32_t *up)
{
	uint32_t b, u = 0;
	int i;

	for (i = 0; i < 3; i++) {
		b = buf[i];
		u <<= 8;
		u |= b;
	}
	*up = u;
}

static void get_i16(const unsigned char *buf, int16_t *ip)
{
	uint16_t b, u = 0;
	int i;

	for (i = 0; i < 2; i++) {
		b = buf[i];
		u <<= 8;
		u |= b;
	}
	*ip = u;
}

static int v2_header_footer_parse(struct v2_header *header, const char *buf)
{
	const unsigned char *b = (const unsigned char *)buf;

	header->ver_major = b[3];
	header->ver_minor = b[4];
	header->flags = b[5];
	if (header->ver_major == 0xff || header->ver_minor == 0xff)
		return 0;
	return u32_unsync(b + 6, &header->size);
}

static int v2_header_parse(struct v2_header *header, const char *buf)
{
	if (buf[0] != 'I' || buf[1] != 'D' || buf[2] != '3')
		return 0;
	return v2_header_footer_parse(header, buf);
}

static int v2_footer_parse(struct v2_header *header, const char *buf)
{
	if (buf[0] != '3' || buf[1] != 'D' || buf[2] != 'I')
		return 0;
	return v2_header_footer_parse(header, buf);
}

static int v2_extended_header_parse(struct v2_extended_header *header, const char *buf)
{
	return u32_unsync((const unsigned char *)buf, &header->size);
}

static int is_frame_id_char(char ch)
{
	return (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9');
}

/* XXXYYY
 *
 * X = [A-Z0-9]
 * Y = byte
 *
 * XXX is frame
 * YYY is frame size excluding this 6 byte header
 */
static int v2_2_0_frame_header_parse(struct v2_frame_header *header, const char *buf)
{
	int i;

	for (i = 0; i < 3; i++) {
		if (!is_frame_id_char(buf[i]))
			return 0;
		header->id[i] = buf[i];
	}
	header->id[3] = 0;
	get_u24((const unsigned char *)(buf + 3), &header->size);
	header->flags = 0;
	if (header->size == 0)
		return 0;
	id3_debug("%c%c%c %d\n", header->id[0], header->id[1], header->id[2], header->size);
	return 1;
}

/* XXXXYYYYZZ
 *
 * X = [A-Z0-9]
 * Y = byte
 * Z = byte
 *
 * XXXX is frame
 * YYYY is frame size excluding this 10 byte header
 * ZZ   is flags
 */
static int v2_3_0_frame_header_parse(struct v2_frame_header *header, const char *buf)
{
	int i;

	for (i = 0; i < 4; i++) {
		if (!(is_frame_id_char(buf[i]) || (i == 3 && buf[i] == '\0')))
			return 0;
		header->id[i] = buf[i];
	}
	get_u32((const unsigned char *)(buf + 4), &header->size);
	header->flags = (buf[8] << 8) | buf[9];
	if (header->size == 0)
		return 0;
	id3_debug("%c%c%c%c %d\n", header->id[0], header->id[1], header->id[2],
			header->id[3], header->size);
	return 1;
}

/* same as 2.3 but header size is sync safe */
static int v2_4_0_frame_header_parse(struct v2_frame_header *header, const char *buf)
{
	int i;

	for (i = 0; i < 4; i++) {
		if (!(is_frame_id_char(buf[i]) || (i == 3 && buf[i] == '\0')))
			return 0;
		header->id[i] = buf[i];
	}
	if (!u32_unsync((const unsigned char *)(buf + 4), &header->size))
		return 0;
	header->flags = (buf[8] << 8) | buf[9];
	if (header->size == 0)
		return 0;
	id3_debug("%c%c%c%c %d\n", header->id[0], header->id[1], header->id[2],
			header->id[3], header->size);
	return 1;
}

static char *parse_genre(const char *str)
{
	int parenthesis = 0;
	long int idx;
	char *end;

	if (strncasecmp(str, "(RX", 3) == 0)
		return xstrdup("Remix");

	if (strncasecmp(str, "(CR", 3) == 0)
		return xstrdup("Cover");

	if (*str == '(') {
		parenthesis = 1;
		str++;
	}

	idx = strtol(str, &end, 10);
	if (str != end) {
		/* Number parsed but there may be some crap after the number.
		 * I don't care, ID3v2 by definition contains crap.
		 */
		if (idx >= 0 && idx < NR_GENRES)
			return xstrdup(genres[idx]);
	}

	if (parenthesis) {
		const char *ptr = strchr(str, ')');

		if (ptr && ptr[1]) {
			/* genre name after random crap in parenthesis,
			 * return the genre name */
			return xstrdup(ptr + 1);
		}
		str--;
	}

	/* random crap, just return it and wait for a bug report */
	return xstrdup(str);
}

/* http://www.id3.org/id3v2.4.0-structure.txt */
static struct {
	const char name[8];
	enum id3_key key;
} frame_tab[] = {
	/* 2.4.0 */
	{ "TDRC", ID3_DATE }, // recording date
	{ "TDRL", ID3_DATE }, // release date
	{ "TDOR", ID3_ORIGINALDATE }, // original release date
	{ "TSOP", ID3_ARTISTSORT },
	{ "TSOA", ID3_ALBUMSORT },

	/* >= 2.3.0 */
	{ "TPE1", ID3_ARTIST },
	{ "TALB", ID3_ALBUM },
	{ "TIT2", ID3_TITLE },
	{ "TYER", ID3_DATE },
	{ "TCON", ID3_GENRE },
	{ "TPOS", ID3_DISC },
	{ "TRCK", ID3_TRACK },
	{ "TPE2", ID3_ALBUMARTIST },
	{ "TSO2", ID3_ALBUMARTISTSORT },
	{ "XSOP", ID3_ARTISTSORT }, // obsolete
	{ "XSOA", ID3_ALBUMSORT }, // obsolete
	{ "TCMP", ID3_COMPILATION },
	{ "TORY", ID3_ORIGINALDATE },
	{ "TCOM", ID3_COMPOSER },
	{ "TPE3", ID3_CONDUCTOR },
	{ "TEXT", ID3_LYRICIST },
	{ "TPE4", ID3_REMIXER },
	{ "TPUB", ID3_PUBLISHER }, // TPUB can be both publisher or label
	{ "TIT3", ID3_SUBTITLE },
	{ "TMED", ID3_MEDIA },
	{ "TBPM", ID3_BPM},

	/* obsolete frames (2.2.0) */
	{ "TP1",  ID3_ARTIST },
	{ "TP2",  ID3_ALBUMARTIST },
	{ "TAL",  ID3_ALBUM },
	{ "TT2",  ID3_TITLE },
	{ "TYE",  ID3_DATE },
	{ "TCO",  ID3_GENRE },
	{ "TPA",  ID3_DISC },
	{ "TRK",  ID3_TRACK },
	{ "TSP",  ID3_ARTISTSORT },
	{ "TS2",  ID3_ALBUMARTISTSORT },
	{ "TSA",  ID3_ALBUMSORT },
	{ "TCP",  ID3_COMPILATION },
	{ "TBP",  ID3_BPM },
};

static int frame_tab_index(const char *id)
{
	int i = 0;

	while (i < N_ELEMENTS(frame_tab)) {
		if (!strncmp(id, frame_tab[i].name, 4))
			return i;
		i++;
	}
	return -1;
}

static int check_date_format(const char *buf)
{
	int i, ch;

	/* year */
	for (i = 0; i < 4; i++) {
		ch = *buf++;
		if (ch < '0' || ch > '9')
			return 0;
	}
	ch = *buf++;
	if (!ch)
		return 4;
	if (ch != '-')
		return 0;

	/* month */
	for (i = 0; i < 2; i++) {
		ch = *buf++;
		if (ch < '0' || ch > '9')
			return 0;
	}
	ch = *buf++;
	if (!ch)
		return 7;
	if (ch != '-')
		return 0;

	/* day */
	for (i = 0; i < 2; i++) {
		ch = *buf++;
		if (ch < '0' || ch > '9')
			return 0;
	}
	ch = *buf;
	if (!ch || (ch >= '0' && ch <= '9'))
		return 10;
	return 0;
}

static void fix_date(char *buf)
{
	const char *ptr = buf;
	int ch, len = 0;

	do {
		ch = *ptr++;
		if (ch >= '0' && ch <= '9') {
			len++;
			continue;
		}
		if (len == 4) {
			// number which length is 4, must be year
			memmove(buf, ptr - 5, 4);
			buf[4] = 0;
			return;
		}
		len = 0;
	} while (ch);
	*buf = 0;
}

static char *decode_str(const char *buf, int len, int encoding)
{
	char *in, *out = NULL;

	switch (encoding) {
	case ID3_ENCODING_ISO_8859_1:
		in = xstrndup(buf, len);
		utf8_encode(in, id3_default_charset, &out);
		free(in);
		break;
	case ID3_ENCODING_UTF_8:
		in = xstrndup(buf, len);
		if (u_is_valid(in)) {
			out = in;
		} else {
			utf8_encode(in, id3_default_charset, &out);
			free(in);
		}
		break;
	case ID3_ENCODING_UTF_16:
	case ID3_ENCODING_UTF_16_BE:
		out = utf16_to_utf8((const unsigned char *)buf, len);
		break;
	}
	return out;
}

static void add_v2(struct id3tag *id3, enum id3_key key, char *value)
{
	free(id3->v2[key]);
	id3->v2[key] = value;
	id3->has_v2 = 1;
}

static void decode_normal(struct id3tag *id3, const char *buf, int len, int encoding, enum id3_key key)
{
	char *out = decode_str(buf, len, encoding);

	if (!out)
		return;

	if (key == ID3_GENRE) {
		char *tmp;

		id3_debug("genre before: '%s'\n", out);
		tmp = parse_genre(out);
		free(out);
		out = tmp;
	} else if (key == ID3_DATE || key == ID3_ORIGINALDATE) {
		int date_len = check_date_format(out);
		id3_debug("date before: '%s'\n", out);
		if (date_len)
			out[date_len] = '\0';
		else
			fix_date(out);
		if (!*out) {
			id3_debug("date parsing failed\n");
			free(out);
			return;
		}
	} else if (key == ID3_ALBUMARTIST) {
		/*
		 * This must be TPE2 frame; ignore it if ID3_ALBUMARTIST is
		 * already present
		 */
		if (id3->v2[key]) {
			free(out);
			return;
		}
	} else if (key == ID3_PUBLISHER) {
		 add_v2(id3, ID3_LABEL, strdup(out));
	}

	add_v2(id3, key, out);
}

static size_t id3_skiplen(const char *buf, size_t len, int encoding)
{
	if (encoding == ID3_ENCODING_ISO_8859_1 || encoding == ID3_ENCODING_UTF_8) {
		return strlen(buf) + 1;
	} else {
		int i = 0;
		while (i + 1 < len) {
			if (buf[i] == '\0' && buf[i + 1] == '\0')
				return i + 2;

			/* Assume every character is exactly 2 bytes */
			i += 2;
		}

		return len;
	}
}

static void decode_txxx(struct id3tag *id3, const char *buf, int len, int encoding)
{
	const char ql_prefix[] = "QuodLibet::";
	enum id3_key key = NUM_ID3_KEYS;
	int size;
	char *out, *out_mem;

	out = decode_str(buf, len, encoding);
	if (!out)
		return;

	id3_debug("TXXX, key = '%s'\n", out);

	out_mem = out;

	/* skip braindead QuodLibet TXXX frame prefix */
	if (!strncmp(out, ql_prefix, sizeof(ql_prefix) - 1))
		out += sizeof(ql_prefix) - 1;

	if (!strcasecmp(out, "replaygain_track_gain"))
		key = ID3_RG_TRACK_GAIN;
	else if (!strcasecmp(out, "replaygain_track_peak"))
		key = ID3_RG_TRACK_PEAK;
	else if (!strcasecmp(out, "replaygain_album_gain"))
		key = ID3_RG_ALBUM_GAIN;
	else if (!strcasecmp(out, "replaygain_album_peak"))
		key = ID3_RG_ALBUM_PEAK;
	else if (!strcasecmp(out, "album artist"))
		key = ID3_ALBUMARTIST;
	else if (!strcasecmp(out, "albumartist"))
		key = ID3_ALBUMARTIST;
	else if (!strcasecmp(out, "albumartistsort"))
		key = ID3_ALBUMARTISTSORT;
	else if (!strcasecmp(out, "albumsort"))
		key = ID3_ALBUMSORT;
	else if (!strcasecmp(out, "compilation"))
		key = ID3_COMPILATION;

	size = id3_skiplen(buf, len, encoding);
	free(out_mem);

	if (key == NUM_ID3_KEYS)
		return;

	buf += size;
	len -= size;
	if (len <= 0)
		return;

	out = decode_str(buf, len, encoding);
	if (!out)
		return;

	add_v2(id3, key, out);
}

static void decode_comment(struct id3tag *id3, const char *buf, int len, int encoding)
{
	int slen;
	char *out;
	int valid_description;

	if (len <= 3)
		return;

	/* skip language */
	buf += 3;
	len -= 3;

	/* "Short content description" part of COMM frame */
	out = decode_str(buf, len, encoding);
	if (!out)
		return;

	valid_description = strcmp(out, "") == 0 || strcmp(out, "description") == 0;
	free(out);

	if (!valid_description)
		return;

	slen = id3_skiplen(buf, len, encoding);
	if (slen >= len)
		return;

	buf += slen;
	len -= slen;

	out = decode_str(buf, len, encoding);
	if (!out)
		return;

	add_v2(id3, ID3_COMMENT, out);
}

/*
 * From http://id3.org/id3v2.4.0-frames:
 *
 * The volume adjustment is encoded as a fixed point decibel value, 16 bit signed
 * integer representing (adjustment*512), giving +/- 64 dB with a precision of
 * 0.001953125 dB. E.g. +2 dB is stored as $04 00 and -2 dB is $FC 00. There may
 * be more than one "RVA2" frame in each tag, but only one with the same
 * identification string.
 *
 * 	<Header for 'Relative volume adjustment (2)', ID: "RVA2">
 * 	Identification          <text string> $00
 *
 * The 'identification' string is used to identify the situation and/or device
 * where this adjustment should apply. The following is then repeated for every
 * channel
 *
 * 	Type of channel         $xx
 * 	Volume adjustment       $xx xx
 * 	Bits representing peak  $xx
 * 	Peak volume             $xx (xx ...)
 *
 * Type of channel:	$00 Other
 * 			$01 Master volume
 * 			$02 Front right
 * 			$03 Front left
 * 			$04 Back right
 * 			$05 Back left
 * 			$06 Front centre
 * 			$07 Back centre
 * 			$08 Subwoofer
 *
 * Bits representing peak can be any number between 0 and 255. 0 means that there
 * is no peak volume field. The peak volume field is always padded to whole
 * bytes, setting the most significant bits to zero.
 */
static void decode_rva2(struct id3tag *id3, const char *buf, int len)
{
	const int rva2_min_len	= 6 + 1 + 2 + 1;

	int audiophile_rg	= 0;
	int channel		= 0;
	int16_t volume_adj	= 0;
	int peak_bits		= 0;
	int peak_bytes		= 0;
	int peak_shift		= 0;
	uint32_t peak		= 0;

	char *gain_str		= NULL;
	char *peak_str		= NULL;

	int i;

	if (len < rva2_min_len) {
		id3_debug("frame length %d too small\n", len);
		return;
	}

	if (!strcasecmp(buf, "album")) {
		audiophile_rg = 1;
	} else if (strcasecmp(buf, "track")) {
		id3_debug("unsupported identifier: %s\n", buf);
		return;
	}

	buf += 6;

	channel = *buf++;
	if (channel != 0x1) {
		id3_debug("unsupported channel: %d\n", channel);
		return;
	}

	get_i16((unsigned char *)buf, &volume_adj);
	buf += 2;

	peak_bits = *buf++;

	if (peak_bits == 0)
		id3_debug("no peak data\n");

	/*
	 * This crazy code comes from Mutagen
	 */
	peak_bytes = min_i(4, (peak_bits + 7) >> 3);
	peak_shift = ((8 - (peak_bits & 7)) & 7) + (4 - peak_bytes) * 8;

	if (len < rva2_min_len + peak_bytes) {
		id3_debug("peak data %d does not fit frame with length %d\n", peak_bytes, len);
		return;
	}

	for (i = 0; i < peak_bytes; ++i) {
		peak <<= 8;
		peak |= (unsigned char)*buf++;
	}

	gain_str = xnew(char, 32);
	snprintf(gain_str, 32, "%lf dB", volume_adj / 512.0);

	add_v2(id3, audiophile_rg ? ID3_RG_ALBUM_GAIN : ID3_RG_TRACK_GAIN, gain_str);

	if (peak_bytes) {
		peak_str = xnew(char, 32);
		snprintf(peak_str, 32, "%lf", ((double)peak * (1 << peak_shift)) / INT_MAX);

		add_v2(id3, audiophile_rg ? ID3_RG_ALBUM_PEAK : ID3_RG_TRACK_PEAK, peak_str);
	}

	id3_debug("gain %s, peak %s\n", gain_str, peak_str ? peak_str : "none");
}

static void decode_ufid(struct id3tag *id3, const char *buf, int len)
{
	char *ufid;
	int ufid_len = len - 22 - 1;

	if (ufid_len < 0 || strcmp(buf, "http://musicbrainz.org") != 0)
		return;

	ufid = xnew(char, ufid_len + 1);
	memcpy(ufid, buf + len - ufid_len, ufid_len);
	ufid[ufid_len] = '\0';

	id3_debug("%s: %s\n", buf, ufid);
	add_v2(id3, ID3_MUSICBRAINZ_TRACKID, ufid);
}


static void v2_add_frame(struct id3tag *id3, struct v2_frame_header *fh, const char *buf)
{
	int encoding;
	int len;
	int idx;

	if (!strncmp(fh->id, "RVA2", 4)) {
		decode_rva2(id3, buf, fh->size);
		return;
	} else if (!strncmp(fh->id, "UFID", 4)) {
		decode_ufid(id3, buf, fh->size);
		return;
	}

	encoding = *buf++;
	len = fh->size - 1;

	if (encoding > ID3_ENCODING_MAX)
		return;

	idx = frame_tab_index(fh->id);
	if (idx >= 0) {
		decode_normal(id3, buf, len, encoding, frame_tab[idx].key);
	} else if (!strncmp(fh->id, "TXXX", 4)) {
		decode_txxx(id3, buf, len, encoding);
	} else if (!strncmp(fh->id, "COMM", 4)) {
		decode_comment(id3, buf, len, encoding);
	} else if (!strncmp(fh->id, "COM", 3)) {
		decode_comment(id3, buf, len, encoding);
	}
}

static void unsync(unsigned char *buf, int *lenp)
{
	int len = *lenp;
	int s, d;

	s = d = 0;
	while (s < len - 1) {
		if (buf[s] == 0xff && buf[s + 1] == 0x00) {
			/* 0xff 0x00 -> 0xff */
			buf[d++] = 0xff;
			s += 2;

			if (s < len - 2 && buf[s] == 0x00) {
				/* 0xff 0x00 0x00 -> 0xff 0x00 */
				buf[d++] = 0x00;
				s++;
			}
			continue;
		}
		buf[d++] = buf[s++];
	}
	if (s < len)
		buf[d++] = buf[s++];

	d_print("de-synchronization removed %d bytes\n", s - d);
	*lenp = d;
}

static int v2_read(struct id3tag *id3, int fd, const struct v2_header *header)
{
	char *buf;
	int rc, buf_size;
	int frame_start, i;
	int frame_header_size;

	buf_size = header->size;
	buf = xnew(char, buf_size);
	rc = read_all(fd, buf, buf_size);
	if (rc == -1) {
		free(buf);
		return rc;
	}

	frame_start = 0;
	if (header->flags & V2_HEADER_EXTENDED) {
		struct v2_extended_header ext;

		if (!v2_extended_header_parse(&ext, buf) || ext.size > buf_size) {
			id3_debug("extended header corrupted\n");
			free(buf);
			return -2;
		}
		frame_start = ext.size;
		/* should check if update flag is set */
	}

	frame_header_size = 10;
	if (header->ver_major == 2)
		frame_header_size = 6;

	i = frame_start;
	while (i < buf_size - frame_header_size) {
		struct v2_frame_header fh;
		int len_unsync;

		if (header->ver_major == 2) {
			if (!v2_2_0_frame_header_parse(&fh, buf + i))
				break;
		} else if (header->ver_major == 3) {
			if (!v2_3_0_frame_header_parse(&fh, buf + i))
				break;
		} else {
			/* assume v2.4 */
			if (!v2_4_0_frame_header_parse(&fh, buf + i))
				break;
		}

		i += frame_header_size;

		if (fh.size > buf_size - i) {
			id3_debug("frame too big\n");
			break;
		}

		if (fh.flags & V2_FRAME_LEN_INDICATOR) {
			/*
			 * Ignore the frame length 4-byte field
			 */
			i	+= 4;
			fh.size	-= 4;
		}

		len_unsync = fh.size;

		if ((fh.flags & V2_FRAME_UNSYNC) || (header->flags & V2_HEADER_UNSYNC))
			unsync((unsigned char *)(buf + i), (int *)&fh.size);

		v2_add_frame(id3, &fh, buf + i);

		i += len_unsync;
	}

	free(buf);
	return 0;
}

int id3_tag_size(const char *buf, int buf_size)
{
	struct v2_header header;

	if (buf_size < 10)
		return 0;
	if (v2_header_parse(&header, buf)) {
		if (header.flags & V2_HEADER_FOOTER) {
			/* header + data + footer */
			id3_debug("v2.%d.%d with footer\n", header.ver_major, header.ver_minor);
			return 10 + header.size + 10;
		}
		/* header */
		id3_debug("v2.%d.%d\n", header.ver_major, header.ver_minor);
		return 10 + header.size;
	}
	if (buf_size >= 3 && is_v1(buf)) {
		id3_debug("v1\n");
		return 128;
	}
	return 0;
}

void id3_init(struct id3tag *id3)
{
	const struct id3tag t = { .has_v1 = 0, .has_v2 = 0 };
	*id3 = t;
}

void id3_free(struct id3tag *id3)
{
	int i;

	for (i = 0; i < NUM_ID3_KEYS; i++)
		free(id3->v2[i]);
}

int id3_read_tags(struct id3tag *id3, int fd, unsigned int flags)
{
	off_t off;
	int rc;

	if (flags & ID3_V2) {
		struct v2_header header;
		char buf[138];

		rc = read_all(fd, buf, 10);
		if (rc == -1)
			goto rc_error;
		if (v2_header_parse(&header, buf)) {
			rc = v2_read(id3, fd, &header);
			if (rc)
				goto rc_error;
			/* get v1 if needed */
		} else {
			/* get v2 from end and optionally v1 */

			off = lseek(fd, -138, SEEK_END);
			if (off == -1)
				goto error;
			rc = read_all(fd, buf, 138);
			if (rc == -1)
				goto rc_error;

			if (is_v1(buf + 10)) {
				if (flags & ID3_V1) {
					memcpy(id3->v1, buf + 10, 128);
					id3->has_v1 = 1;
				}
				if (v2_footer_parse(&header, buf)) {
					/* footer at end of file - 128 */
					off = lseek(fd, -((off_t) header.size + 138), SEEK_END);
					if (off == -1)
						goto error;
					rc = v2_read(id3, fd, &header);
					if (rc)
						goto rc_error;
				}
			} else if (v2_footer_parse(&header, buf + 128)) {
				/* footer at end of file */
				off = lseek(fd, -((off_t) header.size + 10), SEEK_END);
				if (off == -1)
					goto error;
				rc = v2_read(id3, fd, &header);
				if (rc)
					goto rc_error;
			}
			return 0;
		}
	}
	if (flags & ID3_V1) {
		off = lseek(fd, -128, SEEK_END);
		if (off == -1)
			goto error;
		rc = read_all(fd, id3->v1, 128);
		if (rc == -1)
			goto rc_error;
		id3->has_v1 = is_v1(id3->v1);
	}
	return 0;
error:
	rc = -1;
rc_error:
	return rc;
}

static char *v1_get_str(const char *buf, int len)
{
	char in[32];
	char *out;
	int i;

	for (i = len - 1; i >= 0; i--) {
		if (buf[i] != 0 && buf[i] != ' ')
			break;
	}
	if (i == -1)
		return NULL;
	memcpy(in, buf, i + 1);
	in[i + 1] = 0;
	if (u_is_valid(in))
		return xstrdup(in);
	if (utf8_encode(in, id3_default_charset, &out))
		return NULL;
	return out;
}

char *id3_get_comment(struct id3tag *id3, enum id3_key key)
{
	if (id3->has_v2) {
		if (id3->v2[key])
			return xstrdup(id3->v2[key]);
	}
	if (id3->has_v1) {
		switch (key) {
		case ID3_ARTIST:
			return v1_get_str(id3->v1 + 33, 30);
		case ID3_ALBUM:
			return v1_get_str(id3->v1 + 63, 30);
		case ID3_TITLE:
			return v1_get_str(id3->v1 + 3, 30);
		case ID3_DATE:
			return v1_get_str(id3->v1 + 93, 4);
		case ID3_GENRE:
			{
				unsigned char idx = id3->v1[127];

				if (idx >= NR_GENRES)
					return NULL;
				return xstrdup(genres[idx]);
			}
		case ID3_TRACK:
			{
				char *t;

				if (id3->v1[125] != 0)
					return NULL;
				t = xnew(char, 4);
				snprintf(t, 4, "%d", ((unsigned char *)id3->v1)[126]);
				return t;
			}
		default:
			return NULL;
		}
	}
	return NULL;
}

char const *id3_get_genre(uint16_t id)
{
	if (id >= NR_GENRES)
		return NULL;
	return genres[id];
}
ata.fd, &readfds);
	/* zero timeout -> return immediately */
	tv.tv_sec = 0;
	tv.tv_usec = 50e3;
	rc = select(ip->data.fd + 1, &readfds, NULL, NULL, &tv);
	if (rc == -1) {
		if (errno == EINTR)
			errno = EAGAIN;
		return -1;
	}
	if (rc == 0) {
		errno = EAGAIN;
		return -1;
	}

	buf = buffer;
	if (ip->pcm_convert_scale > 1) {
		/* use tmp buffer for 16-bit mono and 8-bit */
		buf = tmp;
		count /= ip->pcm_convert_scale;
		if (count > sizeof(tmp))
			count = sizeof(tmp);
	}

	rc = ip->ops->read(&ip->data, buf, count);
	if (rc == -1 && (errno == EAGAIN || errno == EINTR)) {
		errno = EAGAIN;
		return -1;
	}
	if (rc <= 0) {
		ip->eof = 1;
		return rc;
	}

	BUG_ON(rc % sf_get_frame_size(ip->data.sf) != 0);

	sample_size = sf_get_sample_size(ip->data.sf);
	if (ip->pcm_convert_in_place != NULL)
		ip->pcm_convert_in_place(buf, rc / sample_size);
	if (ip->pcm_convert != NULL)
		ip->pcm_convert(buffer, tmp, rc / sample_size);
	return rc * ip->pcm_convert_scale;
}

int ip_seek(struct input_plugin *ip, double offset)
{
	int rc;

	if (ip->data.remote)
		return -IP_ERROR_FUNCTION_NOT_SUPPORTED;
	rc = ip->ops->seek(&ip->data, offset);
	if (rc == 0)
		ip->eof = 0;
	return rc;
}

int ip_read_comments(struct input_plugin *ip, struct keyval **comments)
{
	struct keyval *kv = NULL;
	int rc;

	rc = ip->ops->read_comments(&ip->data, &kv);

	if (ip->data.remote) {
		GROWING_KEYVALS(c);

		if (kv) {
			keyvals_init(&c, kv);
			keyvals_free(kv);
		}

		if (ip->data.icy_name && !keyvals_get_val_growing(&c, "title"))
			keyvals_add(&c, "title", xstrdup(ip->data.icy_name));

		if (ip->data.icy_genre && !keyvals_get_val_growing(&c, "genre"))
			keyvals_add(&c, "genre", xstrdup(ip->data.icy_genre));

		if (ip->data.icy_url && !keyvals_get_val_growing(&c, "comment"))
			keyvals_add(&c, "comment", xstrdup(ip->data.icy_url));

		keyvals_terminate(&c);

		kv = c.keyvals;
	}

	*comments = kv;

	return ip->data.remote ? 0 : rc;
}

int ip_duration(struct input_plugin *ip)
{
	if (ip->data.remote)
		return -1;
	if (ip->duration == -1)
		ip->duration = ip->ops->duration(&ip->data);
	if (ip->duration < 0)
		return -1;
	return ip->duration;
}

int ip_bitrate(struct input_plugin *ip)
{
	if (ip->data.remote)
		return -1;
	if (ip->bitrate == -1)
		ip->bitrate = ip->ops->bitrate(&ip->data);
	if (ip->bitrate < 0)
		return -1;
	return ip->bitrate;
}

int ip_current_bitrate(struct input_plugin *ip)
{
	return ip->ops->bitrate_current(&ip->data);
}

char *ip_codec(struct input_plugin *ip)
{
	if (ip->data.remote)
		return NULL;
	if (!ip->codec)
		ip->codec = ip->ops->codec(&ip->data);
	return ip->codec;
}

char *ip_codec_profile(struct input_plugin *ip)
{
	if (ip->data.remote)
		return NULL;
	if (!ip->codec_profile)
		ip->codec_profile = ip->ops->codec_profile(&ip->data);
	return ip->codec_profile;
}

sample_format_t ip_get_sf(struct input_plugin *ip)
{
	BUG_ON(!ip->open);
	return ip->data.sf;
}

void ip_get_channel_map(struct input_plugin *ip, channel_position_t *channel_map)
{
	BUG_ON(!ip->open);
	channel_map_copy(channel_map, ip->data.channel_map);
}

const char *ip_get_filename(struct input_plugin *ip)
{
	return ip->data.filename;
}

const char *ip_get_metadata(struct input_plugin *ip)
{
	BUG_ON(!ip->open);
	return ip->data.metadata;
}

int ip_is_remote(struct input_plugin *ip)
{
	return ip->data.remote;
}

int ip_metadata_changed(struct input_plugin *ip)
{
	int ret = ip->data.metadata_changed;

	BUG_ON(!ip->open);
	ip->data.metadata_changed = 0;
	return ret;
}

int ip_eof(struct input_plugin *ip)
{
	BUG_ON(!ip->open);
	return ip->eof;
}

static void option_error(int rc)
{
	char *msg = ip_get_error_msg(NULL, rc, "setting option");
	error_msg("%s", msg);
	free(msg);
}

static void set_ip_option(void *data, const char *val)
{
	const struct input_plugin_opt *ipo = data;
	int rc;

	rc = ipo->set(val);
	if (rc)
		option_error(rc);
}

static void get_ip_option(void *data, char *buf, size_t size)
{
	const struct input_plugin_opt *ipo = data;
	char *val = NULL;

	ipo->get(&val);
	if (val) {
		strscpy(buf, val, size);
		free(val);
	}
}

static void set_ip_priority(void *data, const char *val)
{
	/* warn only once during the lifetime of the program. */
	static bool warned = false;
	long tmp;
	struct ip *ip = data;

	if (str_to_int(val, &tmp) == -1 || tmp < 0 || (long)(int)tmp != tmp) {
		error_msg("non-negative integer expected");
		return;
	}
	if (ui_initialized) {
		if (!warned) {
			static const char *msg =
				"Metadata might become inconsistent "
				"after this change. Continue? [y/N]";
			if (yes_no_query("%s", msg) != UI_QUERY_ANSWER_YES) {
				info_msg("Aborted");
				return;
			}
			warned = true;
		}
		info_msg("Run \":update-cache -f\" to refresh the metadata.");
	}

	ip_wrlock();
	ip->priority = (int)tmp;
	list_mergesort(&ip_head, sort_ip);
	ip_unlock();
}

static void get_ip_priority(void *data, char *val, size_t size)
{
	const struct ip *ip = data;
	ip_rdlock();
	snprintf(val, size, "%d", ip->priority);
	ip_unlock();
}

void ip_add_options(void)
{
	struct ip *ip;
	const struct input_plugin_opt *ipo;
	char key[64];

	ip_rdlock();
	list_for_each_entry(ip, &ip_head, node) {
		for (ipo = ip->options; ipo->name; ipo++) {
			snprintf(key, sizeof(key), "input.%s.%s", ip->name,
					ipo->name);
			option_add(xstrdup(key), ipo, get_ip_option,
					set_ip_option, NULL, 0);
		}
		snprintf(key, sizeof(key), "input.%s.priority", ip->name);
		option_add(xstrdup(key), ip, get_ip_priority, set_ip_priority, NULL, 0);
	}
	ip_unlock();
}

char *ip_get_error_msg(struct input_plugin *ip, int rc, const char *arg)
{
	char buffer[1024];

	switch (-rc) {
	case IP_ERROR_ERRNO:
		snprintf(buffer, sizeof(buffer), "%s: %s", arg, strerror(errno));
		break;
	case IP_ERROR_UNRECOGNIZED_FILE_TYPE:
		snprintf(buffer, sizeof(buffer),
				"%s: unrecognized filename extension", arg);
		break;
	case IP_ERROR_UNSUPPORTED_FILE_TYPE:
		snprintf(buffer, sizeof(buffer),
				"%s: unsupported file format", arg);
		break;
	case IP_ERROR_FUNCTION_NOT_SUPPORTED:
		snprintf(buffer, sizeof(buffer),
				"%s: function not supported", arg);
		break;
	case IP_ERROR_FILE_FORMAT:
		snprintf(buffer, sizeof(buffer),
				"%s: file format not supported or corrupted file",
				arg);
		break;
	case IP_ERROR_INVALID_URI:
		snprintf(buffer, sizeof(buffer), "%s: invalid URI", arg);
		break;
	case IP_ERROR_SAMPLE_FORMAT:
		snprintf(buffer, sizeof(buffer),
				"%s: input plugin doesn't support the sample format",
				arg);
		break;
	case IP_ERROR_WRONG_DISC:
		snprintf(buffer, sizeof(buffer), "%s: wrong disc inserted, aborting!", arg);
		break;
	case IP_ERROR_NO_DISC:
		snprintf(buffer, sizeof(buffer), "%s: could not read disc", arg);
		break;
	case IP_ERROR_HTTP_RESPONSE:
		snprintf(buffer, sizeof(buffer), "%s: invalid HTTP response", arg);
		break;
	case IP_ERROR_HTTP_STATUS:
		snprintf(buffer, sizeof(buffer), "%s: %d %s", arg, ip->http_code, ip->http_reason);
		free(ip->http_reason);
		ip->http_reason = NULL;
		ip->http_code = -1;
		break;
	case IP_ERROR_HTTP_REDIRECT_LIMIT:
		snprintf(buffer, sizeof(buffer), "%s: too many HTTP redirections", arg);
		break;
	case IP_ERROR_NOT_OPTION:
		snprintf(buffer, sizeof(buffer),
				"%s: no such option", arg);
		break;
	case IP_ERROR_INTERNAL:
		snprintf(buffer, sizeof(buffer), "%s: internal error", arg);
		break;
	case IP_ERROR_SUCCESS:
	default:
		snprintf(buffer, sizeof(buffer),
				"%s: this is not an error (%d), this is a bug",
				arg, rc);
		break;
	}
	return xstrdup(buffer);
}

char **ip_get_supported_extensions(void)
{
	struct ip *ip;
	char **exts;
	int i, size;
	int count = 0;

	size = 8;
	exts = xnew(char *, size);
	ip_rdlock();
	list_for_each_entry(ip, &ip_head, node) {
		const char * const *e = ip->extensions;

		for (i = 0; e[i]; i++) {
			if (count == size - 1) {
				size *= 2;
				exts = xrenew(char *, exts, size);
			}
			exts[count++] = xstrdup(e[i]);
		}
	}
	ip_unlock();
	exts[count] = NULL;
	qsort(exts, count, sizeof(char *), strptrcmp);
	return exts;
}

void ip_dump_plugins(void)
{
	struct ip *ip;
	int i;

	printf("Input Plugins: %s\n", plugin_dir);
	ip_rdlock();
	list_for_each_entry(ip, &ip_head, node) {
		printf("  %s:\n    Priority: %d\n    File Types:", ip->name, ip->priority);
		for (i = 0; ip->extensions[i]; i++)
			printf(" %s", ip->extensions[i]);
		printf("\n    MIME Types:");
		for (i = 0; ip->mime_types[i]; i++)
			printf(" %s", ip->mime_types[i]);
		printf("\n");
	}
	ip_unlock();
}