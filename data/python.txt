import random
import string

from time import sleep
from IPython.display import clear_output

def add_lists(list1, list2):
    output = []
    for i in zip(list1, list2):
        output.append(sum(i))
    return output

def check_bounds(position, size):
    for i in position:
        if i < 0 or i >= size:
            return False
    return True

def play_board(bots, n_iter = 25, grid_size = 5, sleep_time = 0.3):

    if not type(bots) == list:
        bots = [bots]
    
    for bot in bots:
        bot.grid_size = grid_size

    for it in range(n_iter):

        grid_list = [['.'] * grid_size for ncols in range(grid_size)]
        
        for bot in bots:
            grid_list[bot.position[0]][bot.position[1]] = bot.character    

        clear_output(True)
        print('\n'.join([' '.join(lst) for lst in grid_list]))
        sleep(sleep_time)

        for bot in bots:
            bot.move()
class WanderBot():
    def __init__(self, character = 8982):
        self.character = chr(character)
        self.position = [0,0]
        self.moves = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        self.grid_size = None
    def wander(self):
        has_new_pos = False
        while not has_new_pos:
            move = random.choice(self.moves)
            new_pos = add_lists(move, self.position)
            has_new_pos = check_bounds(new_pos, self.grid_size)
        return new_pos
    def move(self):
        self.position = self.wander()
import pandas as pd
from bs4 import BeautifulSoup
import requests
from urllib.request import Request, urlopen
pd.read_csv("https://raw.githubusercontent.com/Zaanis/COGS108_Repo/main/all_player_1.csv")
data = []
for num in range (1,8):
  url = "https://draftwire.usatoday.com/2020/04/11/2020-nfl-mock-draft-7-rounds-updated-joe-burrow-tua-tagovailoa-justin-herbert/{}/".format(num)
  page = requests.get(url)
  soup = BeautifulSoup(page.content, 'html.parser')
  lists = soup.find_all('div', class_ = 'articleBody')
  content = str(list(lists)[0])
  content_list = content.split('')
  for c in content_list:
    if '|' in c:
      pick = int(c.split('.')[0])
      player = str(c.split(' | ')[1])
      position = str(c.split(' | ')[2])
      data.append([pick, player, position])
df = pd.DataFrame(data)
df.columns = ['Pick', 'Name', 'Position']
def getname(x):
  name = x.split(', ')
  return name[1] +' ' + name[0]
alpha = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
names = []
for letter in alpha:
  url = "https://www.footballdb.com/players/current.html?letter={}".format(letter)
  hdr = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.3',
        'Accept-Encoding': 'none',
        'Accept-Language': 'en-US,en;q=0.8',
        'Connection': 'keep-alive'}
  req = Request(url , headers=hdr)
  webpage = urlopen(req).read()
  soup = BeautifulSoup(webpage, "html.parser")
  lists = soup.find_all('div', class_ = 'tr')
  for l in lists:
    name = l.find('div', class_ = "td").text
    names.append(name)
final_name = [getname(x) for x in names]
for l in lists:
  print(l)
for l in lists:
  c = l.find('div', class_ = 'nfl-c-player-info__value').text
import string
import random
import nltk
def div_3(data_list):
    output = []
    for i in data_list:
        if i % 3 == 0:
            output.append(i)
    return output
def is_even(data_list):
    output_list = []
    for i in data_list:
        if i % 2 == 0:
            output_list.append(True)
        else:
            output_list.append(False)
    return output_list
def is_question(input_string):
    output = True
    if '?' in input_string:
        output = True
    else:
        output = False
    return output
def prepare_text(input_string):
    temp_string = input_string.lower()
    temp_string = remove_punctuation(temp_string)
    out_list = temp_string.split()
    return out_list
def remove_punctuation(input_string):
    out_string = ''
    for i in input_string:
        if i not in string.punctuation:
            out_string += i
    return out_string
def end_chat(input_list):
    if 'quit' in input_list:
        output = True
    else:
        output = False
    return output
def selector(input_list, check_list, return_list):
    output = None
    for i in input_list:
        if i in check_list:
            output = random.choice(return_list)
            break
    return output
def is_in_list(list_one, list_two):
    """Check if any element of list_one is in list_two."""
    
    for element in list_one:
        if element in list_two:
            return True
    return False

def find_in_list(list_one, list_two):
    """Find and return an element from list_one that is in list_two, or None otherwise."""
    
    for element in list_one:
        if element in list_two:
            return element
    return None
def respond_echo(input_string, number_of_echoes, spacer):
    echo_output = ''
    if input_string != None:
        for i in range(number_of_echoes):
            echo_output += input_string + spacer
    elif input_string == None:
        echo_output = None
    return echo_output
def have_a_chat():
    
    chat = True
    while chat:

        msg = input('INPUT :\t')
        out_msg = None

        question = is_question(msg)

        msg = prepare_text(msg)

        if end_chat(msg):
            out_msg = 'Bye!'
            chat = False

        if not out_msg:

            outs = []

            outs.append(selector(msg, GREETINGS_IN, GREETINGS_OUT))

            outs.append(selector(msg, COMP_IN, COMP_OUT))

            if is_in_list(msg, PEOPLE_IN):
                name = find_in_list(msg, PEOPLE_IN)
                outs.append(list_to_string([PEOPLE_NAMES[name], name.capitalize(),
                                            selector(msg, PEOPLE_IN, PEOPLE_OUT)], ' '))

            outs.append(respond_echo(selector(msg, JOKES_IN, JOKES_OUT), 3, ''))

            if is_in_list(msg, NONO_IN):
                outs.append(list_to_string([selector(msg, NONO_IN, NONO_OUT), find_in_list(msg, NONO_IN)], ' '))

            options = list(filter(None, outs))
            if options:
                out_msg = random.choice(options)

        if not out_msg and question:
            out_msg = QUESTION

        if not out_msg:
            out_msg = random.choice(UNKNOWN)

        print('OUTPUT:', out_msg)
from deck import Deck
from hand import DealerHand, PlayerHand
from card import Card
from numpy.random import randint, seed
seed(20)

class Blackjack:
    num_games = 0
    def __init__(self, wallet):

        assert type(wallet) == int or type(wallet) == float
        self.deck = Deck()
        self.wallet = wallet
        self.game_number = 1
        self.log = ''
        self.bet_amount = 5
        self.player = PlayerHand()
        self.dealer = DealerHand()
        Blackjack.num_games += 1
    
    def play_round(self, num_rounds, stand_threshold):

        assert type(num_rounds) == int and num_rounds > 0
        assert type(stand_threshold) == int and stand_threshold > 0
        self.bet_amount = 5
        while num_rounds > 0:
            if len(self.deck.cards) < 4:
                self.log += 'Not enough cards for a game.'
                self.bet_amount = 5
                return
            if self.wallet < self.bet_amount:
                self.log += 'Wallet amount ${} is less than bet amount ${}.'.format(self.wallet, self.bet_amount)
                self.bet_amount = 5
                return
            self.log += 'Round {} of Blackjack!\n'.format(self.game_number)
            self.log += 'wallet: ' + str(self.wallet) + '\n'
            self.log += 'bet: ' + str(self.bet_amount) + '\n'
            x = randint(0,5)
            y = randint(0,5)
            self.deck.shuffle(modified_overhand = y, mongean = x)
            self.deck.deal_hand(self.player)
            self.deck.deal_hand(self.dealer)
            self.deck.deal_hand(self.player)
            self.deck.deal_hand(self.dealer)
            self.log += 'Player Cards: {}\n'.format(self.player.__repr__())
            self.log += 'Dealer Cards: {}\n'.format(self.dealer.__repr__())
            self.hit_or_stand(self.player, stand_threshold)
            self.dealer.reveal_hand()
            self.log += 'Dealer Cards Revealed: {}\n'.format(self.dealer.__repr__())
            self.hit_or_stand(self.dealer, 17)
            player_score = Blackjack.calculate_score(self.player)
            dealer_score = Blackjack.calculate_score(self.dealer)
            result = self.determine_winner(player_score, dealer_score)
            if result == 1:
                self.wallet += self.bet_amount
                self.bet_amount += 5
            elif result == -1:
                self.wallet -= self.bet_amount
                self.bet_amount -= 5
            if self.bet_amount < 5:
                self.bet_amount = 5
            self.add_to_file(self.player, self.dealer, result)
            num_rounds -= 1
            self.game_number += 1
            self.player = PlayerHand()
            self.dealer = DealerHand()         
    def calculate_score(hand):

        assert type(hand) == PlayerHand or type(hand) == DealerHand
        hand_ranks = [a.rank for a in hand.cards]
        withoutA = list(filter(lambda x: True if x!= 'A' else False, hand_ranks))
        As = list(filter(lambda x: True if x == 'A' else False, hand_ranks))
        withoutA_score = sum(list(map(lambda x: x if type(x) == int else 10, withoutA))) 
        withoutA_score += sum(list(map(lambda x: 0 if len(list(x)) == 0 else 10 + len(x) if withoutA_score + 10 + len(x) <= 21 else len(x), [As])))
        return withoutA_score

    def determine_winner(self, player_score, dealer_score):

        if dealer_score == player_score or (dealer_score > 21 and player_score > 21):
            self.log += 'Player and Dealer tie.\n'
            return 0
        elif (player_score <= 21 and player_score > dealer_score) or dealer_score > 21:
            self.log += 'Player won with a score of {}. Dealer lost with a score of {}.\n'.format(player_score, dealer_score)
            return 1
        elif (dealer_score <= 21 and dealer_score > player_score) or player_score > 21:
            self.log += 'Player lost with a score of {}. Dealer won with a score of {}.\n'.format(player_score, dealer_score)
            return -1
    def hit_or_stand(self, hand, stand_threshold):

        while Blackjack.calculate_score(hand) < stand_threshold and len(self.deck.get_cards()) > 0:
            to_add = self.deck.cards[0]
            self.deck.deal_hand(hand)
            if type(hand) == PlayerHand:
                self.log += to_add.__repr__() + ' was pulled by a Player\n'
            else:
                self.log += to_add.__repr__() + ' was pulled by a Dealer\n'

    def get_log(self):
        return self.log
    
    def reset_log(self):
        self.log = ''
        
    def add_to_file(self, player_hand, dealer_hand, result):

        filename = './game_summaries/game_summary{}.txt'.format(self.num_games)
        with open(filename, 'a', encoding = 'utf-8') as f:
            f.write('ROUND {}:\n'.format(self.game_number))
            f.write('Player Hand:\n')
            f.write(player_hand.__str__() + '\n')
            f.write('Dealer Hand:\n')
            f.write(dealer_hand.__str__() + '\n')
            if result == 1:
                f.write('Winner of ROUND {}: Player\n\n'.format(self.game_number))
            elif result == -1:
                f.write('Winner of ROUND {}: Dealer\n\n'.format(self.game_number))
            else:
                f.write('Winner of ROUND {}: Tied\n\n'.format(self.game_number))
class Card:
    def __init__(self, rank, suit, visible=True):

        assert rank in [2, 3, 4, 5, 6, 7, 8, 9, 10, 'A', 'J', 'K', 'Q']
        assert suit in ['hearts', 'spades', 'clubs', 'diamonds']
        assert type(visible) == bool
        self.rank = rank
        self.suit = suit
        self.visible = visible
        
    def suit_rankings(self):
        if self.suit == 'clubs':
            return 4
        elif self.suit == 'diamonds':
            return 3
        elif self.suit == 'hearts':
            return 2
        elif self.suit == 'spades':
            return 1
    def rank_rankings(self):
        if type(self.rank) == int:
            return self.rank
        else:
            if self.rank == 'A':
                return 14
            elif self.rank == 'K':
                return 13
            elif self.rank == 'Q':
                return 12
            elif self.rank == 'J':
                return 11
    
    def __lt__(self, other_card):
        if self.rank_rankings() < other_card.rank_rankings():
            return True
        elif self.rank_rankings() > other_card.rank_rankings():
            return False
        else:
            if self.suit_rankings() < other_card.suit_rankings():
                return True
            else:
                return False

    def __str__(self):
        
        if self.suit == 'hearts':
            suit =
        elif self.suit == 'diamonds':
            suit = 
        elif self.suit == 'spades':
            suit=  
        elif self.suit == 'clubs':
            suit = 
        if not self.visible:
            return '____\n|?  |\n| ? |\n|__?|'
        else:
            return '____\n|{}  |\n| {} |\n|__{}|'.format(str(self.rank), \
                suit, str(self.rank))

    def __repr__(self):
        
        if not self.visible:
            return '(?, ?)'
        else:
            return '({}, {})'.format(str(self.rank), self.suit)

    def get_rank(self):
        return self.rank
    
    def get_suit(self):
        return self.suit

    def set_visible(self, visible):
        assert type(visible) == bool
        self.visible = visible
from card import Card
from hand import PlayerHand, DealerHand
from shuffle import Shuffle

class Deck:
    def __init__(self):
        
        self.cards = [Card(x,y) for x in [2,3,4,5,6,7,8,9,10,'J','Q','K','A'] \
            for y in ['spades', 'hearts', 'diamonds', 'clubs']]
    def shuffle(self, **shuffle_and_count):
        """Shuffles the deck using a variety of different shuffles.

        Parameters:
            shuffle_and_count: keyword arguments containing the
            shuffle type and the number of times the shuffled
            should be called.
        """
        assert all(isinstance(x, int) for x in shuffle_and_count.values())
        assert all([True if x == 'mongean' or x == 'modified_overhand' \
            else False for x in shuffle_and_count.keys()])
        if 'modified_overhand' in shuffle_and_count:
            self.cards = Shuffle.modified_overhand(self.cards, \
                shuffle_and_count['modified_overhand'])
        if 'mongean' in shuffle_and_count:
            for i in range(shuffle_and_count['mongean']):
                self.cards = Shuffle.mongean(self.cards)
    
    def deal_hand(self, hand):

        assert type(hand) == PlayerHand or type(hand) == DealerHand
        hand.add_card(self.cards[0])
        self.cards.pop(0)

    def get_cards(self):
        return self.cards
from card import Card

class PlayerHand():
    def __init__(self):
        self.cards = []
        
    def add_card(self, *cards):

        for card in cards:
            assert type(card) == Card
            self.cards.append(card)
        self.sort_hand()

    def get_cards(self):
        return self.cards            

    def __str__(self):

        return_str = ''
        for card in self.cards:
            return_str += card.__str__() + '\n'
        return return_str[:-1]
    
    def __repr__(self):

        return_str = ''
        for card in self.cards:
            return_str += card.__repr__() + ' '
        return return_str[:-1]

    def sort_hand(self):

        n = len(self.cards)
        for i in range(n):
            for j in range(0, n-i-1):
                if self.cards[j] > self.cards[j + 1]:
                    self.cards[j + 1], self.cards[j] = \
                    self.cards[j], self.cards[j + 1]
        
    
class DealerHand(PlayerHand):
    
    def __init__(self):

        super().__init__()
        self.hand_visible = False

    def add_card(self, *cards):

        assert all(isinstance(card, Card) for card in cards)
        if self.hand_visible == False:
            for card in cards:
                self.cards.append(card)
            for i in range(len(self.cards) - 1):
                self.cards[i + 1].set_visible(False)
        else:
            super().add_card(*cards)

    
    def reveal_hand(self):

        self.hand_visible = True
        for card in self.cards:
            card.set_visible(True)
        self.sort_hand()
class Shuffle:
    def modified_overhand(cards, num):

        if num == 0 :
            return cards
        else:
            if len(cards) % 2 == 0 and num % 2 == 1:
                top_half_take = num // 2 + 1
                bottom_half_take = num - top_half_take
                top_half_remain = len(cards) // 2 - top_half_take
                top_half = cards[0:int(len(cards) / 2)][::-1]
                bottom_half = cards[int(len(cards) / 2):]
                cards = top_half[0:top_half_take][::-1] + \
                    bottom_half[0:bottom_half_take] + \
                    top_half[::-1][0:top_half_remain] + \
                    bottom_half[bottom_half_take:]
            elif len(cards) % 2 == 1 and num % 2 == 0:
                top_half_take = num // 2 + 1
                bottom_half_take = num - top_half_take
                top_half = cards[0:int(len(cards) / 2) + 1][::-1]
                top_half_remain = len(top_half) - top_half_take
                bottom_half = cards[int(len(cards) / 2) + 1:]
                cards = top_half[0:top_half_take][::-1] + \
                    bottom_half[0:bottom_half_take] + \
                    top_half[::-1][0:top_half_remain] + \
                    bottom_half[bottom_half_take:]
            else:
                top_half = cards[0:int(len(cards) / 2 + 0.5)][::-1]
                bottom_half = cards[int(len(cards) / 2 + 0.5):]
                top_half_take = int(num / 2 + 0.5)
                top_half_remain = len(top_half) - top_half_take
                bottom_half_take = num - top_half_take
                cards = top_half[0:top_half_take][::-1] + \
                    bottom_half[0:bottom_half_take] + \
                    top_half[::-1][0:top_half_remain] + \
                    bottom_half[bottom_half_take:]
            return Shuffle.modified_overhand(cards, num - 1)

    
    def mongean(cards):

        assert type(cards) == list
        if len(cards) == 0:
            return []
        else:
            return_list = Shuffle.mongean(cards[:-1])
            if len(return_list) % 2 == 0:
                return return_list + [cards[-1]]
            else:
                return [cards[-1]] + return_list
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
train_scaled = scaler.fit_transform(train)
train_scaled = pd.DataFrame(train_scaled, columns=train.columns)
test_scaled = scaler.fit_transform(test)
test_scaled = pd.DataFrame(test_scaled, columns=test.columns)
train_log = np.log(train+ 1)
test_log = np.log(test+1)

train_disc = (train > 0).astype(int)
test_disc = (test > 0).astype(int)
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 8))

train.plot(ax=axes[0, 0], kind='hist', bins=50, title='Original Data')

train_scaled.plot(ax=axes[0, 1], kind='hist', bins=50, title='Standardized Data')

train_log.plot(ax=axes[1, 0], kind='hist', bins=50, title='Log-Transformed Data')

train_disc.plot(ax=axes[1, 1], kind='hist', bins=2, title='Discretized Data')

fig.suptitle('Visualization of Different Versions of the Data')

plt.show()
import seaborn as sns
corr_matrix = train.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Train Data')
plt.show()
corr_matrix = train_scaled.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Train Scaled Data')
plt.show()
corr_matrix = train_log.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Train Log Data')
plt.show()
corr_matrix = train_disc.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Train Discretized Data')
plt.show()
corr_matrix = test_disc.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam- Test Discretized Data')
plt.show()
corr_matrix = test_log.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Test Log Data')
plt.show()
corr_matrix = test.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Test Data')
plt.show()
corr_matrix = test_scaled.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Test Scaled Data')
plt.show()
from sklearn.linear_model import LogisticRegression
X_train_stan = train_scaled.iloc[:, :-1]
y_train = train.iloc[:, -1]
X_test_stan = test_scaled.iloc[:, :-1]
y_test = test.iloc[:, -1]

lr = LogisticRegression()
lr.fit(X_train_stan, y_train)

stanlrtrain_error = 1 - lr.score(X_train_stan, y_train)
stanlrtest_error = 1 - lr.score(X_test_stan, y_test)
print("Classification error on standardized training set:", stanlrtrain_error)
print("Classification error on standardized test set:", stanlrtest_error)
from scipy.stats import norm

p_values = lr.coef_[0]
p_values = [2 * (1 - norm.cdf(abs(x))) for x in p_values]

significant_features = [i for i in range(len(p_values)) if p_values[i] < 0.05]
print("Significant features:", significant_features)
X_train_log = train_log.iloc[:, :-1]
y_train = train.iloc[:, -1]
X_test_log = test_log.iloc[:, :-1]
y_test = test.iloc[:, -1]

lr = LogisticRegression()
lr.fit(X_train_log, y_train)

loglrtrain_error = 1 - lr.score(X_train_log, y_train)
loglrtest_error = 1 - lr.score(X_test_log, y_test)
print("Classification error on standardized training set:", loglrtrain_error)
print("Classification error on standardized test set:", loglrtest_error)
p_values = lr.coef_[0]
p_values = [2 * (1 - norm.cdf(abs(x))) for x in p_values]

significant_features = [i for i in range(len(p_values)) if p_values[i] < 0.05]
print("Significant features:", significant_features)
X_train_disc = train_disc.iloc[:, :-1]
y_train = train.iloc[:, -1]
X_test_disc = test_disc.iloc[:, :-1]
y_test = test.iloc[:, -1]

lr = LogisticRegression()
lr.fit(X_train_disc, y_train)

disclrtrain_error = 1 - lr.score(X_train_disc, y_train)
disclrtest_error = 1 - lr.score(X_test_disc, y_test)
print("Classification error on standardized training set:", disclrtrain_error)
print("Classification error on standardized test set:", disclrtest_error)
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis, QuadraticDiscriminantAnalysis
from sklearn.metrics import accuracy_score

lda = LinearDiscriminantAnalysis()
lda.fit(X_train_stan, y_train)

y_pred_train_lda = lda.predict(X_train_stan)
y_pred_test_lda = lda.predict(X_test_stan)
stantrain_error_lda = 1 - accuracy_score(y_train, y_pred_train_lda)
stantest_error_lda = 1 - accuracy_score(y_test, y_pred_test_lda)

qda = QuadraticDiscriminantAnalysis()
qda.fit(X_train_stan, y_train)

y_pred_train_qda = qda.predict(X_train_stan)
y_pred_test_qda = qda.predict(X_test_stan)
stantrain_error_qda = 1 - accuracy_score(y_train, y_pred_train_qda)
stantest_error_qda = 1 - accuracy_score(y_test, y_pred_test_qda)

print("Linear Discriminant Analysis:")
print(f"Training error: {stantrain_error_lda:.4f}")
print(f"Test error: {stantest_error_lda:.4f}\n")
print("Quadratic Discriminant Analysis:")
print(f"Training error: {stantrain_error_qda:.4f}")
print(f"Test error: {stantest_error_qda:.4f}")
from sklearn.ensemble import AdaBoostClassifier
train = pd.read_csv('https://mathweb.ucsd.edu/~wez243/spam-train.txt', sep = ',', header=None)
test = pd.read_csv('https://mathweb.ucsd.edu/~wez243/spam-test.txt', sep = ',', header = None)
train_log = np.log(train+ 1)
test_log = np.log(test+1)
X_train_log = train_log.iloc[:, :-1]
y_train = train.iloc[:, -1]
X_test_log = test_log.iloc[:, :-1]
y_test = test.iloc[:, -1]

ensemble_clf = AdaBoostClassifier(
    estimator=RandomForestClassifier(),
)
ensemble_clf.fit(X_train_log, y_train)

ypredtrain = ensemble_clf.predict(X_train_log)
ypredtest = ensemble_clf.predict(X_test_log)
train_error = 1 - accuracy_score(y_train, ypredtrain)
test_error = 1 - accuracy_score(y_test, ypredtest)

print("AdaBoost Classifier for RF:")
print(f"Training error: {train_error:.4f}")
print(f"Test error: {test_error:.4f}")
def name_scramble(fname, lname):
    fname_reverse = fname[::-1]
    scrambled_name = ""
    x = 0
    while x < len(fname_reverse):
        scrambled_name = scrambled_name + fname_reverse[x]
        x = x + 2
    y = 0
    while y < len(lname):
        scrambled_name = scrambled_name + lname[y]
        y = y + 3
    return scrambled_name
def close_to_25(age1, age2):
    
    if age1 <= 25 and age2 <= 25:
        return max(age1, age2)
    elif age1 > 25 and age2 < 25:
        return age2
    elif age1 < 25 and age2 > 25:
        return age1
    else:
        return 'we are good to go!'    

def main_driver(name1, name2, name3):
    
    return_name = ""
    list_of_name = [name1, name2, name3]
    for names in list_of_name:
        if len(names) >= len(return_name):
            return_name = names
        else:
            return_name = return_name
    return return_name


def helper_distance(lst, x2, y2):
   
    return ((x2 - lst[0]) ** (2) + (y2 - lst[1]) ** (2)) ** (1/2)

def all_distances(coordinates, x_coord, y_coord, threshold):
   
    drivable = []
    for places in coordinates:
        distance = helper_distance(places, x_coord, y_coord)
        if distance <= threshold:
            drivable.append(places)
        else:
            drivable = drivable
    return drivable


def places_names(coordinates, x_coord, y_coord, threshold, names):
   
    available_places = all_distances(coordinates, x_coord, y_coord, threshold) 
    name_of_places = []
    for coords in available_places:
        name_of_places.append(names[coordinates.index(coords)])
    return name_of_places


def message(i_name, dow, time, c_name):
    
    invitation = "Dear " + i_name + ",\n" + "Please join our meeting on " \
    + dow + " at " + time + ".\n\nTeam captain: " + c_name
    return invitation

def seat_number(lst):
    
    seat_number = []
    for names in lst:
        if len(names) in seat_number:
            seat_number.append("taken")
        else:
            seat_number.append(len(names))
    return seat_number


def suv_vs_minivan(names):
    
    suv_counter = names.count('SUV')
    minivan_counter = names.count('Minivan')
    if suv_counter > minivan_counter:
        return True
    else:
        return False
    

def age_average(lst):
    
    if len(lst) == 0:
        return '0.0'
    else:
        total_age = 0
        for age in lst:
            total_age = total_age + int(age)
        average = round(total_age/len(lst), 1)
    return str(average)


def split_teams(lst, captain):
    
    first_list = [captain]
    second_list = []
    i = 0
    while i < len(lst):
        first_list.append(lst[i])
        i = i + 2
    j = 1
    while j < len(lst):
        second_list.append(lst[j])
        j = j + 2
    second_list.append(captain)
    list_as_tuple = first_list, second_list
    return list_as_tuple
def combine(states, nicknames):
    
    return_list = []
    for i in range(len(nicknames)):
        if i < len(states):
            return_list.append((states[i], nicknames[i]))
        elif i >= len(states):
            return_list.append(('NO STATE PROVIDED', nicknames[i]))
    return return_list

def dict_of_states(tuples):
    
    return_dict = {}
    for states in tuples:
        state_abbrv = states[0]
        if state_abbrv not in return_dict:
            return_dict[state_abbrv] = [states[1]]
        elif state_abbrv in return_dict:
            nickname_list = return_dict.get(state_abbrv)
            nickname_list.append(states[1])
            return_dict[state_abbrv] = nickname_list
    return return_dict

def gambling_in_vegas(profit_history):
    
    return_dict = {}
    if len(profit_history) == 0:
        return {'1': 0, '2': 0, '3': 0}
    for lists in profit_history:
        if len(lists) == 0 and len(return_dict) == 0:
            return_dict['1'] = 0
            return_dict['2'] = 0
            return_dict['3'] = 0
        elif len(lists) == 0 and len(return_dict) != 0:
            return_dict = return_dict
        else:
            for i in range(len(lists)):
                slot_machine = str(i + 1)
                if slot_machine not in return_dict:
                    return_dict[slot_machine] = lists[i]
                elif slot_machine in return_dict:
                    profit = return_dict.get(slot_machine) + lists[i]
                    return_dict[slot_machine] = profit
    return return_dict

def luck_mechanism(records):
    
    return_dict = records
    history = list(records.values())
    third_in_list = 2
    if history[0] > 0 or history[1] > 0 or history[third_in_list] > 0:
        luck = -2
    else:
        luck = 0.001 * abs(history[0]) + 0.002 * abs(history[1]) + \
        min(0.005 * abs(500 - abs(history[2])), 0.003 * \
        abs(history[third_in_list])) - 2
    if luck > 0:
        return_dict['luck'] = 'You are Lucky'
    elif luck == 0:
        return_dict['luck'] = 'Fair game'
    elif luck < 0:
        return_dict['luck'] = 'Not this time'
    return return_dict

def smaller_collection(collections):
    
    all_list = []
    for keys in collections:
        all_items = collections.get(keys)
        for items in all_items:
            if items in all_list:
                all_list = all_list
            else:
                all_list.append(items)
    return all_list

def count_lines_1(filepath):
    
    with open(filepath) as f:
        count = 0
        for line in f:
            count = count + 1
    return count    


def count_lines_2(filepath):
    
    with open(filepath) as f:
        read_data = f.read()
        count = len(read_data.split('\n'))
    return count

def count_lines_3(filepath):
    
    with open(filepath) as f:
        lines = f.readlines()
        count = len(lines)
    return count

def items_only(filepath):
    
    first = []
    with open(filepath) as f:
        lines = f.readlines()
        for i in range(len(lines)):
            lines[i] = lines[i].strip('\n')
            if len(lines[i]) == 0:
                first = first
            else:
                item_index = 2
                first.append((lines[i].split(','))[item_index])
    return first

def case_letters(filepath):
    
    with open(filepath, 'w') as f:
        count_upper = 0
        count_lower = 0
        for i in filepath:
            if i.isupper():
                count_upper += 1
            if i.islower():
                count_lower += 1
        f.write(str(count_upper) + '\n')
        f.write(str(count_lower))
    return None

def map_age(filepath):
    
    with open(filepath) as f:
        lines = f.readlines()
        first_age_limit = 14
        second_age_limit = 15
        third_age_limit = 19
        for i in range(len(lines)):
            lines[i] = int(lines[i].strip('\n'))
        with open('files/mappings.txt', 'a') as m:
            for age in lines: 
                if age < 0:
                    m.write('not a valid age' + '\n')
                elif age <= first_age_limit:
                    m.write('kid' + '\n')
                elif age <= third_age_limit:
                    m.write('teenager' + '\n')
                else: 
                    m.write('adult' + '\n')
    return sum(lines)

def correctness():

    assert_needed = [2, 2, 4]
    return assert_needed

def operate_nums(lst):
    
    triple = 3
    double = 2
    assert type(lst) == list
    assert all([isinstance(number, int) for number in lst])
    return [value * triple if value % double == 0 else \
    value * double for value in lst]


def string_lengths(text, nums):
    
    assert all([isinstance(letter, str) for letter in text])
    assert all([isinstance(number, int) for number in nums])
    assert type(text) == list and type(nums) == list
    assert len(text) == len(nums)
    assert all(len(letter) > 0 for letter in text)
    assert all(number >= 0 for number in nums)
    return [True if len(text[i]) > nums[i] else False \
    for i in range(len(text))]


def process_dict(input_dict):

    assert type(input_dict) == dict
    assert all([isinstance(keys, tuple) for keys in list(input_dict.keys())])
    assert all([isinstance(values, str) for keys in list(input_dict.keys()) \
    for values in input_dict.get(keys)])
    assert all([isinstance(values, list) for values in \
    list(input_dict.values())])
    return [len(list(input_dict.keys())[i]) + sum([len(words) for words in \
    list(input_dict.values())[i]]) for i in range(len(input_dict))]


def union(str1, str2):
    
    assert type(str1) == str and type(str2) == str
    assert str1.isalnum() and str2.isalnum()
    return "".join([str1[i] if str1[i] != str2[i] else '' \
    for i in range(min(len(str1), len(str2)))] + \
    [str1[i] for i in range(min(len(str1), len(str2)), len(str1))] + \
    [str2[i] if str1[i] != str2[i] else '' \
    for i in range(min(len(str1), len(str2)))] + \
    [str2[i] for i in range(min(len(str1), len(str2)), len(str2))])


def decode(to_decode):
    
    assert all(isinstance(word, str) for word in to_decode) and \
    type(to_decode) == list
    double = 2
    return ["".join([to_decode[list_position][string_position].upper() \
    if to_decode[list_position][string_position] in \
    ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'] \
    else "" if to_decode[list_position][string_position].isdigit() \
    else to_decode[list_position][string_position].lower() \
    for string_position in range(len(to_decode[list_position]))] + \
    [str(int(to_decode[list_position][string_position]) * double) \
    if to_decode[list_position][string_position].isdigit() \
    else "" for string_position in range(len(to_decode[list_position]))]) \
     for list_position in range(len(to_decode))]


def rotate_matrix(matrix):
    
    assert all(isinstance(value[i], int) \
    for value in matrix for i in range(len(matrix[0])))
    return [[matrix[j][i] for j in range(len(matrix) - 1, -1, -1)] \
    for i in range(len(matrix[0]))]

def cheapest_gas(gas_stations, mileage):
    
    lst1 = [(gas_stations.get(stations)[i][1], stations) \
    for stations in gas_stations \
    for i in range(len(gas_stations.get(stations))) \
    if gas_stations.get(stations)[i][0] <= mileage]
    return min(lst1)[1]


def cheapest_average_gas(gas_stations, mileage):
    
    return min([(sum([gas_stations.get(stations)[i][1] \
    for i in range(len(gas_stations.get(stations))) \
    if gas_stations.get(stations)[i][0] <=mileage])/len(\
    [gas_stations.get(stations)[i][1] \
    for i in range(len(gas_stations.get(stations))) \
    if gas_stations.get(stations)[i][0] <=mileage]), stations) \
    for stations in gas_stations if len([gas_stations.get(stations)[i][1] \
    for i in range(len(gas_stations.get(stations))) \
    if gas_stations.get(stations)[i][0] <=mileage]) != 0])[1]


def session_money(lst, operations):
    
    commands = {
        'add': lambda lst, amount: [x + amount for x in lst], 
        'lose': lambda lst, amount: [x - amount for x in lst], 
        'combine': lambda lst, k: [sum([lst[i] for i in range(j, j + k)]) \
        for j in range(len(lst)) if j < len(lst) - k + 1], 
        'first': lambda lst, k: [int(str(lst[i])[0:k]) \
        for i in range(len(lst))], 
        'reduce_last': lambda lst, k: [[lst[i] if i < len(lst) - k \
        else sum([lst[i] for i in range(i, len(lst))]) \
        for i in range(len(lst) - k + 1)] if k !=0 else lst][0], 
        'last': lambda lst, k: [int(str(lst[i])) if k >= len(str(lst[i])) \
        else int((str(lst[i])[len(str(lst[i])) - k::])) \
        for i in range(len(lst))]}
    return_list = lst
    for i in range(len(operations)):
        return_list = commands[operations[i][0]](return_list, operations[i][1])
    return return_list


def champion_filter(names, categories):
    
    assert all(isinstance(name, str) for name in names)
    assert all(isinstance(category, str) for category in categories)
    assert len(names) == len(categories)
    assert type(names) == list and type(categories) == list
    return list(filter(lambda x: x != 'N/A', list(map(lambda name, category: \
    (name, category) if category in ['Fighter', 'Marksman', 'Mage'] \
    else 'N/A', names, categories))))


def select_items(combinations):
    
    base = 50
    combinations = list(map(lambda x: x if len(x) <= 6 else {}, combinations))
    sorting = lambda items: (base + sum(list(map(lambda AP: items.get(AP), \
    list(filter(lambda name: name if 'AP' in name and 'shoe' \
    not in name else False, items))))), items)
    reversed = max(list(map(sorting, combinations)))
    return (reversed[1], reversed[0])


def calculate_experience(scores):
    
    assert type(scores) == list
    assert all(isinstance(x, list) for x in scores)
    assert all(isinstance(j, int) for x in scores for j in x)
    assert all(len(x) == 4 for x in scores)
    k1, k2, k3 = 100, 250, 5
    d1 = -25
    a1, a2, a3 = 30, 50, 40
    g1 = 0.1
    k, d, a, g = 0, 1, 2, 3
    kill = lambda kills: kills * k1 + (kills // k3) * k2
    death = lambda deaths: deaths * d1
    assist = lambda assists, kills: a1 * assists if kills > assists \
    else a2 * assists if kills < assists else a3 * assists    
    gold = lambda golds: round(golds * g1)
    orig_xp = list(map(lambda z: kill(z[k]) + death(z[d]) + \
    assist(z[a], z[k]) + gold(z[g]), scores))
    return list(map(lambda w: w if w >= 0 else 0, orig_xp))

def calculate_level(scores, level):
    
    xp = sum(calculate_experience(scores))
    base = 2000
    level_up = 200
    threshold = base + level_up * (level - 1)
    return_level = level
    while xp > threshold:
        return_level += 1
        threshold += level_up
        xp -= threshold

def round_up(x, y):
   
    if x % y == 0:
        return x // y
    else:
        return (x // y) + 1


def number_of_trainers_1(lst, level = 20):
   
    size = 5
    return round_up(len([x for x in lst if x <= level]), size)


def number_of_trainers_2(*args):
   
    level = 20
    size = 5
    return round_up(len([x for x in args if x <= level]), size)


def number_of_trainers_3(*args, level = 20):
    
    size = 5
    return round_up(len([x for x in args if x <= level]), size)


def guild_trip(level_limit, **kwargs):
   
    return {k: number_of_trainers_1(i, level_limit) for \
    (k,i) in kwargs.items()}


def swap_values(*args, **kwargs):
    
    assert len(args) == len(kwargs)
    return [('positional_' + str(x[0]), x[1]) for x in \
    list(enumerate(kwargs.values()))] + [('keyword_' + \
    str(list(enumerate(args))[i][0]) + "_" + \
    list(kwargs.keys())[i], args[i]) for i in \
    range(len(list(enumerate(args))))]


def pokemon_comp(**kwargs):
    
    aggron_attack = 10
    alcremie_attack = 3
    bagon_attack = 5
    bayleef_attack = 4
    happiny_attack = 2
    pikachu_attack = 4
    quagsire_attack = 7
    zapdos_attack = 11
    attack_values = {'Aggron': aggron_attack, 'Alcremie': alcremie_attack,\
        'Bagon': bagon_attack, 'Bayleef': bayleef_attack, 'Happiny': \
        happiny_attack, 'Pikachu': pikachu_attack, 'Quagsire': \
        quagsire_attack, 'Zapdos': zapdos_attack}
    pokemon_and_attack = list(kwargs.items())
    squared = 2
    energy = [pokemon_and_attack[i][1] * attack_values.get(pokemon_and_attack \
    [i][0]) + len(pokemon_and_attack[i][0]) ** squared \
    for i in range(len(pokemon_and_attack))]
    def inner(x):
        """
        if sum of energy > x, print the highest energy and return the
        pokemon's name
        if sum of energy < x, print the lowest energy and return the pokemon's 
        name
        if sum of energy = x, return average of energy list
        """
        if sum(energy) > x:
            print(max(energy))
            return list(kwargs.keys())[energy.index(max(energy))]
        elif sum(energy) < x:
            print(min(energy))
            return list(kwargs.keys())[energy.index(min(energy))]
        else:
            return int(sum(energy) / len(energy))
    return inner

def next_move(file_names, row, col):
    
    with open(file_names) as f:
        second_person = 2
        lines = []
        for i in f:
            lines.append(i.strip())
        newline = []
        for i in lines:
            newline.append(i.split(','))
        remaining = []
        for i in newline:
            for l in i:
                if l not in remaining:
                    remaining.append(l)
        original_length = len(remaining)
        to_remove = [newline[row - 1][col - 1]]
        newline = newline[row - 1:] + newline[0:row - 1]
        no_remove = []
        while len(to_remove) > 0:
            for i in newline:
                if to_remove[0] in i and to_remove[0] not in no_remove:
                    if i.index(to_remove[0]) == 1:
                        to_remove.append(i[second_person])
                    elif i.index(to_remove[0]) == 0:
                        no_remove.append(i[1])
                        no_remove.append(i[second_person])
                    elif i.index(to_remove[0]) == second_person:
                        no_remove.append(i[0])
                        no_remove.append(i[1])
            remaining.remove(to_remove[0])
            to_remove.remove(to_remove[0])
            newline.remove(i)
        new_length = len(remaining)
    def inner(stats):

        if stats == True:
            convert_to_percent = 100
            return int(convert_to_percent * new_length / original_length)
        else:
            odd_checker = 2
            if new_length % odd_checker == 1:
                return 'odd'
            else:
                return 'even'
    return inner
     
def message_enc(filepath):
    
    with open(filepath) as f:
        lines = []
        for i in f:
            lines.append(i.strip())
        new_dict = {}
        for line in lines:
            for letter in line:
                if letter != ' ':
                    if letter not in new_dict:
                        new_dict[letter] = 1
                    else:
                        new_dict[letter] += 1 
        sorted_dict = dict(sorted(new_dict.items(), key = lambda item:\
        item[1]))
        reverse_sorted = {}
        for k, v in sorted_dict.items():
            if v not in reverse_sorted:
                reverse_sorted[v] = [k]
            else:
                reverse_sorted[v] = reverse_sorted[v] + [k]
    def inner(i, outfile):

        replace_list = []
        for letters in reverse_sorted.values():
            replace_list = replace_list + sorted(letters)
        half = 0.5
        assert i <= half * len(replace_list)
        while i > 0:
            to_replace1 = replace_list[i - 1]
            to_replace2 = replace_list[len(replace_list) - i]
            for line in lines:
                line_copy = list(line)
                to_replace1_index = []
                to_replace2_index = []
                for j in range(len(line)):
                    if line[j] == to_replace1:
                        to_replace1_index.append(j)
                    elif line[j] == to_replace2:
                        to_replace2_index.append(j)
                for letter_index in to_replace1_index:
                    line_copy[letter_index] = to_replace2
                for letter_index in to_replace2_index:
                    line_copy[letter_index] = to_replace1
                return_str = ""
                for letters in line_copy:
                    return_str = return_str + letters
                lines[lines.index(line)] = return_str
            i -= 1
        for j in range(len(lines)):
            if j != len(lines) - 1 and "\n" not in lines[j]:
                lines[j] = lines[j] + "\n"
            else:
                lines[j] = lines[j]
        with open(outfile, 'w') as f:
            for line in lines:
                f.write(line)
    return inner


def complexity_mc():

    return [3, 4, 6, 5, 3, 6, 2, 6, 3, 3]


def candy_num(bag, fav):
    
    if len(bag) == 0:
        return 0
    else:
        if fav.count(bag[0]) > 0:
            return 1 + candy_num(bag[1:], fav)
        else:
            return 0 + candy_num(bag[1:], fav)
    

def count_left_path(left, right):
   
    if len(left) == 0 or len(right) == 0:
        return 0
    else:
        if left[0] > right[0]:
            return 1 + count_left_path(left[1:], right[1:])
        else:
            return 0 + count_left_path(left[1:], right[1:])


def generate_passcode(string):
    
    if string.count(' ') == 0:
        return str(len(string))
    else:
        position = string.find(' ')
        return str(len(string[0:position])) + \
        generate_passcode(string[position + 1:])
    


def pumpkin_to_friend(bag, num):
    
    if len(bag) < num:
        return []
    else:
        return [sum(bag[0:num])] + pumpkin_to_friend(bag[num:], num)


def expand_formula(compressed_form):
   
    if compressed_form.count('}') == 1:
        index = compressed_form.find('}')
        string = compressed_form[0:index]
        print_list = string.split('{')
        return int(print_list[0]) * print_list[1]
    elif compressed_form.count('}') == 0:
        return ''
    else:
        index = compressed_form.find('}')
        string = compressed_form[0:index]
        print_list = string.split('{')
        return int(print_list[0]) * print_list[1] + \
        expand_formula(compressed_form[index + 1:])


def multiply(chars, nums):
   
    double = 2
    if len(chars) == 0:
        return ''
    if nums[0] % double == 1:
        return chars[0] * nums[0] + multiply(chars[1:], nums[1:]) + \
        chars[0] * nums[0]
    else:
        return  chars[0] * (nums[0] // double) + \
        multiply(chars[1:], nums[1:]) + chars[0] * (nums[0] // double)
    

def maze(coord, map):
    
    x_coord = coord[0]
    y_coord = coord[1]
    if map[x_coord][y_coord] == "*":
        return 'treasure!'
    elif map[x_coord][y_coord] == ".":
        return 'sad'
    elif map[x_coord][y_coord] == "R":
        y_coord += 1
        return maze((x_coord, y_coord), map)
    elif map[x_coord][y_coord] == "L":
        y_coord -= 1
        return maze((x_coord, y_coord), map)
    elif map[x_coord][y_coord] == "U":
        x_coord -= 1
        return maze((x_coord, y_coord), map)
    elif map[x_coord][y_coord] == "D":
        x_coord += 1
        return maze((x_coord, y_coord), map)

def count_substring(s, first, last):
   
    if len(s) == 0:
        return 0
    elif len(s) == 1 and first == last and first == s:
        return 1
    elif len(s) == 1 and first != last:
        return 0
    elif s[0] == first and s[-1] == last:
        return 1 + count_substring(s[1:], first, last) + \
        count_substring(s[:-1], first, last) - \
        count_substring(s[1:-1], first, last)
    elif s[0] != first or s[-1] != last:
        return 0 + count_substring(s[1:], first, last) + \
        count_substring(s[:-1], first, last) - \
        count_substring(s[1:-1], first, last)


def lutee_reproduction(months):
   
    if months == 1:       
        starting_value = 2
        return starting_value
    if months == 0:
        return 0
    else:
        previous_months = 2
        return lutee_reproduction(months - 1) + \
        lutee_reproduction(months - previous_months)


class Website:
   
    server = "DNS"

    def __init__(self, name, url, has_audio, num_clicks, \
    browser_compatibility):
       
        assert type(name) == str and len(name) != 0
        assert type(url) == str and len(url) != 0
        two = 2
        assert len(url.split('.')) >= two and \
        len(url.split('.')[len(url.split('.')) - 1]) >= two
        assert type(has_audio) == bool
        assert type(num_clicks) == int
        assert type(browser_compatibility) == list
        self.name = name
        self.url = url
        self.has_audio = has_audio
        self.num_clicks = num_clicks
        self.browser_compatibility = browser_compatibility

    def get_name(self):
        return self.name

    def get_url(self):
        return self.url

    def get_has_audio(self):
        return self.has_audio

    def get_num_clicks(self):
        return self.num_clicks

    def get_browser_compatibility(self):
        return self.browser_compatibility

    def __str__(self):
        return self.get_name() + ' linked at ' +  self.get_url() + ' is \
available on ' + str(self.get_browser_compatibility()) + " \
platforms. It's been interacted with " + str(self.get_num_clicks \
        ()) + ' times already!'

    def click(self, user):

        self.num_clicks += 1
        return user + ' interacted with ' + self.get_name() + ' at ' + \
            self.get_url()

    def add_to_browser(self, browser):

        assert type(browser) == Browser
        if browser.open_tab(self):
            return True
        else:
            return False

    def check_browser_compatibility(self, browser):
        
        if browser.get_name() in self.get_browser_compatibility():
            return True
        else:
            return False

    def refresh(self):

        self.num_clicks = 0
        return 'refreshed!'

    def play_audio(self):

        if self.get_has_audio() == True:
            return 'doo da do!'
        else:
            return 'no audio.'

        
class Browser:


    def __init__(self, name, user):
       
        assert type(name) == str and len(name) > 0
        assert type(user) == str and len(user) > 0
        self.name = name
        self.user = user
        self.num_tabs = 0
        self.websites = []
        self.history = []

    def get_name(self):
        return self.name

    def get_user(self):
        return self.user

    def get_num_tabs(self):
        return self.num_tabs

    def get_history(self):
        return self.history

    def get_websites(self):
        return self.websites

    def __str__(self):
        return 'Browser ' + self.get_name() + ' opened by ' + self.get_user() + ' has ' + str(self.get_num_tabs()) + ' tabs open.'

    def open_tab(self, website):

        assert type(website) == Website
        if self.get_name() in website.get_browser_compatibility():
            self.num_tabs += 1
            self.websites += [website]
            self.history += [website]
            return True
        else:
            return False

    def close_tab(self, website):

        assert type(website) == Website
        if website in self.get_websites():
            self.num_tabs = self.num_tabs - 1
            if len(self.websites) == 1:
                self.websites = []
            else:
                self.get_websites().remove(website)
            return True
        else:
            return False

    def clear_history(self, n):

        assert n > 0
        if n > len(self.get_history()):
            return False
        else:
            for i in range(n):
                self.get_history().pop(0)
            return True

    def get_total_clicks(self):
        return sum([web.get_num_clicks() for web in self.get_websites()])

    def interact_all(self):

        if len(self.get_websites()) > 0:
            return_str = ''
            for web in self.get_websites():
                return_str += web.click(self.user) + '\n'
            return_str2 = return_str.replace('interacted with', 'Clicked on')
            return return_str2[:-1]
        else:
            return 'Empty'
    def combine_windows(self, other_browser):

        assert type(other_browser) == Browser
        to_add = [x for x in other_browser.get_websites() \
        if x.check_browser_compatibility(self)]
        self.num_tabs += len(to_add)
        self.history += to_add
        self.websites += to_add
        if len(to_add) == len(other_browser.get_websites()):
            return True
        else:
            return len(to_add)


class DoggyCare:
    
    def __init__(self, dogs):
        self.dogs = dict(sorted(dogs.items(), key = lambda item: item[1]))
    def __repr__(self):
        return str(self.dogs)
    def __str__(self):
        threshold = 30
        if len(self.dogs) == 0:
            return 'NO DOGS TODAY, HAVE A REST!'
        if list(self.dogs.values())[0] > threshold:
            return 'No dogs to feed yet!'
        else:
            return 'Need to add more food for ' + list(self.dogs.keys())[0] +\
            '! ' + str(list(self.dogs.values())[0]) + \
            ' percent of fullness for ' + list(self.dogs.keys())[0] + ' now.'
    def __eq__(self, other):
        self_count = 0
        other_count = 0
        self_amount = 0
        other_amount = 0
        hungry = 30
        difference_threshold = 20
        for i in self.dogs.values():
            if i < hungry:
                self_count += 1
                self_amount += hungry - i
        for i in other.dogs.values():
            if i < hungry:
                other_count += 1
                other_amount += hungry - i
        if self_count != other_count:
            return False
        if abs(self_amount - other_amount) >= difference_threshold:
            return False
        return True
    def __add__(self, other):
        full = 100
        return_dog = DoggyCare(self.dogs)
        for i in range(len(other.dogs.keys())):
            name = list(other.dogs.keys())[i]
            if name in self.dogs:
                return_dog.dogs[name] += other.dogs[name]
                if return_dog.dogs[name] > full:
                    return_dog.dogs[name] = full
            else:
                return_dog.dogs[name] = other.dogs[name]
        return return_dog

class Order:
    
    def __init__(self, name, calories):

        self.name = name
        self.calories = calories
    
    def get_calories_per_object(self):
        return self.calories

    def __eq__(self, other_order):
        if self.get_calories_per_object() == \
        other_order.get_calories_per_object():
            return True
        else:
            return False        

    def __ne__(self, other_order):
        if self.get_calories_per_object() != \
        other_order.get_calories_per_object():
            return True
        else:
            return False    

    def __gt__(self, other_order):
        if self.get_calories_per_object() > \
        other_order.get_calories_per_object():
            return True
        else:
            return False 

    def __ge__(self, other_order):
        if self.get_calories_per_object() >= \
        other_order.get_calories_per_object():
            return True
        else:
            return False 

    def __lt__(self, other_order):
        if self.get_calories_per_object() < \
        other_order.get_calories_per_object():
            return True
        else:
            return False

    def __le__(self, other_order):
        if self.get_calories_per_object() <= \
        other_order.get_calories_per_object():
            return True
        else:
            return False


    def __repr__(self):

        class_name = self.__class__.__name__
        return class_name + ': ' + self.name
        

class Base(Order):

    def __init__(self, name, volume, calories, ice_level):
        super().__init__(name, calories)
        self.volume = volume
        self.ice_level = ice_level

    def get_calories_per_object(self):
        return self.volume * self.calories - self.ice_level
    
    def __str__(self):

        return str(self.volume) + ' liter of ' + self.name + ' with ' + \
        str(self.calories) + ' calories per liter and ' + \
        str(self.ice_level) + ' ice level'

class Topping(Order):

    def __init__(self, name, calories, sweetness):
        super().__init__(name, calories)
        self.sweetness = sweetness
    def get_calories_per_object(self):

        return self.calories * self.sweetness
    
    def __str__(self):

        return self.__class__.__name__+ ' ' + self.name + ': ' + \
        str(self.calories) + ' calories with sweetness level of ' + \
        str(self.sweetness)

class Beverage:
    
    def __init__(self, name, bases, toppings):
        self.name = name
        self.bases = bases
        self.toppings = toppings

    def get_total_calories(self):
        total = 0
        for i in self.bases:
            total += i.get_calories_per_object()
        for j in self.toppings:
            total += j.get_calories_per_object()
        return total
       
    
    def __eq__(self, other_order):
        if self.get_total_calories() == other_order.get_total_calories():
            return True
        else:
            return False     

    def __ne__(self, other_order):    
        if self.get_total_calories() != other_order.get_total_calories():
            return True
        else:
            return False     

    def __gt__(self, other_order):
        if self.get_total_calories() > other_order.get_total_calories():
            return True
        else:
            return False     

    def __ge__(self, other_order):
        if self.get_total_calories() >= other_order.get_total_calories():
            return True
        else:
            return False     

    def __lt__(self, other_order):
        if self.get_total_calories() < other_order.get_total_calories():
            return True
        else:
            return False     

    def __le__(self, other_order):
        if self.get_total_calories() <= other_order.get_total_calories():
            return True
        else:
            return False     

    def __add__(self, other_order):

        new_bev = Beverage('', [], [])
        new_bev.name = self.name + ' ' + other_order.name
        new_bases = []
        new_toppings = []
        current_bases = [base.name.lower() for base in self.bases]
        current_toppings = [topping.name.lower() for topping in self.toppings]
        for i in other_order.bases:
            other_copy = Base(i.name, i.volume, i.calories, i.ice_level)
            if other_copy.name.lower() in current_bases:
                for j in self.bases:
                    self_copy = Base(j.name, j.volume, j.calories, j.ice_level)
                    if other_copy.name.lower() == self_copy.name.lower():
                        self_copy.volume += other_copy.volume
                        self_copy.calories = max(self_copy.calories, \
                        other_copy.calories)
                        self_copy.ice_level = max(self_copy.ice_level, \
                        other_copy.ice_level)
                        new_bases += [self_copy]
                current_bases.remove(other_copy.name.lower())
            else:
                new_bases += [other_copy]
        for i in self.bases:
            if i.name.lower() in current_bases:
                new_bases = [i] + new_bases
        for i in other_order.toppings:
            other_copy = Topping(i.name, i.calories, i.sweetness)
            if other_copy.name.lower() in current_toppings:
                for j in self.toppings:
                    self_copy = Topping(j.name, j.calories, j.sweetness)
                    if other_copy.name.lower() == self_copy.name.lower():
                        self_copy.sweetness += other_copy.sweetness
                        self_copy.calories = max(self_copy.calories, other_copy.calories)
                        new_toppings += [self_copy]
                current_toppings.remove(other_copy.name.lower())
            else:
                new_toppings += [other_copy]
        for i in self.toppings:
            if i.name.lower() in current_toppings:
                new_toppings = [i] + new_toppings
        new_bev.bases = new_bases
        new_bev.toppings = new_toppings
        return new_bev
             
    def __str__(self):
        return self.__class__.__name__ + ': ' + self.name
      
    def __repr__(self):
        return_str = 'Bases:' + '\n'
        for i in self.bases:
            return_str += i.__str__() + '\n'
        if return_str[-1] != '\n':
            return_str += '\n'
        return_str += 'Toppings:\n'
        for j in self.toppings:
            if j != self.toppings[-1]:
                return_str += j.__str__() + '\n'
            else:
                return_str += j.__str__()
        if self.bases == [] and self.toppings == []:
            return_str = 'Bases:\n\n' + 'Toppings:\n'
            return return_str
        else:
            return return_str
      

def check_brackets(string):
   
    """
    if len(string) == 0:
        return True
    else:
        if (string[0], string[-1]) in [('(', ')'), ('{', '}'), ('[', ']')]:
            return check_brackets(string[1:-1])
        else:
            return False

def fix_concat_str(lst1, lst2):

    out = []
    for str2 in lst2:
        for str1 in lst1:
            try:
                out.append(str1 + str2)
            except:
                continue  # add try-except block
    return out


def fix_open_file(*filepaths):
    
    for filepath in filepaths:
        try:
            cur_file = open(filepath, "r")
            print(filepath + ' opened successfully') # add try-except block
            cur_file.close()
        except:
            print(filepath + ' not found')


def fix_add_backwards(lst):
    
    sum_of_pairs = []
    for i in range(len(lst) + 1):
        try:
            sum_of_pairs.append(lst[i] + lst[i - 1]) # add try-except block
        except Exception as e:
            print(type(e))
    return sum_of_pairs


def check_inputs(input1, input2):
    
    if type(input1) != str:
        raise TypeError('input1 is not the correct type')
    for i in range(len(input1)):
        if input1[i].islower() == False:
            raise TypeError('The element at index ' + str(i) + \
                ' is not lowercase letter')
    if type(input2) != list:
        raise TypeError('input2 is not the correct type')
    if input1 not in input2:
        raise TypeError('input1 not in input2')
    else:
        return 'Input validated'
    


def load_file(filepaths):
    
    if type(filepaths) != list:
        raise TypeError('filepaths is not a list')
    for i in range(len(filepaths)):
        if type(filepaths[i]) != str:
            raise TypeError('The filepath at index ' + str(i) + \
            ' is not a string')
    for i in range(len(filepaths)):
        try:
             f = open(filepaths[i], "r")
             f.close()
        except:
            raise FileNotFoundError('The filepath at index ' + str(i) + \
                ' does not exist')
    count = 0
    for i in range(len(filepaths)):
        with open(filepaths[i]) as f:
            lines = f.readlines()
            if len(lines) == 0:
                raise ValueError('The filepath at index ' + str(i) + \
                    ' is empty or contain non-alphabets')
            for j in lines:
                if '\n' in j:
                    j = j.replace('\n', '')
                content = j.split(' ')
                for word in content:
                    if word.isalpha() == False:
                        raise ValueError('The filepath at index ' + str(i) + \
                            ' is empty or contain non-alphabets')
                count += len(content)
    return count


from util import Stack, Queue

def is_duplicated(expression):
   
    stk = Stack()
    duplicate = 0
    value = False
    check1 = False
    check2 = False
    for i in expression:
        if i == '(' or i == ')':
            stk.push(i)
            value = False
        else:
            if not value:
                stk.push(i)
            value = True
    count = stk.num_items
    for i in range(count):
        if duplicate == 0:
            check1 = False
        if stk.peek() == ')':
            duplicate += 1
            stk.pop()
            value = False
        elif stk.peek() == '(':
            duplicate -= 1
            stk.pop()
            if check1 and not value:
                check2 = True
            if value and duplicate >= 1:
                check1 = True
            value = False
        else:
            stk.pop()
            value = True
    return check2
    

def find_kth_element(k, iterable):
    
    que = Queue()
    for i in iterable:
        que.enqueue(i)
    while k > 0:
        if que.peek() == None:
            for i in iterable:
                que.enqueue(i)
            value = que.peek()
            que.dequeue()
        else:
            value = que.peek()
            que.dequeue()
        k -= 1
    return value

def choices_choices(candidate, pattern, possibility):
    
    if '_' not in pattern:
        possibility.append(pattern)
    else:
        for i in candidate:
            copy = list(candidate)
            copy.remove(i)
            choices_choices(copy, pattern.replace('_', i, 1), possibility)


def respect_your_cat(food, num):
    
    if len(food) < 5:
        x = 'Give me more food!'
    else:
        x = food + num*"!"
    return x


def driver_age(lst):
    
    if len(lst) > 0:
        for i in range(len(lst)):
            if lst[i] > 25:
                x = True
            else:
                x = False
    else: 
        x = False
    return x
def over_25_counter_variable(lst):
    
    x = 0
    for i in range(len(lst)):
        if lst[i] >= 25:
            x += 1
    return x

def team_captain(first_name, last_name):
    
    name = "Team captain is " + first_name + " " + last_name
    return name

def team_name(names):
    
    team = ""
    for i in range(len(names)):
        if len(names[i]) == 1:
            team = team + names[i] + " "
        else:
            team = team + (names[i][0] + names[i][-1])
    return team

def team_slogan_concat(words, separator):
    
    slogan = ""
    for i in range(len(words)-1):
        slogan = slogan + words[i] + separator
    return slogan + words[len(words)-1]


def team_slogan_join(words, separator):
    
    return separator.join(words)

def drawing(symbol, repeat):
    
    return symbol*repeat

def drawing_longer(symbols, repeats):
    
    draw = ""
    for i in range(len(symbols)):
        draw = draw + symbols[i]*repeats[i]
    return draw

def hotel_rating_average(ratings):
    
    rate = 0
    for i in range(len(ratings)):
        if ratings[i]< 5:
            ratings[i] = 0
    for i in range(len(ratings)):
        rate =  rate + ratings[i]
    return round(rate/len(ratings),2)

def hotel_rating_best_average(ratings, names):
    
    newrating = []
    hotel = ""
    if len(ratings) == 0:
        hotel = "No route to choose from"
    else:
        for i in range(len(ratings)):
            newrating.append(hotel_rating_average(ratings[i]))
        maximum = max(newrating)
        hotel = names[newrating.index(maximum)]
    return hotel



def password(text, number, boolean):
    
    message = ""
    if type(text) != str:
        message = "ERROR!"
    elif type(number) != int:
        message = "ERROR!"
    elif type(boolean) != bool:
        message = "ERROR!"
    else:
        if number%2 == 0:
            number = number + 1
            message = text[::-1] + str(number) + str(not boolean)
        else:
            number = number - 1
            message = text[::-1] + str(number) + str(not boolean)
    return message


def parks(park_names):
    
    park_list = []
    for names in park_names:
        if len(names) < 3:
            park_list.append('will skip')
        else:
            park_list.append(names[1:len(names)-1])

    return park_list


def many_parks(many_places, threshold):
    
    return_list = []
    for many_places_list in many_places:
        park_list = []
        for names in many_places_list:                
            if len(names) < threshold * 2:
                park_list.append('will skip')
            else:
                park_list.append(names[threshold:len(names)-threshold])
        return_list.append(park_list)
    return return_list


def correct_state(places):
   
    i = 0
    capitalized = []
    while i < len(places):
        if places[i][1] =='CA':
            capitalized.append(places[i][0].upper())
            i = i + 1
        else:
            break
    return capitalized


def names(input_string, end):
    
    all_names = input_string.split(" ")
    count = 0
    for names in all_names:
        if names[-1] == end:
            if names[-2].isalpha():
                count = count + 1
            else:
                count = count
        else:
            count = count
        
    return count


def pr5_1(teams):
   
    count = 0
    for keys in teams:
        count = count + 1
    return count


def pr5_2(teams):
   
    list = []
    for key in teams.keys():
        list.append(key)
    return list


def pr5_3(teams):
   
    lists = teams.values()
    largest = 0
    for captain in lists:
        count = 0 
        for members in captain:
            count = count + 1
            if count > largest:
                largest = count
            else:
                largest = largest
    return largest


def pr5_4(teams, driver):
   
    if driver in teams:
        teams = teams
    else:
        teams.update({driver: []})
    return teams


def pr5_5(teams, driver, team_member):
    
    if driver in teams:
        member_list = teams.get(driver)
        member_list.append(team_member)
        teams.update({driver: member_list})
    else:
        teams.update(({driver: [team_member]}))
    return teams


def pr5_6(teams, team_member):
   
    for driver in teams:
        member_list = teams.get(driver)
        if team_member in member_list:
            member_list.remove(team_member)
        teams.update({driver: member_list})
    return teams


def secret_language(pass_dict):
    
    message = ""
    for members in pass_dict:
        if type(pass_dict.get(members)) == str:
            if len(pass_dict.get(members)) % 2 == 0:
                message = message + members[::-1]
        elif type(pass_dict.get(members)) == int:
            if pass_dict.get(members) >= 0:
                message = message + "*" * len(members)
            elif pass_dict.get(members) < 0:
                message = message + members[-1]
             
    return message



def decode_details(filename):
    
    with open(filename, 'r') as f:
        lines = f.readlines()
        new_lines = [x.replace('!', '').replace('?', '').replace(';', \
        '').replace('$', '').strip() for x in lines]
        return_string = ''
        for words in new_lines:
            return_string = return_string + words + '\n'
    return return_string.strip()
    
def decode_details_skipped(filename, skip):
    
    with open(filename, 'r') as f:
        lines = f.readlines()
        new_lines = [x.replace('!', '').replace('?', '').replace(';', \
        '').replace('$', '').strip() for x in lines]
    return_string = ''
    i = 0
    while i in range(len(new_lines)):
        return_string = return_string + new_lines[i] + '\n'
        i = i + skip + 1
    return return_string.strip()



def passcode(filename):
    
    with open(filename) as f:
        lines = f.readlines()
        total = ''
        for word in lines:
            total = total + word.strip().lower().replace(' ', '')
        totallist = []
        for letter in total:
            totallist.append(letter)
        dictionary = {}
        for letters in totallist:
            if letters.isalpha() and letters not in dictionary:
                dictionary[letters] = 1
            elif letters.isalpha() and letters in dictionary:
                dictionary[letters] = dictionary.get(letters) + 1
        return_string = str("")
        for ordered in sorted(dictionary):
            return_string = return_string + str(dictionary.get(ordered))
    return return_string

def dollars_cents(lst):
   
    return [str(x//100) + ' dollar(s) and ' + str(x%100) + ' cents' \
    for x in lst]



def sum_certain_amount(lst):
   
    return sum([0] + [sum([x//100]) for x in lst if x//100 > 50])



def dollars_only(lst):
   

    return [x[0] for x in lst if x[1] == 'dollars'] + \
    ['keep in vault' for x in lst if x[1] != 'dollars']


def names_only(names):
    
    return  [x for i in range(len(names)) for x in names[i]] 


def name_identify(names):

    return [x.split()[0] for x in names if 'm' in x.split()[1].lower()]


def message_encoding(message):
    
    return [message[i][i%len(message[i])::] + \
    message[i][0:i%len(message[i])] for i in range(len(message))]


def order_66(squads):
   
    return list(map(lambda x: 'executed' if 2 * x.count('jedi') <\
    x.count('clone') else 'survived', squads))



def midichlorian(people, threshold):
    
    return list(map(lambda x: x[0], \
    list(filter(lambda x: x[1]>threshold, people))))

def podracer(bets):
    
    return list(filter(lambda x: x != 'NAN', list(map(lambda name, profit: \
    name if profit[0] - profit[1] - profit[2] > 0 else 'NAN', \
    list(bets.keys()), list(bets.values()))))) 

def darth(names):
    
    return list(map(lambda x: ('Darth ' + x).title(), \
    list(filter(lambda name: name[0] and name[-1] \
    not in ['a', 'e', 'i', 'o', 'u'], names))))

def sand(places):
    
    nothing = lambda x,y: False if set(x) & set(y) else True
    return len(list(filter(lambda x: x != 'NAN', list(map(lambda name, \
    description: name if nothing(description, \
    ['sand', 'coarse', 'rough', 'irritating']) else 'NAN', \
    list(places.keys()), list(places.values()))))))


def death_star(coordinates, death_star):
   
    return list(filter(lambda x: x != 'NAN', list(map(lambda name, location: \
    name if all([location[0] - death_star[0] <= 0.5, location[1] - death_star \
    [1] <=0.5, location[2] - death_star[2] <=0.5]) else 'NAN', \
    list(coordinates.keys()), list(coordinates.values())))))


def identity(x):
    return x

def squared(x):
    return x**2



def dct_op(dct, func):

    return {key: [func(x) for x in value] for (key, value) in \
    list(dct.items())}



def dct_special(dct, func, players):
    
    return [[func(x) for x in dct.get(y)] for y in dct.keys() if y in players]



def nba_stats(dct, func, stats):
    
    if stats == 'total_points':
        idx = 0
    elif stats == 'free_throw':
        idx = 1
    elif stats == 'turn_over':
        idx = 2

    return {key: [func(y) for y in [x[idx] for x in values]] \
    for (key, values) in dct.items()}

def pumpkin_calc(x, y, z):
    
    def ppci(w):
        return round(w / (3.14 * x * y * z *4/3), 3)
    return ppci
         

def decipher_text(key1, key2, key3):
   
    def decode(x):
        return_str = ''
        for i in x:
            if i.lower() == key1.lower() and x.index(i) % 2 == 1:
                return_str = return_str + 'i'
            elif i.lower() == key1.lower() and x.index(i) %2 == 0:
                return_str = return_str + 'e'
            elif i.lower() == key2.lower() and x.index(i) %2 == 1:
                return_str = return_str + 'o'
            elif i.lower() == key2.lower() and x.index(i) %2 == 0:
                return_str = return_str + 'a'
            elif i.lower() == key3.lower():
                return_str = return_str + 'u'
            else:
                return_str = return_str + i.lower()
        return return_str
    return decode

 
def grade_calculator(w1,  w2):
    
    def rawgrade(x,y):
        if len(x) == 0:
            grade1 = 0
        else:
            grade1 = (sum(x) / len(x))
        if len(y) == 0:
            grade2 = 0
        else:
            grade2 = sum(y) / len(y)
        return round((grade1) * w1 + (grade2) * w2, 2)
    def letter(x,y):
        if rawgrade(x,y) >= 0.9:
            return 'A'
        elif rawgrade(x,y) >= 0.8:
            return 'B'
        elif rawgrade(x,y) >= 0.7:
            return 'C'
        elif rawgrade(x,y) >= 0.6:
            return 'D'
        else:
            return 'F'
    return rawgrade, letter


def complexity_tf():
    
    return [False, False, False, True, False, True, False, True, False, True]


def prerequisites(*args, **kwargs):
   
    return_list = []
    for i in args:
        for k in kwargs:
            if i in kwargs.get(k):
                if k not in return_list:
                    return_list.append(k)
            else:
                if k in return_list:
                    return_list.remove(k)
    return return_list


def building_mats(*args, **kwargs):
   
    supply = {}
    for i in args:
        if i[0] not in supply:
            supply[i[0]] = i[1]
        else:
            supply[i[0]] += i[1]
    return_list = []
    for k in kwargs:
        if k not in supply:
            return_list.append(k)
        elif kwargs[k] > supply[k]:
            return_list.append(k)
    return return_list


def reverse_str(name):
   
    if len(name) == 0:
        return name
    else:
        return reverse_str(name[1:]) + name[0]


def reverse_list(lst):
    
    if len(lst) == 0:
        return lst
    else:
        return reverse_list(lst[:-1]) + [reverse_str(lst[-1])]

def remove_dragon(lst):
   
    if len(lst) == 0:
        return []
    if lst[0].lower().count('dragon') > 0:
        return [] + remove_dragon(lst[1:])
    else:
        return [lst[0]] + remove_dragon(lst[1:])


def sum_odd(lst):
   
    if len(lst) == 0:
        return 0
    if lst[0] % 2 == 1:
        return lst[0] + sum_odd(lst[1:])
    elif lst[0] % 2 == 0:
        return sum_odd(lst[1:])


def duplication_glitch(num_diamonds, hours):
    
    if hours == 0:
        return num_diamonds
    else:
        return num_diamonds * 2 ** (hours-1) + \
        duplication_glitch(num_diamonds, hours-1)


def min_recursion(lst):
    
    if len(lst) == 1:
       return lst[0]
    else:
       minNumber = min_recursion(lst[1:])
       current_min = lst[0]
       if minNumber < current_min:
            current_min = minNumber
       return current_min


def count_chars(s):
    
    dct = {}
    if len(s) == 0:
        return dct
    else:
        dct = count_chars(s[1:])
        if s[0] in dct:
            dct[s[0]] += 1
        else:
            dct[s[0]] = 1
        return dct   


def merge(lst_1, lst_2):
    
    if len(lst_1) == 0:
        return lst_2
    elif len(lst_2) == 0:
        return lst_1
    else:
        if lst_1[0] > lst_2[0]:
            return [lst_2[0]] + merge(lst_1, lst_2[1:])
        elif lst_1[0] < lst_2[0]:
            return [lst_1[0]] + merge(lst_1[1:], lst_2)
        elif lst_1[0] == lst_2[0]:
            return [lst_1[0]] + merge(lst_1[1:], lst_2)


def split(*nums, n):
   
    x = list(nums)
    if n == 1:
        return [[x[0]]]
    elif len(x) == n:
        return [x]
    elif len(x) < n:
        return []
    else:
        return [x[0:n]] + split(*nums[n:], n = n - 1)


class Pokemon:
    
    def __init__(self, name, pokemon_type, moves):
        self.name = name
        self.pokemon_type = pokemon_type
        self.moves = moves
        self.total_moves = 0  
    
    def take_movement(self, idx):
        if idx > len(self.moves):
            return 'Fail to take the movement'
        else:
            self.total_moves += 1
            return self.moves[idx]
    
    def show_total_moves(self):
        return 'The total moves of ' + self.name + ' is ' + \
            str(self.total_moves)


class Student:
    
    describe = 'This is a student account'
    def edit_canvas():
        return 'Student account cannot edit this course'
    def __init__(self, pid, height, dob, gpa):
        self.pid = pid
        self.height = height
        self.dob = dob
        self.gpa = gpa
    def info(self):
        return 'The student ' + self.pid + " was born on " + self.dob + \
            ". The student has a gpa of " + str(self.gpa)
    def get_gpa(self):
        return self.gpa
    def set_gpa(self, new_grade):
        if new_grade < 0 or new_grade > 4:
            return 'Invalid Input'
        else:
            self.gpa = new_grade
            return True


def doctest_q6():
    
    return

import random




class Player:
    def __init__(self, username, region):
        self.username = username
        self.region = region
        self.experience = 0
        self.level = 0
        return

    def play(self):
        cond = random.choice(['W', 'L'])
        if cond == 'W':
            self.experience += 5000
            return self.username + ' played a game. You won! You have gained 5000 experience points.'
        elif cond == 'L':
            self.experience += 3000
            return self.username + ' played a game. You lost! You have gained 3000 experience points.'

    def play_several(self, games):
        return_str = ''
        for i in range(games):
            return_str += self.play() + '\n'
        return return_str[:-1]


class RegularPlayer(Player):
    def level_up(self):
        if self.experience >= (self.level + 1) * 10000:
            self.level = self.experience // 10000
            return 'Promoted to level ' + str(self.level)
        else:
            return 'Not enough experience!'


class PremiumPlayer(Player):
    def __init__(self, username, region):
        super().__init__(username, region)
        self.experience = 1000
        self.level = 0
        return
    
    def promote(self):
        if self.experience >= (self.level + 1) * 6000:
            while self.experience >= (self.level + 1) * 6000:
                self.level += 1
                self.experience += 1000
            return 'Promoted to level ' + str(self.level)
        else:
            return 'Not enough experience!'


class Hero:


    def __init__(self, name, health, base_damage, ammo):
        self.name = name
        self.health = health
        self.base_damage = base_damage
        self.ammo = ammo
        self.maximum_ammo = ammo
        self.maximum_health = health
        return

    def attack(self, other_character, ammo_usage = 1):
        if self.health <= 0:
            self.health = 0 
            return "Your character is dead! Can't attack!"
        else:
            shield = 0 
            if type(other_character) == Tank:
                shield = other_character.shield
            damage = (self.base_damage * ammo_usage) - shield
            self.ammo -= 1
            if self.ammo == 0:
                self.ammo = self.maximum_ammo
            other_character.health -= damage
            if other_character.health <= 0:
                other_character.health = 0
                return other_character.name + ' was killed after receiving ' \
                + str(damage) + ' amount of damage!'
            else:
                return other_character.name + ' received ' + str(damage) + \
                ' damage, but survived!'
    
    def heal(self, other_character, heal_amount, yourself = True):
        if yourself == True:
            if self.health <= heal_amount:
                return "Not enough health! Can't heal!"
            if other_character.health == 0:
                return "Your character is dead! Can't heal!"
            else:
                other_character.health += heal_amount
                self.health -= heal_amount
                if other_character.health > other_character.maximum_health:
                    other_character.health = other_character.maximum_health
                return self.name + ' healed ' + other_character.name + ' to ' \
                + str(other_character.health) + ' health!'
        if yourself == False:
            if other_character.health <= heal_amount:
                return "Not enough health! Can't heal!"
            if self.health == 0:
                return "Your character is dead! Can't heal!"
            else:
                self.health += heal_amount
                other_character.health -= heal_amount
                if self.health > self.maximum_health:
                    self.health = self.maximum_health
                return other_character.name + ' healed ' + self.name + ' to ' \
                + str(self.health) + ' health!'
    

class Tank(Hero):


    def __init__(self, name, health, base_damage, ammo, shield):
        super().__init__(name, health, base_damage, ammo)
        self.shield = shield
        return

class Healer(Hero):

    def heal(self, other_character, heal_amount):
        if other_character.health <= 0:
            other_character.health = 0
            other_character.health += int(heal_amount / 2)
            return 'Your character is now alive! ' + self.name + ' healed ' + \
                other_character.name + ' to ' \
                + str(other_character.health) + ' health!'
        else:
            other_character.health += heal_amount
            if other_character.health > other_character.maximum_health:
                other_character.health = other_character.maximum_health
            return self.name + ' healed ' + other_character.name +  ' to ' + \
                str(other_character.health) + ' health!'
            


def question_1():
    
    return  [0, 0, 0, 1, 1, 0, 0, 1, 0, 1]




def question_2():
    
    return  [0, 0, 0, 1, 1]



def reverse_list(lst):
    
    l = len(lst)
    for i in range(l):
        if i < l / 2:
            lst[i], lst[l - i - 1] = lst[l - i - 1], lst[i]



def swap_lists(alist1, alist2):
    
    for i in range(len(alist1)):
        alist1[i], alist2[i] = alist2[i], alist1[i]


def daily_inventory(store, purchases):
    
    store_items = list(store.keys())
    for i in store_items:
        if i not in purchases:
            store.pop(i)
        else:
            if store[i] - purchases[i] == 0:
                store.pop(i)
            else:
                store[i] = store[i] - purchases[i]

def reverse_chunks(seq):
    
    i = len(seq)
    j = 1
    m = 0
    while i > j:
        for k in range(j):
            if k < j/2:
                seq[m + k], seq[m + j - k - 1] = seq[m + j - k - 1], seq[m + k]
        m += j
        i -= j
        j += 1


class Collection:
 

    def __init__(self):

        self.items = []
        self.num_items = 0

    def size(self):

        return self.num_items

    def is_empty(self):

        if self.num_items == 0:
            return True
        else:
            return False

    def clear(self):

        self.items = []
        self.num_items = 0


class Stack(Collection):
   
    def push(self, item):

        if item == None:
            raise ValueError('None is not a valid item')
        else:
            self.num_items += 1
            self.items.insert(0, item)
    def pop(self):

        if self.num_items == 0:
            return None
        else:
            to_return = self.items[0]
            del self.items[0]
            self.num_items -= 1
            return to_return
    def peek(self):

        if self.num_items == 0:
            return None
        else:
            return self.items[0]

    def __str__(self):

        if self.num_items == 0:
            return "(bottom) (top)"
        else:
            items_string = ' '
            for i in self.items[::-1]:
                items_string += str(i) + ' -- '
            return '(bottom)' + items_string[:-3] + '(top)'


class Queue(Collection):

    def enqueue(self, item):

        if item == None:
            raise ValueError('None is not a valid item')
        else:
            self.num_items += 1
            self.items.append(item)
    def dequeue(self):

        if self.num_items == 0:
            return None
        else:
            self.num_items -= 1
            return self.items.pop(0)
    def peek(self):

        if self.num_items == 0:
            return None
        else:
            return self.items[0]
    def __str__(self):

        if self.num_items == 0:
            return "(front) (rear)"
        else:
            items_string = ' '
            for i in self.items:
                items_string += str(i) + ' -- '
            return '(front)' + items_string[:-3] + '(rear)'
class FillinQuestion(Question) :
    def __init__(self) :
        super().__init__()
    def setText(self, questionText) :   
        startanswer = questionText.find("_")
        endanswer = questionText.rfind("_")
        self.setAnswer(questionText[startanswer + 1 : endanswer])
        self._text = questionText[ : startanswer] + "_____" + questionText[endanswer : ]
class AnyCorrectChoiceQuestion(Question) :
    def checkAnswer(self, response) :
        answerlist = self._answer.split()
        for ans in answerlist :
            if response == ans :
                return True
        return False
class Question :
    def __init__(self) :
        self._text = ""
        self._answer = ""
    def setText(self, questionText) :   
        self._text = questionText
    def addText(self, text) :
        self._text = self._text + text
    def setAnswer(self, correctResponse) :
        self._answer = correctResponse
    def checkAnswer(self, response) :
        return response == self._answer
    def display(self) :
        print(self._text)   
class ChoiceQuestion(Question) :
    def __init__(self) :
        super().__init__()
        self._num_choices = 0
    def addChoice(self, choice, correct) :
        self._num_choices = self._num_choices + 1
        self.addText("\n" + str(self._num_choices) + ": " + choice)
        if correct :
            choiceString = str(self._num_choices)
            self.setAnswer(choiceString)
class Person :
    def __init__(self, name, year) :
        self._name = name
        self._year = year
    def __repr__(self) :
        return self._name + ", born " + str(self._year)
class Student(Person) :
    def __init__(self, name, year, major) :
        super().__init__(name, year)
        self._major = major
    def __repr__(self) :
        return self._name + ", born " + str(self._year) + \
             " is a " + self._major + " major"
class Instructor(Person) :
    def __init__(self, name, year, salary) :
        super().__init__(name, year)
        self._salary = salary
    def __repr__(self) :
        return self._name + ", born " + str(self._year) + \
             " has a $%.2f" % self._salary + " salary"

per = Person("Bob", 2000)
stu = Student("Bill", 2000, "CS")
ins = Instructor("Will", 1980, 50000)

print(per)
print(stu)
print(ins)
class Employee :
    def __init__(self, name, salary) :
        self._name = name
        self._salary = salary
    def __repr__(self) :
        return self._name + " has a salary of %.2f" % self._salary
class Manager(Employee) :
    def __init__(self, name, salary, department) :
        super().__init__(name, salary)
        self._department = department
    def __repr__(self) :
        return self._name + " has a salary of %.2f" % self._salary + \
             " and manages the " + self._department + " department"
class Executive(Manager) :
    def __repr__(self) :
        return self._name + " has a salary of %.2f" % self._salary + \
             " and is the executive for the " + self._department + " department"

emp = Employee("Bob", 500)
man = Manager("Bill", 5000, "A")
exe = Executive("Will", 50000, "C")

print(emp)
print(man)
print(exe)
class Dinosaur :
    def __init__(self, name="dinosaur") :
        self._name = name

    def display(self) :
        print(self._name)

class Triceratops(Dinosaur) :
    def __init__(self) :
        super().__init__("triceratops")

x = Triceratops()
x.display()
def hello (number):
    if number == 1:
        return "January"
    if number == 2:
        return "February"
    if number == 3:
        return "March"
    if number == 4:
        return "April"
    if number == 5:
        return "May"
    if number == 6:
        return "June"
    if number == 7:
        return "July"
    if number == 8:
        return "August"
    if number == 9:
        return "September"
    if number == 10:
        return "October"
    if number == 11:
        return "November"
    if number == 12:
        return "December"
for i in range(1, 4) :
   for j in range(1, 4) :
      print("X", end="")
   print("")
input1 = input("First integer: ")
input2 = input("Second integer: ")
input1 = int(input1)
input2 = int(input2)
SUM=input1+input2
print("%-10s%5d" % ("Sum: ", SUM))
DIFF=input1-input2
print("%-10s%3d" % ("Difference: ", DIFF))
PROD=input1*input2
print("%-10s%5d" % ("Product: ", PROD)) 
AVE=(input1+input2)/2
AVE=float(AVE)
print("%-10s%8.2f" % ("Average: ", AVE))
DIST=abs(input1-input2)
print("%-10s%5d" % ("Distance: ", DIST))
MAX=max(input1,input2)
MIN=min(input1,input2)
print("%-10s%5d" % ("Maximum: ", MAX))
print("%-10s%5d" % ("Minimum: ", MIN))
Grade=input("Enter a letter grade: ")
Grade=Grade.upper()
if Grade == "A+":
    number=4.0
elif Grade == "A":
    number=4.0
elif Grade == "A-":
    number=3.7
elif Grade == "B+":
    number=3.3
elif Grade=="B":
    number=3.0
elif Grade=="B-":
    number=2.7
elif Grade=="C+":
    number=2.3
elif Grade=="C":
    number=2.0
elif Grade=="C-":
    number=1.7
elif Grade=="D+":
    number=1.3
elif Grade=="D":
    number=1.0
elif Grade=="D-":
    number=0.7
elif Grade=="F":
    number=0
else:
    print("Please enter a letter grade")
print("The numeric value is:", number)
Card=input("Enter a card notation: ")
Card=Card.upper()
if Card.startswith("A"):
    if Card.endswith("D"):
        print("Ace of Diamonds")
    elif Card.endswith("H"):
        print("Ace of Hearts")
    elif Card.endswith("C"):
        print("Ace of Clubs")
    elif Card.endswith("S"):
        print("Ace of Spades")
    else:
        print("Invalid Input!")
elif Card.startswith("2"):
    if Card.endswith("D"):
        print("Two of Diamonds")
    elif Card.endswith("H"):
        print("Two of Hearts")
    elif Card.endswith("C"):
        print("Two of Clubs")
    elif Card.endswith("S"):
        print("Two of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("3"):
    if Card.endswith("D"):
        print("Three of Diamonds")
    elif Card.endswith("H"):
        print("Three of Hearts")
    elif Card.endswith("C"):
        print("Three of Clubs")
    elif Card.endswith("S"):
        print("Three of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("4"):
    if Card.endswith("D"):
        print("Four of Diamonds")
    elif Card.endswith("H"):
        print("Four of Hearts")
    elif Card.endswith("C"):
        print("Four of Clubs")
    elif Card.endswith("S"):
        print("Four of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("5"):
    if Card.endswith("D"):
        print("Five of Diamonds")
    elif Card.endswith("H"):
        print("Five of Hearts")
    elif Card.endswith("C"):
        print("Five of Clubs")
    elif Card.endswith("S"):
        print("Five of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("6"):
    if Card.endswith("D"):
        print("Six of Diamonds")
    elif Card.endswith("H"):
        print("Six of Hearts")
    elif Card.endswith("C"):
        print("Six of Clubs")
    elif Card.endswith("S"):
        print("Six of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("7"):
    if Card.endswith("D"):
        print("Seven of Diamonds")
    elif Card.endswith("H"):
        print("Seven of Hearts")
    elif Card.endswith("C"):
        print("Seven of Clubs")
    elif Card.endswith("S"):
        print("Seven of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("8"):
    if Card.endswith("D"):
        print("Eight of Diamonds")
    elif Card.endswith("H"):
        print("Eight of Hearts")
    elif Card.endswith("C"):
        print("Eight of Clubs")
    elif Card.endswith("S"):
        print("Eight of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("9"):
    if Card.endswith("D"):
        print("Nine of Diamonds")
    elif Card.endswith("H"):
        print("Nine of Hearts")
    elif Card.endswith("C"):
        print("Nine of Clubs")
    elif Card.endswith("S"):
        print("Nine of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("10"):
    if Card.endswith("D"):
        print("Ten of Diamonds")
    elif Card.endswith("H"):
        print("Ten of Hearts")
    elif Card.endswith("C"):
        print("Ten of Clubs")
    elif Card.endswith("S"):
        print("Ten of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("J"):
    if Card.endswith("D"):
        print("Jack of Diamonds")
    elif Card.endswith("H"):
        print("Jack of Hearts")
    elif Card.endswith("C"):
        print("Jack of Clubs")
    elif Card.endswith("S"):
        print("Jack of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("Q"):
    if Card.endswith("D"):
        print("Queen of Diamonds")
    elif Card.endswith("H"):
        print("Queen of Hearts")
    elif Card.endswith("C"):
        print("Queen of Clubs")
    elif Card.endswith("S"):
        print("Queen of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("K"):
    if Card.endswith("D"):
        print("King of Diamonds")
    elif Card.endswith("H"):
        print("King of Hearts")
    elif Card.endswith("C"):
        print("King of Clubs")
    elif Card.endswith("S"):
        print("King of Spades")
    else:
        print("Invalid Input!")        
else:
    print("Invalid Input!")
income=int(input("Please enter your income: "))
if income <=50000:
    tax=0.01
elif 50000<income<=75000:
    tax=0.02
elif 75000<income<=100000:
    tax=0.03
elif 100000<income<=250000:
    tax=0.04
elif 250000<income<=500000:
    tax=0.05
elif income>500000:
    tax=0.06
print("The income tax is:",round(income*tax,2),"dollars")
Status=input("Please enter your marital status(S for single, M for Married): ")
Status=Status.upper()
Income=int(input("Please enter your income: "))
if Status == "S":
    if 0<=Income<=8000:
        print("The tax is: $",round(Income*0.1,2))
    elif 8000<Income<=32000:
        print("The tax is: $",round(800+Income*0.15,2))
    elif Income>32000:
        print("The tax is:$",round(4400+Income*0.25,2))
elif Status == "M":
    if 0<=Income<=16000:
        print("The tax is: $",round(Income*0.1,2))
    elif 16000<Income<=64000:
        print("The tax is: $",round(1600+Income*0.15,2))
    elif Income>64000:
        print("The tax is:$",round(8800+Income*0.25,2))    
else:
    print("Invalid Input")
Number=int(input("Enter the integer 1-3999: "))
if 1<=Number<=3999:
    Thou=Number//1000
    if Thou==3:
        Thousands="MMM"
    if Thou==2:
        Thousands="MM"
    if Thou == 1:
        Thousands = "M"
    if Thou == 0:
        Thousands = ""
    Hund=(Number-Thou*1000)//100
    if Hund ==9:
        Hundreds = "CM"
    if Hund==8:
        Hundreds = "DCCC"
    if Hund==7:
        Hundreds = "DCC"
    if Hund == 6:
        Hundreds = "DC"
    if Hund == 5:
        Hundreds = "D"
    if Hund == 4:
        Hundreds = "CD"
    if Hund == 3:
        Hundreds = "CCC"
    if Hund == 2:
        Hundreds = "CC"
    if Hund == 1:
        Hundreds = "C"
    if Hund == 0:
        Hundreds = ""
    Ten=(Number-Thou*1000-Hund*100)//10
    if Ten == 9:
        Tenths = "XC"
    if Ten == 8:
        Tenths = "LXXX"
    if Ten == 7:
        Tenths =  "LXX"
    if Ten == 6:
        Tenths = "LX"
    if Ten == 5:
        Tenths = "L"
    if Ten == 4:
        Tenths = "XL"
    if Ten == 3:
        Tenths = "XXX"
    if Ten == 2:
        Tenths = "XX"
    if Ten == 1:
        Tenths = "X"
    if Ten == 0:
        Tenths = ""
    One=(Number-Thou*1000-Hund*100-Ten*10)
    if One == 9:
        Ones = "IX"
    if One == 8:
        Ones = "VIII"
    if One == 7:
        Ones = "VII"
    if One == 6:
        Ones = "VI"
    if One == 5:
        Ones = "V"
    if One == 4:
        Ones = "IV"
    if One == 3:
        Ones = "III"
    if One == 2:
        Ones = "II"
    if One == 1:
        Ones = "I"
    if One == 0:
        Ones =""
else:
    print("Please enter a number 1-3999")
print("The Roman numeral for the year", Number, "is", Thousands+Hundreds+Tenths+Ones+".")
for i in range (1,11):
    for j in range (1,11):
        print("%4d"%(i*j), end="")
    print()
n=int(input("Please enter a number: "))
line=1
dot=1
for i in range(n):
    dot=1
    for i in range(n):
        print("*", end = "")
    print(end=" ")
    for i in range(n):
        if line==1 or line==n:
            print("*", end = "")
        else:
            if dot==1 or dot==n:
                print("*", end = "")
            else:
                print(" ", end = "")   
        dot=dot+1
    line=line+1
    print()

from random import randint
from math import log
human = 0     
comp = 1
smart = 0
dumb = 1
pile = randint(10, 100)
turn = randint(0, 1)
strat = randint(0, 1)
while pile > 0 :
   if turn == comp :
      if pile == 1 :
         take = 1
      elif strat == dumb :
         take = randint(1, pile // 2)
      elif pile == 3 or pile == 7 or pile == 15 or pile == 31 or pile == 63 :
         take = randint(1, pile // 2)
      else : 
         take = pile - 2 ** int(log(pile, 2)) + 1
      pile = pile - take
      print("The computer took",take,"marbles, leaving",pile)
      print()
      turn = human
   elif turn == human :
      print("Your turn. The pile currently has", pile, "marbles in it.")
      take = int(input("How many marbles will you take? "))
      while take < 1 or take > max(pile // 2, 1) :
         print("That isn't a legal move.")
         take = int(input("How many marbles will you take? "))
      pile = pile - take 
      print("Now the pile has", pile, "marbles in it.")
      print()
      turn = comp
if turn == comp :
   print("The computer won!")
else :
   print("You Won!")
num = input("Enter an 8 digit credit card number: ")
odd = 0
for i in range(7, 0, -2) :
    odd = odd + int(num[i])
even = 0
for i in range(6, -1, -2) :
    double = int(num[i]) * 2
    even = even + double // 10 + double % 10
total = odd + even
if total % 10 == 0 :
    print("That number is valid.")
else :
    digit = int(num[7])
    shouldbe = (10 - (total % 10) + digit) % 10
    print("The number is not valid.  The check digit should be: ", shouldbe)
number=int(input("Please enter a random positive number: "))
if number>=0: 
    def main() :
        print("firstDigit of", number, "is", firstDigit(number))
        print("lastDigit of", number, "is", lastDigit(number))
        print("digits of", number, "is", digits(number))
    
    def firstDigit(n) :
        x = str(n)
        first = int(x[0])
        return first

    def lastDigit(n) :
        return n % 10

    
    def digits(n) :
        x = str(n)
        return len(x)

    main()
else:
    print("Please enter a valid number")

from math import pi, sqrt
r = float(input("Enter the radius: "))
h = float(input("Enter the height: "))
def main() :
   print("A sphere has volume:", sphereVolume(r))
   print("A sphere has surface area:", sphereSurface(r))
   print("A cylinder has volume:", cylinderVolume(r, h))
   print("A cylinder has surface area:", cylinderSurface(r, h))
   print("A cone has volume:", coneVolume(r, h))
   print("A cone has surface area:", coneSurface(r, h))

def sphereVolume(r) :
   return 4 / 3 * pi * r ** 3

def sphereSurface(r) :
   return 4 * pi * r ** 2

def cylinderVolume(r, h) :
   return pi * r ** 2 * h

def cylinderSurface(r, h) :
   return 2 * (pi * r ** 2 + pi * r * h)

def coneVolume(r, h) :
   return 1 / 3 * pi * r * r * h

def coneSurface(r, h) :
   s = sqrt(h * h + r * r)
   return pi * r * s + pi * r * r

main()
hours = int(input("Enter the hours (between 1-12): "))
minutes = int(input("Enter the minutes: "))
def main() :
    print(getTimeName(hours, minutes))

def getTimeName(hours, minutes) :
    if minutes == 15 :
        return "quarter after " + hourName(hours)
    elif minutes == 30 :
        return "half past " + hourName(hours)
    elif minutes == 45 :
        return "quarter to " + hourName((hours + 1))
    elif minutes == 0 :
        return hourName(hours) + " o'clock"
    elif minutes < 30 :
        if minutes == 1 : 
            word = " minute past "
        else :
            word= " minutes past "
        return intName(minutes) + word + hourName(hours)
    else :
        if 60 - minutes == 1 :
            word = " minute before "
        else :
            word = " minutes before "
        return intName(60 - minutes) + word + hourName((hours + 1))

def hourName(digit) :
    if digit == 0: return "twelve"
    if digit == 1: return "one"
    if digit == 2: return "two"
    if digit == 3: return "three"
    if digit == 4: return "four"
    if digit == 5: return "five"
    if digit == 6: return "six"
    if digit == 7: return "seven"
    if digit == 8: return "eight"
    if digit == 9: return "nine"
    if digit == 10: return "ten"
    if digit == 11: return "eleven"
    if digit == 12: return "twelve"
    return ""

def intName(number) :
    part = number
    name = ""     
    if part >= 100 :
        name = digitName(part // 100) + " hundred"
        part = part % 100

    if part >= 20 :
        name = name + " " + tensName(part)
        part = part % 10
    elif part >= 10 :
        name = name + " " + teenName(part)
        part = 0
    if part > 0 :
        name = name + " " + digitName(part)
    return name.strip()

def digitName(digit) :
    if digit == 1: return "one"
    if digit == 2: return "two"
    if digit == 3: return "three"
    if digit == 4: return "four"
    if digit == 5: return "five"
    if digit == 6: return "six"
    if digit == 7: return "seven"
    if digit == 8: return "eight"
    if digit == 9: return "nine"
    return ""

def teenName(number) :
    if number == 10 : return "ten"
    if number == 11 : return "eleven"
    if number == 12 : return "twelve"
    if number == 13 : return "thirteen"
    if number == 14 : return "fourteen"
    if number == 15 : return "fifteen"
    if number == 16 : return "sixteen"
    if number == 17 : return "seventeen"
    if number == 18 : return "eighteen"
    if number == 19 : return "nineteen"
    return ""

def tensName(number) :
    if number >= 90 : return "ninety"
    if number >= 80 : return "eighty"
    if number >= 70 : return "seventy"
    if number >= 60 : return "sixty"
    if number >= 50 : return "fifty"
    if number >= 40 : return "forty"
    if number >= 30 : return "thirty"
    if number >= 20 : return "twenty"
    return ""

main()

word=str(input("Please enter a word: "))
search=str(input("Please enter the word you want test whether or not it is in the word above: "))
def main():
    print(search, "is in the word,",word,":",find(word,search))

def find(string, match) :
    if string.startswith(match) == True :
        return True
    elif len(string) >= len(match) :
        return find(string[1 : len(string)], match)
    else :
        return False
main()
year=int(input("Please enter a year: "))
def main() :
    print(year,"is a leap year: ", isLeapYear(year))

def isLeapYear(n) :
    if n > 1582 and year % 400 == 0 :
        return True
    if n > 1582 and year % 100 == 0 : 
        return False
    if n % 4 == 0 :
        return True
    return False
main()
import sys
inputFile = sys.argv[1]
inp = open(inputFile, "r")
lines = inp.readlines()
inp.close()
outputFile = sys.argv[2]
out = open(outputFile, "w")
for i in range(len(lines) - 1, -1, -1) :
    out.write(lines[i])
out.close()
import sys
from sys import exit
def main() :
    if len(sys.argv) != 5 :
        exit("Cipher requires 4 command line parameters")
    keyword = Remove(Get())  
    keyword = keyword.upper()
    inname = sys.argv[3]
    inf = open(inname, "r")
    outname = sys.argv[4]
    outf = open(outname, "w")
    for x in "ZYXWVUTSRQPONMLKJIHGFEDCBA" :
        if x not in keyword :
            keyword = keyword + x
    if "-e" in sys.argv :
        for line in inf :
            for x in line :
                pos = -1
                if x >= "A" and x <= "Z" :
                    pos = ord(x) - ord("A")
                    outf.write(keyword[pos])
                elif x >= "a" and x <= "z" :
                    pos = ord(x) - ord("a")
                    outf.write(keyword[pos].lower())
                else :
                    outf.write(x)
    elif "-d" in sys.argv :
        for line in inf :
            for x in line :
                if x in keyword :
                    x = chr(ord("A") + keyword.index(x))
                elif x in keyword.lower() :
                    x = chr(ord("a") + keyword.lower().index(x))
                outf.write(x)
    else :
        exit("Either -d or -e must be provided for decrypt or encrypt.")
    inf.close()
    outf.close()

def Remove(s) :
    y = ""
    for x in s :
        if x not in y :
            y = y + x
    return y
def Get() :
    for a in sys.argv :
        if a[0 : 2] == "-k" :
            return a[2 : ]
    exit("A keyword must be provided with -kKEYWORD")

main()
from math import pi, sqrt

def sphereVolume(r) :
   return 4 / 3 * pi * r ** 3

def sphereSurface(r) :
   return 4 * pi * r ** 2

def cylinderVolume(r, h) :
   return pi * r ** 2 * h

def cylinderSurface(r, h) :
   return 2 * (pi * r ** 2 + pi * r * h)

def coneVolume(r, h) :
   return 1 / 3 * pi * r * r * h

def coneSurface(r, h) :
   s = sqrt(h * h + r * r)
   return pi * r * s + pi * r * r

from math import pi, sqrt
from geometry import sphereVolume, sphereSurface, cylinderVolume, cylinderSurface, coneVolume, coneSurface

r = float(input("Enter the radius: "))
h = float(input("Enter the height: "))
print("A sphere has volume:", sphereVolume(r))
print("A sphere has surface area:", sphereSurface(r))
print("A cylinder has volume:", cylinderVolume(r, h))
print("A cylinder has surface area:", cylinderSurface(r, h))
print("A cone has volume:", coneVolume(r, h))
print("A cone has surface area:", coneSurface(r, h))


import random
import string

from time import sleep
from IPython.display import clear_output

def add_lists(list1, list2):
    output = []
    for i in zip(list1, list2):
        output.append(sum(i))
    return output

def check_bounds(position, size):
    for i in position:
        if i < 0 or i >= size:
            return False
    return True

def play_board(bots, n_iter = 25, grid_size = 5, sleep_time = 0.3):

    if not type(bots) == list:
        bots = [bots]
    
    for bot in bots:
        bot.grid_size = grid_size

    for it in range(n_iter):

        grid_list = [['.'] * grid_size for ncols in range(grid_size)]
        
        for bot in bots:
            grid_list[bot.position[0]][bot.position[1]] = bot.character    

        clear_output(True)
        print('\n'.join([' '.join(lst) for lst in grid_list]))
        sleep(sleep_time)

        for bot in bots:
            bot.move()
class WanderBot():
    def __init__(self, character = 8982):
        self.character = chr(character)
        self.position = [0,0]
        self.moves = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        self.grid_size = None
    def wander(self):
        has_new_pos = False
        while not has_new_pos:
            move = random.choice(self.moves)
            new_pos = add_lists(move, self.position)
            has_new_pos = check_bounds(new_pos, self.grid_size)
        return new_pos
    def move(self):
        self.position = self.wander()
import pandas as pd
from bs4 import BeautifulSoup
import requests
from urllib.request import Request, urlopen
pd.read_csv("https://raw.githubusercontent.com/Zaanis/COGS108_Repo/main/all_player_1.csv")
data = []
for num in range (1,8):
  url = "https://draftwire.usatoday.com/2020/04/11/2020-nfl-mock-draft-7-rounds-updated-joe-burrow-tua-tagovailoa-justin-herbert/{}/".format(num)
  page = requests.get(url)
  soup = BeautifulSoup(page.content, 'html.parser')
  lists = soup.find_all('div', class_ = 'articleBody')
  content = str(list(lists)[0])
  content_list = content.split('')
  for c in content_list:
    if '|' in c:
      pick = int(c.split('.')[0])
      player = str(c.split(' | ')[1])
      position = str(c.split(' | ')[2])
      data.append([pick, player, position])
df = pd.DataFrame(data)
df.columns = ['Pick', 'Name', 'Position']
def getname(x):
  name = x.split(', ')
  return name[1] +' ' + name[0]
alpha = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
names = []
for letter in alpha:
  url = "https://www.footballdb.com/players/current.html?letter={}".format(letter)
  hdr = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.3',
        'Accept-Encoding': 'none',
        'Accept-Language': 'en-US,en;q=0.8',
        'Connection': 'keep-alive'}
  req = Request(url , headers=hdr)
  webpage = urlopen(req).read()
  soup = BeautifulSoup(webpage, "html.parser")
  lists = soup.find_all('div', class_ = 'tr')
  for l in lists:
    name = l.find('div', class_ = "td").text
    names.append(name)
final_name = [getname(x) for x in names]
for l in lists:
  print(l)
for l in lists:
  c = l.find('div', class_ = 'nfl-c-player-info__value').text
import string
import random
import nltk
def div_3(data_list):
    output = []
    for i in data_list:
        if i % 3 == 0:
            output.append(i)
    return output
def is_even(data_list):
    output_list = []
    for i in data_list:
        if i % 2 == 0:
            output_list.append(True)
        else:
            output_list.append(False)
    return output_list
def is_question(input_string):
    output = True
    if '?' in input_string:
        output = True
    else:
        output = False
    return output
def prepare_text(input_string):
    temp_string = input_string.lower()
    temp_string = remove_punctuation(temp_string)
    out_list = temp_string.split()
    return out_list
def remove_punctuation(input_string):
    out_string = ''
    for i in input_string:
        if i not in string.punctuation:
            out_string += i
    return out_string
def end_chat(input_list):
    if 'quit' in input_list:
        output = True
    else:
        output = False
    return output
def selector(input_list, check_list, return_list):
    output = None
    for i in input_list:
        if i in check_list:
            output = random.choice(return_list)
            break
    return output
def is_in_list(list_one, list_two):
    """Check if any element of list_one is in list_two."""
    
    for element in list_one:
        if element in list_two:
            return True
    return False

def find_in_list(list_one, list_two):
    """Find and return an element from list_one that is in list_two, or None otherwise."""
    
    for element in list_one:
        if element in list_two:
            return element
    return None
def respond_echo(input_string, number_of_echoes, spacer):
    echo_output = ''
    if input_string != None:
        for i in range(number_of_echoes):
            echo_output += input_string + spacer
    elif input_string == None:
        echo_output = None
    return echo_output
def have_a_chat():
    
    chat = True
    while chat:

        msg = input('INPUT :\t')
        out_msg = None

        question = is_question(msg)

        msg = prepare_text(msg)

        if end_chat(msg):
            out_msg = 'Bye!'
            chat = False

        if not out_msg:

            outs = []

            outs.append(selector(msg, GREETINGS_IN, GREETINGS_OUT))

            outs.append(selector(msg, COMP_IN, COMP_OUT))

            if is_in_list(msg, PEOPLE_IN):
                name = find_in_list(msg, PEOPLE_IN)
                outs.append(list_to_string([PEOPLE_NAMES[name], name.capitalize(),
                                            selector(msg, PEOPLE_IN, PEOPLE_OUT)], ' '))

            outs.append(respond_echo(selector(msg, JOKES_IN, JOKES_OUT), 3, ''))

            if is_in_list(msg, NONO_IN):
                outs.append(list_to_string([selector(msg, NONO_IN, NONO_OUT), find_in_list(msg, NONO_IN)], ' '))

            options = list(filter(None, outs))
            if options:
                out_msg = random.choice(options)

        if not out_msg and question:
            out_msg = QUESTION

        if not out_msg:
            out_msg = random.choice(UNKNOWN)

        print('OUTPUT:', out_msg)
from deck import Deck
from hand import DealerHand, PlayerHand
from card import Card
from numpy.random import randint, seed
seed(20)

class Blackjack:
    num_games = 0
    def __init__(self, wallet):

        assert type(wallet) == int or type(wallet) == float
        self.deck = Deck()
        self.wallet = wallet
        self.game_number = 1
        self.log = ''
        self.bet_amount = 5
        self.player = PlayerHand()
        self.dealer = DealerHand()
        Blackjack.num_games += 1
    
    def play_round(self, num_rounds, stand_threshold):

        assert type(num_rounds) == int and num_rounds > 0
        assert type(stand_threshold) == int and stand_threshold > 0
        self.bet_amount = 5
        while num_rounds > 0:
            if len(self.deck.cards) < 4:
                self.log += 'Not enough cards for a game.'
                self.bet_amount = 5
                return
            if self.wallet < self.bet_amount:
                self.log += 'Wallet amount ${} is less than bet amount ${}.'.format(self.wallet, self.bet_amount)
                self.bet_amount = 5
                return
            self.log += 'Round {} of Blackjack!\n'.format(self.game_number)
            self.log += 'wallet: ' + str(self.wallet) + '\n'
            self.log += 'bet: ' + str(self.bet_amount) + '\n'
            x = randint(0,5)
            y = randint(0,5)
            self.deck.shuffle(modified_overhand = y, mongean = x)
            self.deck.deal_hand(self.player)
            self.deck.deal_hand(self.dealer)
            self.deck.deal_hand(self.player)
            self.deck.deal_hand(self.dealer)
            self.log += 'Player Cards: {}\n'.format(self.player.__repr__())
            self.log += 'Dealer Cards: {}\n'.format(self.dealer.__repr__())
            self.hit_or_stand(self.player, stand_threshold)
            self.dealer.reveal_hand()
            self.log += 'Dealer Cards Revealed: {}\n'.format(self.dealer.__repr__())
            self.hit_or_stand(self.dealer, 17)
            player_score = Blackjack.calculate_score(self.player)
            dealer_score = Blackjack.calculate_score(self.dealer)
            result = self.determine_winner(player_score, dealer_score)
            if result == 1:
                self.wallet += self.bet_amount
                self.bet_amount += 5
            elif result == -1:
                self.wallet -= self.bet_amount
                self.bet_amount -= 5
            if self.bet_amount < 5:
                self.bet_amount = 5
            self.add_to_file(self.player, self.dealer, result)
            num_rounds -= 1
            self.game_number += 1
            self.player = PlayerHand()
            self.dealer = DealerHand()         
    def calculate_score(hand):

        assert type(hand) == PlayerHand or type(hand) == DealerHand
        hand_ranks = [a.rank for a in hand.cards]
        withoutA = list(filter(lambda x: True if x!= 'A' else False, hand_ranks))
        As = list(filter(lambda x: True if x == 'A' else False, hand_ranks))
        withoutA_score = sum(list(map(lambda x: x if type(x) == int else 10, withoutA))) 
        withoutA_score += sum(list(map(lambda x: 0 if len(list(x)) == 0 else 10 + len(x) if withoutA_score + 10 + len(x) <= 21 else len(x), [As])))
        return withoutA_score

    def determine_winner(self, player_score, dealer_score):

        if dealer_score == player_score or (dealer_score > 21 and player_score > 21):
            self.log += 'Player and Dealer tie.\n'
            return 0
        elif (player_score <= 21 and player_score > dealer_score) or dealer_score > 21:
            self.log += 'Player won with a score of {}. Dealer lost with a score of {}.\n'.format(player_score, dealer_score)
            return 1
        elif (dealer_score <= 21 and dealer_score > player_score) or player_score > 21:
            self.log += 'Player lost with a score of {}. Dealer won with a score of {}.\n'.format(player_score, dealer_score)
            return -1
    def hit_or_stand(self, hand, stand_threshold):

        while Blackjack.calculate_score(hand) < stand_threshold and len(self.deck.get_cards()) > 0:
            to_add = self.deck.cards[0]
            self.deck.deal_hand(hand)
            if type(hand) == PlayerHand:
                self.log += to_add.__repr__() + ' was pulled by a Player\n'
            else:
                self.log += to_add.__repr__() + ' was pulled by a Dealer\n'

    def get_log(self):
        return self.log
    
    def reset_log(self):
        self.log = ''
        
    def add_to_file(self, player_hand, dealer_hand, result):

        filename = './game_summaries/game_summary{}.txt'.format(self.num_games)
        with open(filename, 'a', encoding = 'utf-8') as f:
            f.write('ROUND {}:\n'.format(self.game_number))
            f.write('Player Hand:\n')
            f.write(player_hand.__str__() + '\n')
            f.write('Dealer Hand:\n')
            f.write(dealer_hand.__str__() + '\n')
            if result == 1:
                f.write('Winner of ROUND {}: Player\n\n'.format(self.game_number))
            elif result == -1:
                f.write('Winner of ROUND {}: Dealer\n\n'.format(self.game_number))
            else:
                f.write('Winner of ROUND {}: Tied\n\n'.format(self.game_number))
class Card:
    def __init__(self, rank, suit, visible=True):

        assert rank in [2, 3, 4, 5, 6, 7, 8, 9, 10, 'A', 'J', 'K', 'Q']
        assert suit in ['hearts', 'spades', 'clubs', 'diamonds']
        assert type(visible) == bool
        self.rank = rank
        self.suit = suit
        self.visible = visible
        
    def suit_rankings(self):
        if self.suit == 'clubs':
            return 4
        elif self.suit == 'diamonds':
            return 3
        elif self.suit == 'hearts':
            return 2
        elif self.suit == 'spades':
            return 1
    def rank_rankings(self):
        if type(self.rank) == int:
            return self.rank
        else:
            if self.rank == 'A':
                return 14
            elif self.rank == 'K':
                return 13
            elif self.rank == 'Q':
                return 12
            elif self.rank == 'J':
                return 11
    
    def __lt__(self, other_card):
        if self.rank_rankings() < other_card.rank_rankings():
            return True
        elif self.rank_rankings() > other_card.rank_rankings():
            return False
        else:
            if self.suit_rankings() < other_card.suit_rankings():
                return True
            else:
                return False

    def __str__(self):
        
        if self.suit == 'hearts':
            suit = ''
        elif self.suit == 'diamonds':
            suit = ''
        elif self.suit == 'spades':
            suit=  ''
        elif self.suit == 'clubs':
            suit = ''
        if not self.visible:
            return '____\n|?  |\n| ? |\n|__?|'
        else:
            return '____\n|{}  |\n| {} |\n|__{}|'.format(str(self.rank), \
                suit, str(self.rank))

    def __repr__(self):
        
        if not self.visible:
            return '(?, ?)'
        else:
            return '({}, {})'.format(str(self.rank), self.suit)

    def get_rank(self):
        return self.rank
    
    def get_suit(self):
        return self.suit

    def set_visible(self, visible):
        assert type(visible) == bool
        self.visible = visible
from card import Card
from hand import PlayerHand, DealerHand
from shuffle import Shuffle

class Deck:
    def __init__(self):
        
        self.cards = [Card(x,y) for x in [2,3,4,5,6,7,8,9,10,'J','Q','K','A'] \
            for y in ['spades', 'hearts', 'diamonds', 'clubs']]
    def shuffle(self, **shuffle_and_count):
        """Shuffles the deck using a variety of different shuffles.

        Parameters:
            shuffle_and_count: keyword arguments containing the
            shuffle type and the number of times the shuffled
            should be called.
        """
        assert all(isinstance(x, int) for x in shuffle_and_count.values())
        assert all([True if x == 'mongean' or x == 'modified_overhand' \
            else False for x in shuffle_and_count.keys()])
        if 'modified_overhand' in shuffle_and_count:
            self.cards = Shuffle.modified_overhand(self.cards, \
                shuffle_and_count['modified_overhand'])
        if 'mongean' in shuffle_and_count:
            for i in range(shuffle_and_count['mongean']):
                self.cards = Shuffle.mongean(self.cards)
    
    def deal_hand(self, hand):

        assert type(hand) == PlayerHand or type(hand) == DealerHand
        hand.add_card(self.cards[0])
        self.cards.pop(0)

    def get_cards(self):
        return self.cards
from card import Card

class PlayerHand():
    def __init__(self):
        self.cards = []
        
    def add_card(self, *cards):

        for card in cards:
            assert type(card) == Card
            self.cards.append(card)
        self.sort_hand()

    def get_cards(self):
        return self.cards            

    def __str__(self):

        return_str = ''
        for card in self.cards:
            return_str += card.__str__() + '\n'
        return return_str[:-1]
    
    def __repr__(self):

        return_str = ''
        for card in self.cards:
            return_str += card.__repr__() + ' '
        return return_str[:-1]

    def sort_hand(self):

        n = len(self.cards)
        for i in range(n):
            for j in range(0, n-i-1):
                if self.cards[j] > self.cards[j + 1]:
                    self.cards[j + 1], self.cards[j] = \
                    self.cards[j], self.cards[j + 1]
        
    
class DealerHand(PlayerHand):
    
    def __init__(self):

        super().__init__()
        self.hand_visible = False

    def add_card(self, *cards):

        assert all(isinstance(card, Card) for card in cards)
        if self.hand_visible == False:
            for card in cards:
                self.cards.append(card)
            for i in range(len(self.cards) - 1):
                self.cards[i + 1].set_visible(False)
        else:
            super().add_card(*cards)

    
    def reveal_hand(self):

        self.hand_visible = True
        for card in self.cards:
            card.set_visible(True)
        self.sort_hand()
class Shuffle:
    def modified_overhand(cards, num):

        if num == 0 :
            return cards
        else:
            if len(cards) % 2 == 0 and num % 2 == 1:
                top_half_take = num // 2 + 1
                bottom_half_take = num - top_half_take
                top_half_remain = len(cards) // 2 - top_half_take
                top_half = cards[0:int(len(cards) / 2)][::-1]
                bottom_half = cards[int(len(cards) / 2):]
                cards = top_half[0:top_half_take][::-1] + \
                    bottom_half[0:bottom_half_take] + \
                    top_half[::-1][0:top_half_remain] + \
                    bottom_half[bottom_half_take:]
            elif len(cards) % 2 == 1 and num % 2 == 0:
                top_half_take = num // 2 + 1
                bottom_half_take = num - top_half_take
                top_half = cards[0:int(len(cards) / 2) + 1][::-1]
                top_half_remain = len(top_half) - top_half_take
                bottom_half = cards[int(len(cards) / 2) + 1:]
                cards = top_half[0:top_half_take][::-1] + \
                    bottom_half[0:bottom_half_take] + \
                    top_half[::-1][0:top_half_remain] + \
                    bottom_half[bottom_half_take:]
            else:
                top_half = cards[0:int(len(cards) / 2 + 0.5)][::-1]
                bottom_half = cards[int(len(cards) / 2 + 0.5):]
                top_half_take = int(num / 2 + 0.5)
                top_half_remain = len(top_half) - top_half_take
                bottom_half_take = num - top_half_take
                cards = top_half[0:top_half_take][::-1] + \
                    bottom_half[0:bottom_half_take] + \
                    top_half[::-1][0:top_half_remain] + \
                    bottom_half[bottom_half_take:]
            return Shuffle.modified_overhand(cards, num - 1)

    
    def mongean(cards):

        assert type(cards) == list
        if len(cards) == 0:
            return []
        else:
            return_list = Shuffle.mongean(cards[:-1])
            if len(return_list) % 2 == 0:
                return return_list + [cards[-1]]
            else:
                return [cards[-1]] + return_list
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
train_scaled = scaler.fit_transform(train)
train_scaled = pd.DataFrame(train_scaled, columns=train.columns)
test_scaled = scaler.fit_transform(test)
test_scaled = pd.DataFrame(test_scaled, columns=test.columns)
train_log = np.log(train+ 1)
test_log = np.log(test+1)

train_disc = (train > 0).astype(int)
test_disc = (test > 0).astype(int)
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 8))

train.plot(ax=axes[0, 0], kind='hist', bins=50, title='Original Data')

train_scaled.plot(ax=axes[0, 1], kind='hist', bins=50, title='Standardized Data')

train_log.plot(ax=axes[1, 0], kind='hist', bins=50, title='Log-Transformed Data')

train_disc.plot(ax=axes[1, 1], kind='hist', bins=2, title='Discretized Data')

fig.suptitle('Visualization of Different Versions of the Data')

plt.show()
import seaborn as sns
corr_matrix = train.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Train Data')
plt.show()
corr_matrix = train_scaled.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Train Scaled Data')
plt.show()
corr_matrix = train_log.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Train Log Data')
plt.show()
corr_matrix = train_disc.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Train Discretized Data')
plt.show()
corr_matrix = test_disc.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam- Test Discretized Data')
plt.show()
corr_matrix = test_log.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Test Log Data')
plt.show()
corr_matrix = test.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Test Data')
plt.show()
corr_matrix = test_scaled.corr()
sns.heatmap(corr_matrix, cmap='coolwarm')
plt.title('Correlation Heatmap of Spam-Test Scaled Data')
plt.show()
from sklearn.linear_model import LogisticRegression
X_train_stan = train_scaled.iloc[:, :-1]
y_train = train.iloc[:, -1]
X_test_stan = test_scaled.iloc[:, :-1]
y_test = test.iloc[:, -1]

lr = LogisticRegression()
lr.fit(X_train_stan, y_train)

stanlrtrain_error = 1 - lr.score(X_train_stan, y_train)
stanlrtest_error = 1 - lr.score(X_test_stan, y_test)
print("Classification error on standardized training set:", stanlrtrain_error)
print("Classification error on standardized test set:", stanlrtest_error)
from scipy.stats import norm

p_values = lr.coef_[0]
p_values = [2 * (1 - norm.cdf(abs(x))) for x in p_values]

significant_features = [i for i in range(len(p_values)) if p_values[i] < 0.05]
print("Significant features:", significant_features)
X_train_log = train_log.iloc[:, :-1]
y_train = train.iloc[:, -1]
X_test_log = test_log.iloc[:, :-1]
y_test = test.iloc[:, -1]

lr = LogisticRegression()
lr.fit(X_train_log, y_train)

loglrtrain_error = 1 - lr.score(X_train_log, y_train)
loglrtest_error = 1 - lr.score(X_test_log, y_test)
print("Classification error on standardized training set:", loglrtrain_error)
print("Classification error on standardized test set:", loglrtest_error)
p_values = lr.coef_[0]
p_values = [2 * (1 - norm.cdf(abs(x))) for x in p_values]

significant_features = [i for i in range(len(p_values)) if p_values[i] < 0.05]
print("Significant features:", significant_features)
X_train_disc = train_disc.iloc[:, :-1]
y_train = train.iloc[:, -1]
X_test_disc = test_disc.iloc[:, :-1]
y_test = test.iloc[:, -1]

lr = LogisticRegression()
lr.fit(X_train_disc, y_train)

disclrtrain_error = 1 - lr.score(X_train_disc, y_train)
disclrtest_error = 1 - lr.score(X_test_disc, y_test)
print("Classification error on standardized training set:", disclrtrain_error)
print("Classification error on standardized test set:", disclrtest_error)
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis, QuadraticDiscriminantAnalysis
from sklearn.metrics import accuracy_score

lda = LinearDiscriminantAnalysis()
lda.fit(X_train_stan, y_train)

y_pred_train_lda = lda.predict(X_train_stan)
y_pred_test_lda = lda.predict(X_test_stan)
stantrain_error_lda = 1 - accuracy_score(y_train, y_pred_train_lda)
stantest_error_lda = 1 - accuracy_score(y_test, y_pred_test_lda)

qda = QuadraticDiscriminantAnalysis()
qda.fit(X_train_stan, y_train)

y_pred_train_qda = qda.predict(X_train_stan)
y_pred_test_qda = qda.predict(X_test_stan)
stantrain_error_qda = 1 - accuracy_score(y_train, y_pred_train_qda)
stantest_error_qda = 1 - accuracy_score(y_test, y_pred_test_qda)

print("Linear Discriminant Analysis:")
print(f"Training error: {stantrain_error_lda:.4f}")
print(f"Test error: {stantest_error_lda:.4f}\n")
print("Quadratic Discriminant Analysis:")
print(f"Training error: {stantrain_error_qda:.4f}")
print(f"Test error: {stantest_error_qda:.4f}")
from sklearn.ensemble import AdaBoostClassifier
train = pd.read_csv('https://mathweb.ucsd.edu/~wez243/spam-train.txt', sep = ',', header=None)
test = pd.read_csv('https://mathweb.ucsd.edu/~wez243/spam-test.txt', sep = ',', header = None)
train_log = np.log(train+ 1)
test_log = np.log(test+1)
X_train_log = train_log.iloc[:, :-1]
y_train = train.iloc[:, -1]
X_test_log = test_log.iloc[:, :-1]
y_test = test.iloc[:, -1]

ensemble_clf = AdaBoostClassifier(
    estimator=RandomForestClassifier(),
)
ensemble_clf.fit(X_train_log, y_train)

ypredtrain = ensemble_clf.predict(X_train_log)
ypredtest = ensemble_clf.predict(X_test_log)
train_error = 1 - accuracy_score(y_train, ypredtrain)
test_error = 1 - accuracy_score(y_test, ypredtest)

print("AdaBoost Classifier for RF:")
print(f"Training error: {train_error:.4f}")
print(f"Test error: {test_error:.4f}")
def name_scramble(fname, lname):
    fname_reverse = fname[::-1]
    scrambled_name = ""
    x = 0
    while x < len(fname_reverse):
        scrambled_name = scrambled_name + fname_reverse[x]
        x = x + 2
    y = 0
    while y < len(lname):
        scrambled_name = scrambled_name + lname[y]
        y = y + 3
    return scrambled_name
def close_to_25(age1, age2):
    
    if age1 <= 25 and age2 <= 25:
        return max(age1, age2)
    elif age1 > 25 and age2 < 25:
        return age2
    elif age1 < 25 and age2 > 25:
        return age1
    else:
        return 'we are good to go!'    

def main_driver(name1, name2, name3):
    
    return_name = ""
    list_of_name = [name1, name2, name3]
    for names in list_of_name:
        if len(names) >= len(return_name):
            return_name = names
        else:
            return_name = return_name
    return return_name


def helper_distance(lst, x2, y2):
   
    return ((x2 - lst[0]) ** (2) + (y2 - lst[1]) ** (2)) ** (1/2)

def all_distances(coordinates, x_coord, y_coord, threshold):
   
    drivable = []
    for places in coordinates:
        distance = helper_distance(places, x_coord, y_coord)
        if distance <= threshold:
            drivable.append(places)
        else:
            drivable = drivable
    return drivable


def places_names(coordinates, x_coord, y_coord, threshold, names):
   
    available_places = all_distances(coordinates, x_coord, y_coord, threshold) 
    name_of_places = []
    for coords in available_places:
        name_of_places.append(names[coordinates.index(coords)])
    return name_of_places


def message(i_name, dow, time, c_name):
    
    invitation = "Dear " + i_name + ",\n" + "Please join our meeting on " \
    + dow + " at " + time + ".\n\nTeam captain: " + c_name
    return invitation

def seat_number(lst):
    
    seat_number = []
    for names in lst:
        if len(names) in seat_number:
            seat_number.append("taken")
        else:
            seat_number.append(len(names))
    return seat_number


def suv_vs_minivan(names):
    
    suv_counter = names.count('SUV')
    minivan_counter = names.count('Minivan')
    if suv_counter > minivan_counter:
        return True
    else:
        return False
    

def age_average(lst):
    
    if len(lst) == 0:
        return '0.0'
    else:
        total_age = 0
        for age in lst:
            total_age = total_age + int(age)
        average = round(total_age/len(lst), 1)
    return str(average)


def split_teams(lst, captain):
    
    first_list = [captain]
    second_list = []
    i = 0
    while i < len(lst):
        first_list.append(lst[i])
        i = i + 2
    j = 1
    while j < len(lst):
        second_list.append(lst[j])
        j = j + 2
    second_list.append(captain)
    list_as_tuple = first_list, second_list
    return list_as_tuple
def combine(states, nicknames):
    
    return_list = []
    for i in range(len(nicknames)):
        if i < len(states):
            return_list.append((states[i], nicknames[i]))
        elif i >= len(states):
            return_list.append(('NO STATE PROVIDED', nicknames[i]))
    return return_list

def dict_of_states(tuples):
    
    return_dict = {}
    for states in tuples:
        state_abbrv = states[0]
        if state_abbrv not in return_dict:
            return_dict[state_abbrv] = [states[1]]
        elif state_abbrv in return_dict:
            nickname_list = return_dict.get(state_abbrv)
            nickname_list.append(states[1])
            return_dict[state_abbrv] = nickname_list
    return return_dict

def gambling_in_vegas(profit_history):
    
    return_dict = {}
    if len(profit_history) == 0:
        return {'1': 0, '2': 0, '3': 0}
    for lists in profit_history:
        if len(lists) == 0 and len(return_dict) == 0:
            return_dict['1'] = 0
            return_dict['2'] = 0
            return_dict['3'] = 0
        elif len(lists) == 0 and len(return_dict) != 0:
            return_dict = return_dict
        else:
            for i in range(len(lists)):
                slot_machine = str(i + 1)
                if slot_machine not in return_dict:
                    return_dict[slot_machine] = lists[i]
                elif slot_machine in return_dict:
                    profit = return_dict.get(slot_machine) + lists[i]
                    return_dict[slot_machine] = profit
    return return_dict

def luck_mechanism(records):
    
    return_dict = records
    history = list(records.values())
    third_in_list = 2
    if history[0] > 0 or history[1] > 0 or history[third_in_list] > 0:
        luck = -2
    else:
        luck = 0.001 * abs(history[0]) + 0.002 * abs(history[1]) + \
        min(0.005 * abs(500 - abs(history[2])), 0.003 * \
        abs(history[third_in_list])) - 2
    if luck > 0:
        return_dict['luck'] = 'You are Lucky'
    elif luck == 0:
        return_dict['luck'] = 'Fair game'
    elif luck < 0:
        return_dict['luck'] = 'Not this time'
    return return_dict

def smaller_collection(collections):
    
    all_list = []
    for keys in collections:
        all_items = collections.get(keys)
        for items in all_items:
            if items in all_list:
                all_list = all_list
            else:
                all_list.append(items)
    return all_list

def count_lines_1(filepath):
    
    with open(filepath) as f:
        count = 0
        for line in f:
            count = count + 1
    return count    


def count_lines_2(filepath):
    
    with open(filepath) as f:
        read_data = f.read()
        count = len(read_data.split('\n'))
    return count

def count_lines_3(filepath):
    
    with open(filepath) as f:
        lines = f.readlines()
        count = len(lines)
    return count

def items_only(filepath):
    
    first = []
    with open(filepath) as f:
        lines = f.readlines()
        for i in range(len(lines)):
            lines[i] = lines[i].strip('\n')
            if len(lines[i]) == 0:
                first = first
            else:
                item_index = 2
                first.append((lines[i].split(','))[item_index])
    return first

def case_letters(filepath):
    
    with open(filepath, 'w') as f:
        count_upper = 0
        count_lower = 0
        for i in filepath:
            if i.isupper():
                count_upper += 1
            if i.islower():
                count_lower += 1
        f.write(str(count_upper) + '\n')
        f.write(str(count_lower))
    return None

def map_age(filepath):
    
    with open(filepath) as f:
        lines = f.readlines()
        first_age_limit = 14
        second_age_limit = 15
        third_age_limit = 19
        for i in range(len(lines)):
            lines[i] = int(lines[i].strip('\n'))
        with open('files/mappings.txt', 'a') as m:
            for age in lines: 
                if age < 0:
                    m.write('not a valid age' + '\n')
                elif age <= first_age_limit:
                    m.write('kid' + '\n')
                elif age <= third_age_limit:
                    m.write('teenager' + '\n')
                else: 
                    m.write('adult' + '\n')
    return sum(lines)

def correctness():

    assert_needed = [2, 2, 4]
    return assert_needed

def operate_nums(lst):
    
    triple = 3
    double = 2
    assert type(lst) == list
    assert all([isinstance(number, int) for number in lst])
    return [value * triple if value % double == 0 else \
    value * double for value in lst]


def string_lengths(text, nums):
    
    assert all([isinstance(letter, str) for letter in text])
    assert all([isinstance(number, int) for number in nums])
    assert type(text) == list and type(nums) == list
    assert len(text) == len(nums)
    assert all(len(letter) > 0 for letter in text)
    assert all(number >= 0 for number in nums)
    return [True if len(text[i]) > nums[i] else False \
    for i in range(len(text))]


def process_dict(input_dict):

    assert type(input_dict) == dict
    assert all([isinstance(keys, tuple) for keys in list(input_dict.keys())])
    assert all([isinstance(values, str) for keys in list(input_dict.keys()) \
    for values in input_dict.get(keys)])
    assert all([isinstance(values, list) for values in \
    list(input_dict.values())])
    return [len(list(input_dict.keys())[i]) + sum([len(words) for words in \
    list(input_dict.values())[i]]) for i in range(len(input_dict))]


def union(str1, str2):
    
    assert type(str1) == str and type(str2) == str
    assert str1.isalnum() and str2.isalnum()
    return "".join([str1[i] if str1[i] != str2[i] else '' \
    for i in range(min(len(str1), len(str2)))] + \
    [str1[i] for i in range(min(len(str1), len(str2)), len(str1))] + \
    [str2[i] if str1[i] != str2[i] else '' \
    for i in range(min(len(str1), len(str2)))] + \
    [str2[i] for i in range(min(len(str1), len(str2)), len(str2))])


def decode(to_decode):
    
    assert all(isinstance(word, str) for word in to_decode) and \
    type(to_decode) == list
    double = 2
    return ["".join([to_decode[list_position][string_position].upper() \
    if to_decode[list_position][string_position] in \
    ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'] \
    else "" if to_decode[list_position][string_position].isdigit() \
    else to_decode[list_position][string_position].lower() \
    for string_position in range(len(to_decode[list_position]))] + \
    [str(int(to_decode[list_position][string_position]) * double) \
    if to_decode[list_position][string_position].isdigit() \
    else "" for string_position in range(len(to_decode[list_position]))]) \
     for list_position in range(len(to_decode))]


def rotate_matrix(matrix):
    
    assert all(isinstance(value[i], int) \
    for value in matrix for i in range(len(matrix[0])))
    return [[matrix[j][i] for j in range(len(matrix) - 1, -1, -1)] \
    for i in range(len(matrix[0]))]

def cheapest_gas(gas_stations, mileage):
    
    lst1 = [(gas_stations.get(stations)[i][1], stations) \
    for stations in gas_stations \
    for i in range(len(gas_stations.get(stations))) \
    if gas_stations.get(stations)[i][0] <= mileage]
    return min(lst1)[1]


def cheapest_average_gas(gas_stations, mileage):
    
    return min([(sum([gas_stations.get(stations)[i][1] \
    for i in range(len(gas_stations.get(stations))) \
    if gas_stations.get(stations)[i][0] <=mileage])/len(\
    [gas_stations.get(stations)[i][1] \
    for i in range(len(gas_stations.get(stations))) \
    if gas_stations.get(stations)[i][0] <=mileage]), stations) \
    for stations in gas_stations if len([gas_stations.get(stations)[i][1] \
    for i in range(len(gas_stations.get(stations))) \
    if gas_stations.get(stations)[i][0] <=mileage]) != 0])[1]


def session_money(lst, operations):
    
    commands = {
        'add': lambda lst, amount: [x + amount for x in lst], 
        'lose': lambda lst, amount: [x - amount for x in lst], 
        'combine': lambda lst, k: [sum([lst[i] for i in range(j, j + k)]) \
        for j in range(len(lst)) if j < len(lst) - k + 1], 
        'first': lambda lst, k: [int(str(lst[i])[0:k]) \
        for i in range(len(lst))], 
        'reduce_last': lambda lst, k: [[lst[i] if i < len(lst) - k \
        else sum([lst[i] for i in range(i, len(lst))]) \
        for i in range(len(lst) - k + 1)] if k !=0 else lst][0], 
        'last': lambda lst, k: [int(str(lst[i])) if k >= len(str(lst[i])) \
        else int((str(lst[i])[len(str(lst[i])) - k::])) \
        for i in range(len(lst))]}
    return_list = lst
    for i in range(len(operations)):
        return_list = commands[operations[i][0]](return_list, operations[i][1])
    return return_list


def champion_filter(names, categories):
    
    assert all(isinstance(name, str) for name in names)
    assert all(isinstance(category, str) for category in categories)
    assert len(names) == len(categories)
    assert type(names) == list and type(categories) == list
    return list(filter(lambda x: x != 'N/A', list(map(lambda name, category: \
    (name, category) if category in ['Fighter', 'Marksman', 'Mage'] \
    else 'N/A', names, categories))))


def select_items(combinations):
    
    base = 50
    combinations = list(map(lambda x: x if len(x) <= 6 else {}, combinations))
    sorting = lambda items: (base + sum(list(map(lambda AP: items.get(AP), \
    list(filter(lambda name: name if 'AP' in name and 'shoe' \
    not in name else False, items))))), items)
    reversed = max(list(map(sorting, combinations)))
    return (reversed[1], reversed[0])


def calculate_experience(scores):
    
    assert type(scores) == list
    assert all(isinstance(x, list) for x in scores)
    assert all(isinstance(j, int) for x in scores for j in x)
    assert all(len(x) == 4 for x in scores)
    k1, k2, k3 = 100, 250, 5
    d1 = -25
    a1, a2, a3 = 30, 50, 40
    g1 = 0.1
    k, d, a, g = 0, 1, 2, 3
    kill = lambda kills: kills * k1 + (kills // k3) * k2
    death = lambda deaths: deaths * d1
    assist = lambda assists, kills: a1 * assists if kills > assists \
    else a2 * assists if kills < assists else a3 * assists    
    gold = lambda golds: round(golds * g1)
    orig_xp = list(map(lambda z: kill(z[k]) + death(z[d]) + \
    assist(z[a], z[k]) + gold(z[g]), scores))
    return list(map(lambda w: w if w >= 0 else 0, orig_xp))

def calculate_level(scores, level):
    
    xp = sum(calculate_experience(scores))
    base = 2000
    level_up = 200
    threshold = base + level_up * (level - 1)
    return_level = level
    while xp > threshold:
        return_level += 1
        threshold += level_up
        xp -= threshold

def round_up(x, y):
   
    if x % y == 0:
        return x // y
    else:
        return (x // y) + 1


def number_of_trainers_1(lst, level = 20):
   
    size = 5
    return round_up(len([x for x in lst if x <= level]), size)


def number_of_trainers_2(*args):
   
    level = 20
    size = 5
    return round_up(len([x for x in args if x <= level]), size)


def number_of_trainers_3(*args, level = 20):
    
    size = 5
    return round_up(len([x for x in args if x <= level]), size)


def guild_trip(level_limit, **kwargs):
   
    return {k: number_of_trainers_1(i, level_limit) for \
    (k,i) in kwargs.items()}


def swap_values(*args, **kwargs):
    
    assert len(args) == len(kwargs)
    return [('positional_' + str(x[0]), x[1]) for x in \
    list(enumerate(kwargs.values()))] + [('keyword_' + \
    str(list(enumerate(args))[i][0]) + "_" + \
    list(kwargs.keys())[i], args[i]) for i in \
    range(len(list(enumerate(args))))]


def pokemon_comp(**kwargs):
    
    aggron_attack = 10
    alcremie_attack = 3
    bagon_attack = 5
    bayleef_attack = 4
    happiny_attack = 2
    pikachu_attack = 4
    quagsire_attack = 7
    zapdos_attack = 11
    attack_values = {'Aggron': aggron_attack, 'Alcremie': alcremie_attack,\
        'Bagon': bagon_attack, 'Bayleef': bayleef_attack, 'Happiny': \
        happiny_attack, 'Pikachu': pikachu_attack, 'Quagsire': \
        quagsire_attack, 'Zapdos': zapdos_attack}
    pokemon_and_attack = list(kwargs.items())
    squared = 2
    energy = [pokemon_and_attack[i][1] * attack_values.get(pokemon_and_attack \
    [i][0]) + len(pokemon_and_attack[i][0]) ** squared \
    for i in range(len(pokemon_and_attack))]
    def inner(x):
        """
        if sum of energy > x, print the highest energy and return the
        pokemon's name
        if sum of energy < x, print the lowest energy and return the pokemon's 
        name
        if sum of energy = x, return average of energy list
        """
        if sum(energy) > x:
            print(max(energy))
            return list(kwargs.keys())[energy.index(max(energy))]
        elif sum(energy) < x:
            print(min(energy))
            return list(kwargs.keys())[energy.index(min(energy))]
        else:
            return int(sum(energy) / len(energy))
    return inner

def next_move(file_names, row, col):
    
    with open(file_names) as f:
        second_person = 2
        lines = []
        for i in f:
            lines.append(i.strip())
        newline = []
        for i in lines:
            newline.append(i.split(','))
        remaining = []
        for i in newline:
            for l in i:
                if l not in remaining:
                    remaining.append(l)
        original_length = len(remaining)
        to_remove = [newline[row - 1][col - 1]]
        newline = newline[row - 1:] + newline[0:row - 1]
        no_remove = []
        while len(to_remove) > 0:
            for i in newline:
                if to_remove[0] in i and to_remove[0] not in no_remove:
                    if i.index(to_remove[0]) == 1:
                        to_remove.append(i[second_person])
                    elif i.index(to_remove[0]) == 0:
                        no_remove.append(i[1])
                        no_remove.append(i[second_person])
                    elif i.index(to_remove[0]) == second_person:
                        no_remove.append(i[0])
                        no_remove.append(i[1])
            remaining.remove(to_remove[0])
            to_remove.remove(to_remove[0])
            newline.remove(i)
        new_length = len(remaining)
    def inner(stats):

        if stats == True:
            convert_to_percent = 100
            return int(convert_to_percent * new_length / original_length)
        else:
            odd_checker = 2
            if new_length % odd_checker == 1:
                return 'odd'
            else:
                return 'even'
    return inner
     
def message_enc(filepath):
    
    with open(filepath) as f:
        lines = []
        for i in f:
            lines.append(i.strip())
        new_dict = {}
        for line in lines:
            for letter in line:
                if letter != ' ':
                    if letter not in new_dict:
                        new_dict[letter] = 1
                    else:
                        new_dict[letter] += 1 
        sorted_dict = dict(sorted(new_dict.items(), key = lambda item:\
        item[1]))
        reverse_sorted = {}
        for k, v in sorted_dict.items():
            if v not in reverse_sorted:
                reverse_sorted[v] = [k]
            else:
                reverse_sorted[v] = reverse_sorted[v] + [k]
    def inner(i, outfile):

        replace_list = []
        for letters in reverse_sorted.values():
            replace_list = replace_list + sorted(letters)
        half = 0.5
        assert i <= half * len(replace_list)
        while i > 0:
            to_replace1 = replace_list[i - 1]
            to_replace2 = replace_list[len(replace_list) - i]
            for line in lines:
                line_copy = list(line)
                to_replace1_index = []
                to_replace2_index = []
                for j in range(len(line)):
                    if line[j] == to_replace1:
                        to_replace1_index.append(j)
                    elif line[j] == to_replace2:
                        to_replace2_index.append(j)
                for letter_index in to_replace1_index:
                    line_copy[letter_index] = to_replace2
                for letter_index in to_replace2_index:
                    line_copy[letter_index] = to_replace1
                return_str = ""
                for letters in line_copy:
                    return_str = return_str + letters
                lines[lines.index(line)] = return_str
            i -= 1
        for j in range(len(lines)):
            if j != len(lines) - 1 and "\n" not in lines[j]:
                lines[j] = lines[j] + "\n"
            else:
                lines[j] = lines[j]
        with open(outfile, 'w') as f:
            for line in lines:
                f.write(line)
    return inner


def complexity_mc():

    return [3, 4, 6, 5, 3, 6, 2, 6, 3, 3]


def candy_num(bag, fav):
    
    if len(bag) == 0:
        return 0
    else:
        if fav.count(bag[0]) > 0:
            return 1 + candy_num(bag[1:], fav)
        else:
            return 0 + candy_num(bag[1:], fav)
    

def count_left_path(left, right):
   
    if len(left) == 0 or len(right) == 0:
        return 0
    else:
        if left[0] > right[0]:
            return 1 + count_left_path(left[1:], right[1:])
        else:
            return 0 + count_left_path(left[1:], right[1:])


def generate_passcode(string):
    
    if string.count(' ') == 0:
        return str(len(string))
    else:
        position = string.find(' ')
        return str(len(string[0:position])) + \
        generate_passcode(string[position + 1:])
    


def pumpkin_to_friend(bag, num):
    
    if len(bag) < num:
        return []
    else:
        return [sum(bag[0:num])] + pumpkin_to_friend(bag[num:], num)


def expand_formula(compressed_form):
   
    if compressed_form.count('}') == 1:
        index = compressed_form.find('}')
        string = compressed_form[0:index]
        print_list = string.split('{')
        return int(print_list[0]) * print_list[1]
    elif compressed_form.count('}') == 0:
        return ''
    else:
        index = compressed_form.find('}')
        string = compressed_form[0:index]
        print_list = string.split('{')
        return int(print_list[0]) * print_list[1] + \
        expand_formula(compressed_form[index + 1:])


def multiply(chars, nums):
   
    double = 2
    if len(chars) == 0:
        return ''
    if nums[0] % double == 1:
        return chars[0] * nums[0] + multiply(chars[1:], nums[1:]) + \
        chars[0] * nums[0]
    else:
        return  chars[0] * (nums[0] // double) + \
        multiply(chars[1:], nums[1:]) + chars[0] * (nums[0] // double)
    

def maze(coord, map):
    
    x_coord = coord[0]
    y_coord = coord[1]
    if map[x_coord][y_coord] == "*":
        return 'treasure!'
    elif map[x_coord][y_coord] == ".":
        return 'sad'
    elif map[x_coord][y_coord] == "R":
        y_coord += 1
        return maze((x_coord, y_coord), map)
    elif map[x_coord][y_coord] == "L":
        y_coord -= 1
        return maze((x_coord, y_coord), map)
    elif map[x_coord][y_coord] == "U":
        x_coord -= 1
        return maze((x_coord, y_coord), map)
    elif map[x_coord][y_coord] == "D":
        x_coord += 1
        return maze((x_coord, y_coord), map)

def count_substring(s, first, last):
   
    if len(s) == 0:
        return 0
    elif len(s) == 1 and first == last and first == s:
        return 1
    elif len(s) == 1 and first != last:
        return 0
    elif s[0] == first and s[-1] == last:
        return 1 + count_substring(s[1:], first, last) + \
        count_substring(s[:-1], first, last) - \
        count_substring(s[1:-1], first, last)
    elif s[0] != first or s[-1] != last:
        return 0 + count_substring(s[1:], first, last) + \
        count_substring(s[:-1], first, last) - \
        count_substring(s[1:-1], first, last)


def lutee_reproduction(months):
   
    if months == 1:       
        starting_value = 2
        return starting_value
    if months == 0:
        return 0
    else:
        previous_months = 2
        return lutee_reproduction(months - 1) + \
        lutee_reproduction(months - previous_months)


class Website:
   
    server = "DNS"

    def __init__(self, name, url, has_audio, num_clicks, \
    browser_compatibility):
       
        assert type(name) == str and len(name) != 0
        assert type(url) == str and len(url) != 0
        two = 2
        assert len(url.split('.')) >= two and \
        len(url.split('.')[len(url.split('.')) - 1]) >= two
        assert type(has_audio) == bool
        assert type(num_clicks) == int
        assert type(browser_compatibility) == list
        self.name = name
        self.url = url
        self.has_audio = has_audio
        self.num_clicks = num_clicks
        self.browser_compatibility = browser_compatibility

    def get_name(self):
        return self.name

    def get_url(self):
        return self.url

    def get_has_audio(self):
        return self.has_audio

    def get_num_clicks(self):
        return self.num_clicks

    def get_browser_compatibility(self):
        return self.browser_compatibility

    def __str__(self):
        return self.get_name() + ' linked at ' +  self.get_url() + ' is \
available on ' + str(self.get_browser_compatibility()) + " \
platforms. It's been interacted with " + str(self.get_num_clicks \
        ()) + ' times already!'

    def click(self, user):

        self.num_clicks += 1
        return user + ' interacted with ' + self.get_name() + ' at ' + \
            self.get_url()

    def add_to_browser(self, browser):

        assert type(browser) == Browser
        if browser.open_tab(self):
            return True
        else:
            return False

    def check_browser_compatibility(self, browser):
        
        if browser.get_name() in self.get_browser_compatibility():
            return True
        else:
            return False

    def refresh(self):

        self.num_clicks = 0
        return 'refreshed!'

    def play_audio(self):

        if self.get_has_audio() == True:
            return 'doo da do!'
        else:
            return 'no audio.'

        
class Browser:


    def __init__(self, name, user):
       
        assert type(name) == str and len(name) > 0
        assert type(user) == str and len(user) > 0
        self.name = name
        self.user = user
        self.num_tabs = 0
        self.websites = []
        self.history = []

    def get_name(self):
        return self.name

    def get_user(self):
        return self.user

    def get_num_tabs(self):
        return self.num_tabs

    def get_history(self):
        return self.history

    def get_websites(self):
        return self.websites

    def __str__(self):
        return 'Browser ' + self.get_name() + ' opened by ' + self.get_user() + ' has ' + str(self.get_num_tabs()) + ' tabs open.'

    def open_tab(self, website):

        assert type(website) == Website
        if self.get_name() in website.get_browser_compatibility():
            self.num_tabs += 1
            self.websites += [website]
            self.history += [website]
            return True
        else:
            return False

    def close_tab(self, website):

        assert type(website) == Website
        if website in self.get_websites():
            self.num_tabs = self.num_tabs - 1
            if len(self.websites) == 1:
                self.websites = []
            else:
                self.get_websites().remove(website)
            return True
        else:
            return False

    def clear_history(self, n):

        assert n > 0
        if n > len(self.get_history()):
            return False
        else:
            for i in range(n):
                self.get_history().pop(0)
            return True

    def get_total_clicks(self):
        return sum([web.get_num_clicks() for web in self.get_websites()])

    def interact_all(self):

        if len(self.get_websites()) > 0:
            return_str = ''
            for web in self.get_websites():
                return_str += web.click(self.user) + '\n'
            return_str2 = return_str.replace('interacted with', 'Clicked on')
            return return_str2[:-1]
        else:
            return 'Empty'
    def combine_windows(self, other_browser):

        assert type(other_browser) == Browser
        to_add = [x for x in other_browser.get_websites() \
        if x.check_browser_compatibility(self)]
        self.num_tabs += len(to_add)
        self.history += to_add
        self.websites += to_add
        if len(to_add) == len(other_browser.get_websites()):
            return True
        else:
            return len(to_add)


class DoggyCare:
    
    def __init__(self, dogs):
        self.dogs = dict(sorted(dogs.items(), key = lambda item: item[1]))
    def __repr__(self):
        return str(self.dogs)
    def __str__(self):
        threshold = 30
        if len(self.dogs) == 0:
            return 'NO DOGS TODAY, HAVE A REST!'
        if list(self.dogs.values())[0] > threshold:
            return 'No dogs to feed yet!'
        else:
            return 'Need to add more food for ' + list(self.dogs.keys())[0] +\
            '! ' + str(list(self.dogs.values())[0]) + \
            ' percent of fullness for ' + list(self.dogs.keys())[0] + ' now.'
    def __eq__(self, other):
        self_count = 0
        other_count = 0
        self_amount = 0
        other_amount = 0
        hungry = 30
        difference_threshold = 20
        for i in self.dogs.values():
            if i < hungry:
                self_count += 1
                self_amount += hungry - i
        for i in other.dogs.values():
            if i < hungry:
                other_count += 1
                other_amount += hungry - i
        if self_count != other_count:
            return False
        if abs(self_amount - other_amount) >= difference_threshold:
            return False
        return True
    def __add__(self, other):
        full = 100
        return_dog = DoggyCare(self.dogs)
        for i in range(len(other.dogs.keys())):
            name = list(other.dogs.keys())[i]
            if name in self.dogs:
                return_dog.dogs[name] += other.dogs[name]
                if return_dog.dogs[name] > full:
                    return_dog.dogs[name] = full
            else:
                return_dog.dogs[name] = other.dogs[name]
        return return_dog

class Order:
    
    def __init__(self, name, calories):

        self.name = name
        self.calories = calories
    
    def get_calories_per_object(self):
        return self.calories

    def __eq__(self, other_order):
        if self.get_calories_per_object() == \
        other_order.get_calories_per_object():
            return True
        else:
            return False        

    def __ne__(self, other_order):
        if self.get_calories_per_object() != \
        other_order.get_calories_per_object():
            return True
        else:
            return False    

    def __gt__(self, other_order):
        if self.get_calories_per_object() > \
        other_order.get_calories_per_object():
            return True
        else:
            return False 

    def __ge__(self, other_order):
        if self.get_calories_per_object() >= \
        other_order.get_calories_per_object():
            return True
        else:
            return False 

    def __lt__(self, other_order):
        if self.get_calories_per_object() < \
        other_order.get_calories_per_object():
            return True
        else:
            return False

    def __le__(self, other_order):
        if self.get_calories_per_object() <= \
        other_order.get_calories_per_object():
            return True
        else:
            return False


    def __repr__(self):

        class_name = self.__class__.__name__
        return class_name + ': ' + self.name
        

class Base(Order):

    def __init__(self, name, volume, calories, ice_level):
        super().__init__(name, calories)
        self.volume = volume
        self.ice_level = ice_level

    def get_calories_per_object(self):
        return self.volume * self.calories - self.ice_level
    
    def __str__(self):

        return str(self.volume) + ' liter of ' + self.name + ' with ' + \
        str(self.calories) + ' calories per liter and ' + \
        str(self.ice_level) + ' ice level'

class Topping(Order):

    def __init__(self, name, calories, sweetness):
        super().__init__(name, calories)
        self.sweetness = sweetness
    def get_calories_per_object(self):

        return self.calories * self.sweetness
    
    def __str__(self):

        return self.__class__.__name__+ ' ' + self.name + ': ' + \
        str(self.calories) + ' calories with sweetness level of ' + \
        str(self.sweetness)

class Beverage:
    
    def __init__(self, name, bases, toppings):
        self.name = name
        self.bases = bases
        self.toppings = toppings

    def get_total_calories(self):
        total = 0
        for i in self.bases:
            total += i.get_calories_per_object()
        for j in self.toppings:
            total += j.get_calories_per_object()
        return total
       
    
    def __eq__(self, other_order):
        if self.get_total_calories() == other_order.get_total_calories():
            return True
        else:
            return False     

    def __ne__(self, other_order):    
        if self.get_total_calories() != other_order.get_total_calories():
            return True
        else:
            return False     

    def __gt__(self, other_order):
        if self.get_total_calories() > other_order.get_total_calories():
            return True
        else:
            return False     

    def __ge__(self, other_order):
        if self.get_total_calories() >= other_order.get_total_calories():
            return True
        else:
            return False     

    def __lt__(self, other_order):
        if self.get_total_calories() < other_order.get_total_calories():
            return True
        else:
            return False     

    def __le__(self, other_order):
        if self.get_total_calories() <= other_order.get_total_calories():
            return True
        else:
            return False     

    def __add__(self, other_order):

        new_bev = Beverage('', [], [])
        new_bev.name = self.name + ' ' + other_order.name
        new_bases = []
        new_toppings = []
        current_bases = [base.name.lower() for base in self.bases]
        current_toppings = [topping.name.lower() for topping in self.toppings]
        for i in other_order.bases:
            other_copy = Base(i.name, i.volume, i.calories, i.ice_level)
            if other_copy.name.lower() in current_bases:
                for j in self.bases:
                    self_copy = Base(j.name, j.volume, j.calories, j.ice_level)
                    if other_copy.name.lower() == self_copy.name.lower():
                        self_copy.volume += other_copy.volume
                        self_copy.calories = max(self_copy.calories, \
                        other_copy.calories)
                        self_copy.ice_level = max(self_copy.ice_level, \
                        other_copy.ice_level)
                        new_bases += [self_copy]
                current_bases.remove(other_copy.name.lower())
            else:
                new_bases += [other_copy]
        for i in self.bases:
            if i.name.lower() in current_bases:
                new_bases = [i] + new_bases
        for i in other_order.toppings:
            other_copy = Topping(i.name, i.calories, i.sweetness)
            if other_copy.name.lower() in current_toppings:
                for j in self.toppings:
                    self_copy = Topping(j.name, j.calories, j.sweetness)
                    if other_copy.name.lower() == self_copy.name.lower():
                        self_copy.sweetness += other_copy.sweetness
                        self_copy.calories = max(self_copy.calories, other_copy.calories)
                        new_toppings += [self_copy]
                current_toppings.remove(other_copy.name.lower())
            else:
                new_toppings += [other_copy]
        for i in self.toppings:
            if i.name.lower() in current_toppings:
                new_toppings = [i] + new_toppings
        new_bev.bases = new_bases
        new_bev.toppings = new_toppings
        return new_bev
             
    def __str__(self):
        return self.__class__.__name__ + ': ' + self.name
      
    def __repr__(self):
        return_str = 'Bases:' + '\n'
        for i in self.bases:
            return_str += i.__str__() + '\n'
        if return_str[-1] != '\n':
            return_str += '\n'
        return_str += 'Toppings:\n'
        for j in self.toppings:
            if j != self.toppings[-1]:
                return_str += j.__str__() + '\n'
            else:
                return_str += j.__str__()
        if self.bases == [] and self.toppings == []:
            return_str = 'Bases:\n\n' + 'Toppings:\n'
            return return_str
        else:
            return return_str
      

def check_brackets(string):
   
    """
    if len(string) == 0:
        return True
    else:
        if (string[0], string[-1]) in [('(', ')'), ('{', '}'), ('[', ']')]:
            return check_brackets(string[1:-1])
        else:
            return False

def fix_concat_str(lst1, lst2):

    out = []
    for str2 in lst2:
        for str1 in lst1:
            try:
                out.append(str1 + str2)
            except:
                continue  # add try-except block
    return out


def fix_open_file(*filepaths):
    
    for filepath in filepaths:
        try:
            cur_file = open(filepath, "r")
            print(filepath + ' opened successfully') # add try-except block
            cur_file.close()
        except:
            print(filepath + ' not found')


def fix_add_backwards(lst):
    
    sum_of_pairs = []
    for i in range(len(lst) + 1):
        try:
            sum_of_pairs.append(lst[i] + lst[i - 1]) # add try-except block
        except Exception as e:
            print(type(e))
    return sum_of_pairs


def check_inputs(input1, input2):
    
    if type(input1) != str:
        raise TypeError('input1 is not the correct type')
    for i in range(len(input1)):
        if input1[i].islower() == False:
            raise TypeError('The element at index ' + str(i) + \
                ' is not lowercase letter')
    if type(input2) != list:
        raise TypeError('input2 is not the correct type')
    if input1 not in input2:
        raise TypeError('input1 not in input2')
    else:
        return 'Input validated'
    


def load_file(filepaths):
    
    if type(filepaths) != list:
        raise TypeError('filepaths is not a list')
    for i in range(len(filepaths)):
        if type(filepaths[i]) != str:
            raise TypeError('The filepath at index ' + str(i) + \
            ' is not a string')
    for i in range(len(filepaths)):
        try:
             f = open(filepaths[i], "r")
             f.close()
        except:
            raise FileNotFoundError('The filepath at index ' + str(i) + \
                ' does not exist')
    count = 0
    for i in range(len(filepaths)):
        with open(filepaths[i]) as f:
            lines = f.readlines()
            if len(lines) == 0:
                raise ValueError('The filepath at index ' + str(i) + \
                    ' is empty or contain non-alphabets')
            for j in lines:
                if '\n' in j:
                    j = j.replace('\n', '')
                content = j.split(' ')
                for word in content:
                    if word.isalpha() == False:
                        raise ValueError('The filepath at index ' + str(i) + \
                            ' is empty or contain non-alphabets')
                count += len(content)
    return count


from util import Stack, Queue

def is_duplicated(expression):
   
    stk = Stack()
    duplicate = 0
    value = False
    check1 = False
    check2 = False
    for i in expression:
        if i == '(' or i == ')':
            stk.push(i)
            value = False
        else:
            if not value:
                stk.push(i)
            value = True
    count = stk.num_items
    for i in range(count):
        if duplicate == 0:
            check1 = False
        if stk.peek() == ')':
            duplicate += 1
            stk.pop()
            value = False
        elif stk.peek() == '(':
            duplicate -= 1
            stk.pop()
            if check1 and not value:
                check2 = True
            if value and duplicate >= 1:
                check1 = True
            value = False
        else:
            stk.pop()
            value = True
    return check2
    

def find_kth_element(k, iterable):
    
    que = Queue()
    for i in iterable:
        que.enqueue(i)
    while k > 0:
        if que.peek() == None:
            for i in iterable:
                que.enqueue(i)
            value = que.peek()
            que.dequeue()
        else:
            value = que.peek()
            que.dequeue()
        k -= 1
    return value

def choices_choices(candidate, pattern, possibility):
    
    if '_' not in pattern:
        possibility.append(pattern)
    else:
        for i in candidate:
            copy = list(candidate)
            copy.remove(i)
            choices_choices(copy, pattern.replace('_', i, 1), possibility)


def respect_your_cat(food, num):
    
    if len(food) < 5:
        x = 'Give me more food!'
    else:
        x = food + num*"!"
    return x


def driver_age(lst):
    
    if len(lst) > 0:
        for i in range(len(lst)):
            if lst[i] > 25:
                x = True
            else:
                x = False
    else: 
        x = False
    return x
def over_25_counter_variable(lst):
    
    x = 0
    for i in range(len(lst)):
        if lst[i] >= 25:
            x += 1
    return x

def team_captain(first_name, last_name):
    
    name = "Team captain is " + first_name + " " + last_name
    return name

def team_name(names):
    
    team = ""
    for i in range(len(names)):
        if len(names[i]) == 1:
            team = team + names[i] + " "
        else:
            team = team + (names[i][0] + names[i][-1])
    return team

def team_slogan_concat(words, separator):
    
    slogan = ""
    for i in range(len(words)-1):
        slogan = slogan + words[i] + separator
    return slogan + words[len(words)-1]


def team_slogan_join(words, separator):
    
    return separator.join(words)

def drawing(symbol, repeat):
    
    return symbol*repeat

def drawing_longer(symbols, repeats):
    
    draw = ""
    for i in range(len(symbols)):
        draw = draw + symbols[i]*repeats[i]
    return draw

def hotel_rating_average(ratings):
    
    rate = 0
    for i in range(len(ratings)):
        if ratings[i]< 5:
            ratings[i] = 0
    for i in range(len(ratings)):
        rate =  rate + ratings[i]
    return round(rate/len(ratings),2)

def hotel_rating_best_average(ratings, names):
    
    newrating = []
    hotel = ""
    if len(ratings) == 0:
        hotel = "No route to choose from"
    else:
        for i in range(len(ratings)):
            newrating.append(hotel_rating_average(ratings[i]))
        maximum = max(newrating)
        hotel = names[newrating.index(maximum)]
    return hotel



def password(text, number, boolean):
    
    message = ""
    if type(text) != str:
        message = "ERROR!"
    elif type(number) != int:
        message = "ERROR!"
    elif type(boolean) != bool:
        message = "ERROR!"
    else:
        if number%2 == 0:
            number = number + 1
            message = text[::-1] + str(number) + str(not boolean)
        else:
            number = number - 1
            message = text[::-1] + str(number) + str(not boolean)
    return message


def parks(park_names):
    
    park_list = []
    for names in park_names:
        if len(names) < 3:
            park_list.append('will skip')
        else:
            park_list.append(names[1:len(names)-1])

    return park_list


def many_parks(many_places, threshold):
    
    return_list = []
    for many_places_list in many_places:
        park_list = []
        for names in many_places_list:                
            if len(names) < threshold * 2:
                park_list.append('will skip')
            else:
                park_list.append(names[threshold:len(names)-threshold])
        return_list.append(park_list)
    return return_list


def correct_state(places):
   
    i = 0
    capitalized = []
    while i < len(places):
        if places[i][1] =='CA':
            capitalized.append(places[i][0].upper())
            i = i + 1
        else:
            break
    return capitalized


def names(input_string, end):
    
    all_names = input_string.split(" ")
    count = 0
    for names in all_names:
        if names[-1] == end:
            if names[-2].isalpha():
                count = count + 1
            else:
                count = count
        else:
            count = count
        
    return count


def pr5_1(teams):
   
    count = 0
    for keys in teams:
        count = count + 1
    return count


def pr5_2(teams):
   
    list = []
    for key in teams.keys():
        list.append(key)
    return list


def pr5_3(teams):
   
    lists = teams.values()
    largest = 0
    for captain in lists:
        count = 0 
        for members in captain:
            count = count + 1
            if count > largest:
                largest = count
            else:
                largest = largest
    return largest


def pr5_4(teams, driver):
   
    if driver in teams:
        teams = teams
    else:
        teams.update({driver: []})
    return teams


def pr5_5(teams, driver, team_member):
    
    if driver in teams:
        member_list = teams.get(driver)
        member_list.append(team_member)
        teams.update({driver: member_list})
    else:
        teams.update(({driver: [team_member]}))
    return teams


def pr5_6(teams, team_member):
   
    for driver in teams:
        member_list = teams.get(driver)
        if team_member in member_list:
            member_list.remove(team_member)
        teams.update({driver: member_list})
    return teams


def secret_language(pass_dict):
    
    message = ""
    for members in pass_dict:
        if type(pass_dict.get(members)) == str:
            if len(pass_dict.get(members)) % 2 == 0:
                message = message + members[::-1]
        elif type(pass_dict.get(members)) == int:
            if pass_dict.get(members) >= 0:
                message = message + "*" * len(members)
            elif pass_dict.get(members) < 0:
                message = message + members[-1]
             
    return message



def decode_details(filename):
    
    with open(filename, 'r') as f:
        lines = f.readlines()
        new_lines = [x.replace('!', '').replace('?', '').replace(';', \
        '').replace('$', '').strip() for x in lines]
        return_string = ''
        for words in new_lines:
            return_string = return_string + words + '\n'
    return return_string.strip()
    
def decode_details_skipped(filename, skip):
    
    with open(filename, 'r') as f:
        lines = f.readlines()
        new_lines = [x.replace('!', '').replace('?', '').replace(';', \
        '').replace('$', '').strip() for x in lines]
    return_string = ''
    i = 0
    while i in range(len(new_lines)):
        return_string = return_string + new_lines[i] + '\n'
        i = i + skip + 1
    return return_string.strip()



def passcode(filename):
    
    with open(filename) as f:
        lines = f.readlines()
        total = ''
        for word in lines:
            total = total + word.strip().lower().replace(' ', '')
        totallist = []
        for letter in total:
            totallist.append(letter)
        dictionary = {}
        for letters in totallist:
            if letters.isalpha() and letters not in dictionary:
                dictionary[letters] = 1
            elif letters.isalpha() and letters in dictionary:
                dictionary[letters] = dictionary.get(letters) + 1
        return_string = str("")
        for ordered in sorted(dictionary):
            return_string = return_string + str(dictionary.get(ordered))
    return return_string

def dollars_cents(lst):
   
    return [str(x//100) + ' dollar(s) and ' + str(x%100) + ' cents' \
    for x in lst]



def sum_certain_amount(lst):
   
    return sum([0] + [sum([x//100]) for x in lst if x//100 > 50])



def dollars_only(lst):
   

    return [x[0] for x in lst if x[1] == 'dollars'] + \
    ['keep in vault' for x in lst if x[1] != 'dollars']


def names_only(names):
    
    return  [x for i in range(len(names)) for x in names[i]] 


def name_identify(names):

    return [x.split()[0] for x in names if 'm' in x.split()[1].lower()]


def message_encoding(message):
    
    return [message[i][i%len(message[i])::] + \
    message[i][0:i%len(message[i])] for i in range(len(message))]


def order_66(squads):
   
    return list(map(lambda x: 'executed' if 2 * x.count('jedi') <\
    x.count('clone') else 'survived', squads))



def midichlorian(people, threshold):
    
    return list(map(lambda x: x[0], \
    list(filter(lambda x: x[1]>threshold, people))))

def podracer(bets):
    
    return list(filter(lambda x: x != 'NAN', list(map(lambda name, profit: \
    name if profit[0] - profit[1] - profit[2] > 0 else 'NAN', \
    list(bets.keys()), list(bets.values()))))) 

def darth(names):
    
    return list(map(lambda x: ('Darth ' + x).title(), \
    list(filter(lambda name: name[0] and name[-1] \
    not in ['a', 'e', 'i', 'o', 'u'], names))))

def sand(places):
    
    nothing = lambda x,y: False if set(x) & set(y) else True
    return len(list(filter(lambda x: x != 'NAN', list(map(lambda name, \
    description: name if nothing(description, \
    ['sand', 'coarse', 'rough', 'irritating']) else 'NAN', \
    list(places.keys()), list(places.values()))))))


def death_star(coordinates, death_star):
   
    return list(filter(lambda x: x != 'NAN', list(map(lambda name, location: \
    name if all([location[0] - death_star[0] <= 0.5, location[1] - death_star \
    [1] <=0.5, location[2] - death_star[2] <=0.5]) else 'NAN', \
    list(coordinates.keys()), list(coordinates.values())))))


def identity(x):
    return x

def squared(x):
    return x**2



def dct_op(dct, func):

    return {key: [func(x) for x in value] for (key, value) in \
    list(dct.items())}



def dct_special(dct, func, players):
    
    return [[func(x) for x in dct.get(y)] for y in dct.keys() if y in players]



def nba_stats(dct, func, stats):
    
    if stats == 'total_points':
        idx = 0
    elif stats == 'free_throw':
        idx = 1
    elif stats == 'turn_over':
        idx = 2

    return {key: [func(y) for y in [x[idx] for x in values]] \
    for (key, values) in dct.items()}

def pumpkin_calc(x, y, z):
    
    def ppci(w):
        return round(w / (3.14 * x * y * z *4/3), 3)
    return ppci
         

def decipher_text(key1, key2, key3):
   
    def decode(x):
        return_str = ''
        for i in x:
            if i.lower() == key1.lower() and x.index(i) % 2 == 1:
                return_str = return_str + 'i'
            elif i.lower() == key1.lower() and x.index(i) %2 == 0:
                return_str = return_str + 'e'
            elif i.lower() == key2.lower() and x.index(i) %2 == 1:
                return_str = return_str + 'o'
            elif i.lower() == key2.lower() and x.index(i) %2 == 0:
                return_str = return_str + 'a'
            elif i.lower() == key3.lower():
                return_str = return_str + 'u'
            else:
                return_str = return_str + i.lower()
        return return_str
    return decode

 
def grade_calculator(w1,  w2):
    
    def rawgrade(x,y):
        if len(x) == 0:
            grade1 = 0
        else:
            grade1 = (sum(x) / len(x))
        if len(y) == 0:
            grade2 = 0
        else:
            grade2 = sum(y) / len(y)
        return round((grade1) * w1 + (grade2) * w2, 2)
    def letter(x,y):
        if rawgrade(x,y) >= 0.9:
            return 'A'
        elif rawgrade(x,y) >= 0.8:
            return 'B'
        elif rawgrade(x,y) >= 0.7:
            return 'C'
        elif rawgrade(x,y) >= 0.6:
            return 'D'
        else:
            return 'F'
    return rawgrade, letter


def complexity_tf():
    
    return [False, False, False, True, False, True, False, True, False, True]


def prerequisites(*args, **kwargs):
   
    return_list = []
    for i in args:
        for k in kwargs:
            if i in kwargs.get(k):
                if k not in return_list:
                    return_list.append(k)
            else:
                if k in return_list:
                    return_list.remove(k)
    return return_list


def building_mats(*args, **kwargs):
   
    supply = {}
    for i in args:
        if i[0] not in supply:
            supply[i[0]] = i[1]
        else:
            supply[i[0]] += i[1]
    return_list = []
    for k in kwargs:
        if k not in supply:
            return_list.append(k)
        elif kwargs[k] > supply[k]:
            return_list.append(k)
    return return_list


def reverse_str(name):
   
    if len(name) == 0:
        return name
    else:
        return reverse_str(name[1:]) + name[0]


def reverse_list(lst):
    
    if len(lst) == 0:
        return lst
    else:
        return reverse_list(lst[:-1]) + [reverse_str(lst[-1])]

def remove_dragon(lst):
   
    if len(lst) == 0:
        return []
    if lst[0].lower().count('dragon') > 0:
        return [] + remove_dragon(lst[1:])
    else:
        return [lst[0]] + remove_dragon(lst[1:])


def sum_odd(lst):
   
    if len(lst) == 0:
        return 0
    if lst[0] % 2 == 1:
        return lst[0] + sum_odd(lst[1:])
    elif lst[0] % 2 == 0:
        return sum_odd(lst[1:])


def duplication_glitch(num_diamonds, hours):
    
    if hours == 0:
        return num_diamonds
    else:
        return num_diamonds * 2 ** (hours-1) + \
        duplication_glitch(num_diamonds, hours-1)


def min_recursion(lst):
    
    if len(lst) == 1:
       return lst[0]
    else:
       minNumber = min_recursion(lst[1:])
       current_min = lst[0]
       if minNumber < current_min:
            current_min = minNumber
       return current_min


def count_chars(s):
    
    dct = {}
    if len(s) == 0:
        return dct
    else:
        dct = count_chars(s[1:])
        if s[0] in dct:
            dct[s[0]] += 1
        else:
            dct[s[0]] = 1
        return dct   


def merge(lst_1, lst_2):
    
    if len(lst_1) == 0:
        return lst_2
    elif len(lst_2) == 0:
        return lst_1
    else:
        if lst_1[0] > lst_2[0]:
            return [lst_2[0]] + merge(lst_1, lst_2[1:])
        elif lst_1[0] < lst_2[0]:
            return [lst_1[0]] + merge(lst_1[1:], lst_2)
        elif lst_1[0] == lst_2[0]:
            return [lst_1[0]] + merge(lst_1[1:], lst_2)


def split(*nums, n):
   
    x = list(nums)
    if n == 1:
        return [[x[0]]]
    elif len(x) == n:
        return [x]
    elif len(x) < n:
        return []
    else:
        return [x[0:n]] + split(*nums[n:], n = n - 1)


class Pokemon:
    
    def __init__(self, name, pokemon_type, moves):
        self.name = name
        self.pokemon_type = pokemon_type
        self.moves = moves
        self.total_moves = 0  
    
    def take_movement(self, idx):
        if idx > len(self.moves):
            return 'Fail to take the movement'
        else:
            self.total_moves += 1
            return self.moves[idx]
    
    def show_total_moves(self):
        return 'The total moves of ' + self.name + ' is ' + \
            str(self.total_moves)


class Student:
    
    describe = 'This is a student account'
    def edit_canvas():
        return 'Student account cannot edit this course'
    def __init__(self, pid, height, dob, gpa):
        self.pid = pid
        self.height = height
        self.dob = dob
        self.gpa = gpa
    def info(self):
        return 'The student ' + self.pid + " was born on " + self.dob + \
            ". The student has a gpa of " + str(self.gpa)
    def get_gpa(self):
        return self.gpa
    def set_gpa(self, new_grade):
        if new_grade < 0 or new_grade > 4:
            return 'Invalid Input'
        else:
            self.gpa = new_grade
            return True


def doctest_q6():
    
    return

import random




class Player:
    def __init__(self, username, region):
        self.username = username
        self.region = region
        self.experience = 0
        self.level = 0
        return

    def play(self):
        cond = random.choice(['W', 'L'])
        if cond == 'W':
            self.experience += 5000
            return self.username + ' played a game. You won! You have gained 5000 experience points.'
        elif cond == 'L':
            self.experience += 3000
            return self.username + ' played a game. You lost! You have gained 3000 experience points.'

    def play_several(self, games):
        return_str = ''
        for i in range(games):
            return_str += self.play() + '\n'
        return return_str[:-1]


class RegularPlayer(Player):
    def level_up(self):
        if self.experience >= (self.level + 1) * 10000:
            self.level = self.experience // 10000
            return 'Promoted to level ' + str(self.level)
        else:
            return 'Not enough experience!'


class PremiumPlayer(Player):
    def __init__(self, username, region):
        super().__init__(username, region)
        self.experience = 1000
        self.level = 0
        return
    
    def promote(self):
        if self.experience >= (self.level + 1) * 6000:
            while self.experience >= (self.level + 1) * 6000:
                self.level += 1
                self.experience += 1000
            return 'Promoted to level ' + str(self.level)
        else:
            return 'Not enough experience!'


class Hero:


    def __init__(self, name, health, base_damage, ammo):
        self.name = name
        self.health = health
        self.base_damage = base_damage
        self.ammo = ammo
        self.maximum_ammo = ammo
        self.maximum_health = health
        return

    def attack(self, other_character, ammo_usage = 1):
        if self.health <= 0:
            self.health = 0 
            return "Your character is dead! Can't attack!"
        else:
            shield = 0 
            if type(other_character) == Tank:
                shield = other_character.shield
            damage = (self.base_damage * ammo_usage) - shield
            self.ammo -= 1
            if self.ammo == 0:
                self.ammo = self.maximum_ammo
            other_character.health -= damage
            if other_character.health <= 0:
                other_character.health = 0
                return other_character.name + ' was killed after receiving ' \
                + str(damage) + ' amount of damage!'
            else:
                return other_character.name + ' received ' + str(damage) + \
                ' damage, but survived!'
    
    def heal(self, other_character, heal_amount, yourself = True):
        if yourself == True:
            if self.health <= heal_amount:
                return "Not enough health! Can't heal!"
            if other_character.health == 0:
                return "Your character is dead! Can't heal!"
            else:
                other_character.health += heal_amount
                self.health -= heal_amount
                if other_character.health > other_character.maximum_health:
                    other_character.health = other_character.maximum_health
                return self.name + ' healed ' + other_character.name + ' to ' \
                + str(other_character.health) + ' health!'
        if yourself == False:
            if other_character.health <= heal_amount:
                return "Not enough health! Can't heal!"
            if self.health == 0:
                return "Your character is dead! Can't heal!"
            else:
                self.health += heal_amount
                other_character.health -= heal_amount
                if self.health > self.maximum_health:
                    self.health = self.maximum_health
                return other_character.name + ' healed ' + self.name + ' to ' \
                + str(self.health) + ' health!'
    

class Tank(Hero):


    def __init__(self, name, health, base_damage, ammo, shield):
        super().__init__(name, health, base_damage, ammo)
        self.shield = shield
        return

class Healer(Hero):

    def heal(self, other_character, heal_amount):
        if other_character.health <= 0:
            other_character.health = 0
            other_character.health += int(heal_amount / 2)
            return 'Your character is now alive! ' + self.name + ' healed ' + \
                other_character.name + ' to ' \
                + str(other_character.health) + ' health!'
        else:
            other_character.health += heal_amount
            if other_character.health > other_character.maximum_health:
                other_character.health = other_character.maximum_health
            return self.name + ' healed ' + other_character.name +  ' to ' + \
                str(other_character.health) + ' health!'
            


def question_1():
    
    return  [0, 0, 0, 1, 1, 0, 0, 1, 0, 1]




def question_2():
    
    return  [0, 0, 0, 1, 1]



def reverse_list(lst):
    
    l = len(lst)
    for i in range(l):
        if i < l / 2:
            lst[i], lst[l - i - 1] = lst[l - i - 1], lst[i]



def swap_lists(alist1, alist2):
    
    for i in range(len(alist1)):
        alist1[i], alist2[i] = alist2[i], alist1[i]


def daily_inventory(store, purchases):
    
    store_items = list(store.keys())
    for i in store_items:
        if i not in purchases:
            store.pop(i)
        else:
            if store[i] - purchases[i] == 0:
                store.pop(i)
            else:
                store[i] = store[i] - purchases[i]

def reverse_chunks(seq):
    
    i = len(seq)
    j = 1
    m = 0
    while i > j:
        for k in range(j):
            if k < j/2:
                seq[m + k], seq[m + j - k - 1] = seq[m + j - k - 1], seq[m + k]
        m += j
        i -= j
        j += 1


class Collection:
 

    def __init__(self):

        self.items = []
        self.num_items = 0

    def size(self):

        return self.num_items

    def is_empty(self):

        if self.num_items == 0:
            return True
        else:
            return False

    def clear(self):

        self.items = []
        self.num_items = 0


class Stack(Collection):
   
    def push(self, item):

        if item == None:
            raise ValueError('None is not a valid item')
        else:
            self.num_items += 1
            self.items.insert(0, item)
    def pop(self):

        if self.num_items == 0:
            return None
        else:
            to_return = self.items[0]
            del self.items[0]
            self.num_items -= 1
            return to_return
    def peek(self):

        if self.num_items == 0:
            return None
        else:
            return self.items[0]

    def __str__(self):

        if self.num_items == 0:
            return "(bottom) (top)"
        else:
            items_string = ' '
            for i in self.items[::-1]:
                items_string += str(i) + ' -- '
            return '(bottom)' + items_string[:-3] + '(top)'


class Queue(Collection):

    def enqueue(self, item):

        if item == None:
            raise ValueError('None is not a valid item')
        else:
            self.num_items += 1
            self.items.append(item)
    def dequeue(self):

        if self.num_items == 0:
            return None
        else:
            self.num_items -= 1
            return self.items.pop(0)
    def peek(self):

        if self.num_items == 0:
            return None
        else:
            return self.items[0]
    def __str__(self):

        if self.num_items == 0:
            return "(front) (rear)"
        else:
            items_string = ' '
            for i in self.items:
                items_string += str(i) + ' -- '
            return '(front)' + items_string[:-3] + '(rear)'
class FillinQuestion(Question) :
    def __init__(self) :
        super().__init__()
    def setText(self, questionText) :   
        startanswer = questionText.find("_")
        endanswer = questionText.rfind("_")
        self.setAnswer(questionText[startanswer + 1 : endanswer])
        self._text = questionText[ : startanswer] + "_____" + questionText[endanswer : ]
class AnyCorrectChoiceQuestion(Question) :
    def checkAnswer(self, response) :
        answerlist = self._answer.split()
        for ans in answerlist :
            if response == ans :
                return True
        return False
class Question :
    def __init__(self) :
        self._text = ""
        self._answer = ""
    def setText(self, questionText) :   
        self._text = questionText
    def addText(self, text) :
        self._text = self._text + text
    def setAnswer(self, correctResponse) :
        self._answer = correctResponse
    def checkAnswer(self, response) :
        return response == self._answer
    def display(self) :
        print(self._text)   
class ChoiceQuestion(Question) :
    def __init__(self) :
        super().__init__()
        self._num_choices = 0
    def addChoice(self, choice, correct) :
        self._num_choices = self._num_choices + 1
        self.addText("\n" + str(self._num_choices) + ": " + choice)
        if correct :
            choiceString = str(self._num_choices)
            self.setAnswer(choiceString)
class Person :
    def __init__(self, name, year) :
        self._name = name
        self._year = year
    def __repr__(self) :
        return self._name + ", born " + str(self._year)
class Student(Person) :
    def __init__(self, name, year, major) :
        super().__init__(name, year)
        self._major = major
    def __repr__(self) :
        return self._name + ", born " + str(self._year) + \
             " is a " + self._major + " major"
class Instructor(Person) :
    def __init__(self, name, year, salary) :
        super().__init__(name, year)
        self._salary = salary
    def __repr__(self) :
        return self._name + ", born " + str(self._year) + \
             " has a $%.2f" % self._salary + " salary"

per = Person("Bob", 2000)
stu = Student("Bill", 2000, "CS")
ins = Instructor("Will", 1980, 50000)

print(per)
print(stu)
print(ins)
class Employee :
    def __init__(self, name, salary) :
        self._name = name
        self._salary = salary
    def __repr__(self) :
        return self._name + " has a salary of %.2f" % self._salary
class Manager(Employee) :
    def __init__(self, name, salary, department) :
        super().__init__(name, salary)
        self._department = department
    def __repr__(self) :
        return self._name + " has a salary of %.2f" % self._salary + \
             " and manages the " + self._department + " department"
class Executive(Manager) :
    def __repr__(self) :
        return self._name + " has a salary of %.2f" % self._salary + \
             " and is the executive for the " + self._department + " department"

emp = Employee("Bob", 500)
man = Manager("Bill", 5000, "A")
exe = Executive("Will", 50000, "C")

print(emp)
print(man)
print(exe)
class Dinosaur :
    def __init__(self, name="dinosaur") :
        self._name = name

    def display(self) :
        print(self._name)

class Triceratops(Dinosaur) :
    def __init__(self) :
        super().__init__("triceratops")

x = Triceratops()
x.display()
def hello (number):
    if number == 1:
        return "January"
    if number == 2:
        return "February"
    if number == 3:
        return "March"
    if number == 4:
        return "April"
    if number == 5:
        return "May"
    if number == 6:
        return "June"
    if number == 7:
        return "July"
    if number == 8:
        return "August"
    if number == 9:
        return "September"
    if number == 10:
        return "October"
    if number == 11:
        return "November"
    if number == 12:
        return "December"
for i in range(1, 4) :
   for j in range(1, 4) :
      print("X", end="")
   print("")
input1 = input("First integer: ")
input2 = input("Second integer: ")
input1 = int(input1)
input2 = int(input2)
SUM=input1+input2
print("%-10s%5d" % ("Sum: ", SUM))
DIFF=input1-input2
print("%-10s%3d" % ("Difference: ", DIFF))
PROD=input1*input2
print("%-10s%5d" % ("Product: ", PROD)) 
AVE=(input1+input2)/2
AVE=float(AVE)
print("%-10s%8.2f" % ("Average: ", AVE))
DIST=abs(input1-input2)
print("%-10s%5d" % ("Distance: ", DIST))
MAX=max(input1,input2)
MIN=min(input1,input2)
print("%-10s%5d" % ("Maximum: ", MAX))
print("%-10s%5d" % ("Minimum: ", MIN))
Grade=input("Enter a letter grade: ")
Grade=Grade.upper()
if Grade == "A+":
    number=4.0
elif Grade == "A":
    number=4.0
elif Grade == "A-":
    number=3.7
elif Grade == "B+":
    number=3.3
elif Grade=="B":
    number=3.0
elif Grade=="B-":
    number=2.7
elif Grade=="C+":
    number=2.3
elif Grade=="C":
    number=2.0
elif Grade=="C-":
    number=1.7
elif Grade=="D+":
    number=1.3
elif Grade=="D":
    number=1.0
elif Grade=="D-":
    number=0.7
elif Grade=="F":
    number=0
else:
    print("Please enter a letter grade")
print("The numeric value is:", number)
Card=input("Enter a card notation: ")
Card=Card.upper()
if Card.startswith("A"):
    if Card.endswith("D"):
        print("Ace of Diamonds")
    elif Card.endswith("H"):
        print("Ace of Hearts")
    elif Card.endswith("C"):
        print("Ace of Clubs")
    elif Card.endswith("S"):
        print("Ace of Spades")
    else:
        print("Invalid Input!")
elif Card.startswith("2"):
    if Card.endswith("D"):
        print("Two of Diamonds")
    elif Card.endswith("H"):
        print("Two of Hearts")
    elif Card.endswith("C"):
        print("Two of Clubs")
    elif Card.endswith("S"):
        print("Two of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("3"):
    if Card.endswith("D"):
        print("Three of Diamonds")
    elif Card.endswith("H"):
        print("Three of Hearts")
    elif Card.endswith("C"):
        print("Three of Clubs")
    elif Card.endswith("S"):
        print("Three of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("4"):
    if Card.endswith("D"):
        print("Four of Diamonds")
    elif Card.endswith("H"):
        print("Four of Hearts")
    elif Card.endswith("C"):
        print("Four of Clubs")
    elif Card.endswith("S"):
        print("Four of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("5"):
    if Card.endswith("D"):
        print("Five of Diamonds")
    elif Card.endswith("H"):
        print("Five of Hearts")
    elif Card.endswith("C"):
        print("Five of Clubs")
    elif Card.endswith("S"):
        print("Five of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("6"):
    if Card.endswith("D"):
        print("Six of Diamonds")
    elif Card.endswith("H"):
        print("Six of Hearts")
    elif Card.endswith("C"):
        print("Six of Clubs")
    elif Card.endswith("S"):
        print("Six of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("7"):
    if Card.endswith("D"):
        print("Seven of Diamonds")
    elif Card.endswith("H"):
        print("Seven of Hearts")
    elif Card.endswith("C"):
        print("Seven of Clubs")
    elif Card.endswith("S"):
        print("Seven of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("8"):
    if Card.endswith("D"):
        print("Eight of Diamonds")
    elif Card.endswith("H"):
        print("Eight of Hearts")
    elif Card.endswith("C"):
        print("Eight of Clubs")
    elif Card.endswith("S"):
        print("Eight of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("9"):
    if Card.endswith("D"):
        print("Nine of Diamonds")
    elif Card.endswith("H"):
        print("Nine of Hearts")
    elif Card.endswith("C"):
        print("Nine of Clubs")
    elif Card.endswith("S"):
        print("Nine of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("10"):
    if Card.endswith("D"):
        print("Ten of Diamonds")
    elif Card.endswith("H"):
        print("Ten of Hearts")
    elif Card.endswith("C"):
        print("Ten of Clubs")
    elif Card.endswith("S"):
        print("Ten of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("J"):
    if Card.endswith("D"):
        print("Jack of Diamonds")
    elif Card.endswith("H"):
        print("Jack of Hearts")
    elif Card.endswith("C"):
        print("Jack of Clubs")
    elif Card.endswith("S"):
        print("Jack of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("Q"):
    if Card.endswith("D"):
        print("Queen of Diamonds")
    elif Card.endswith("H"):
        print("Queen of Hearts")
    elif Card.endswith("C"):
        print("Queen of Clubs")
    elif Card.endswith("S"):
        print("Queen of Spades")
    else:
        print("Invalid Input!")        
elif Card.startswith("K"):
    if Card.endswith("D"):
        print("King of Diamonds")
    elif Card.endswith("H"):
        print("King of Hearts")
    elif Card.endswith("C"):
        print("King of Clubs")
    elif Card.endswith("S"):
        print("King of Spades")
    else:
        print("Invalid Input!")        
else:
    print("Invalid Input!")
income=int(input("Please enter your income: "))
if income <=50000:
    tax=0.01
elif 50000<income<=75000:
    tax=0.02
elif 75000<income<=100000:
    tax=0.03
elif 100000<income<=250000:
    tax=0.04
elif 250000<income<=500000:
    tax=0.05
elif income>500000:
    tax=0.06
print("The income tax is:",round(income*tax,2),"dollars")
Status=input("Please enter your marital status(S for single, M for Married): ")
Status=Status.upper()
Income=int(input("Please enter your income: "))
if Status == "S":
    if 0<=Income<=8000:
        print("The tax is: $",round(Income*0.1,2))
    elif 8000<Income<=32000:
        print("The tax is: $",round(800+Income*0.15,2))
    elif Income>32000:
        print("The tax is:$",round(4400+Income*0.25,2))
elif Status == "M":
    if 0<=Income<=16000:
        print("The tax is: $",round(Income*0.1,2))
    elif 16000<Income<=64000:
        print("The tax is: $",round(1600+Income*0.15,2))
    elif Income>64000:
        print("The tax is:$",round(8800+Income*0.25,2))    
else:
    print("Invalid Input")
Number=int(input("Enter the integer 1-3999: "))
if 1<=Number<=3999:
    Thou=Number//1000
    if Thou==3:
        Thousands="MMM"
    if Thou==2:
        Thousands="MM"
    if Thou == 1:
        Thousands = "M"
    if Thou == 0:
        Thousands = ""
    Hund=(Number-Thou*1000)//100
    if Hund ==9:
        Hundreds = "CM"
    if Hund==8:
        Hundreds = "DCCC"
    if Hund==7:
        Hundreds = "DCC"
    if Hund == 6:
        Hundreds = "DC"
    if Hund == 5:
        Hundreds = "D"
    if Hund == 4:
        Hundreds = "CD"
    if Hund == 3:
        Hundreds = "CCC"
    if Hund == 2:
        Hundreds = "CC"
    if Hund == 1:
        Hundreds = "C"
    if Hund == 0:
        Hundreds = ""
    Ten=(Number-Thou*1000-Hund*100)//10
    if Ten == 9:
        Tenths = "XC"
    if Ten == 8:
        Tenths = "LXXX"
    if Ten == 7:
        Tenths =  "LXX"
    if Ten == 6:
        Tenths = "LX"
    if Ten == 5:
        Tenths = "L"
    if Ten == 4:
        Tenths = "XL"
    if Ten == 3:
        Tenths = "XXX"
    if Ten == 2:
        Tenths = "XX"
    if Ten == 1:
        Tenths = "X"
    if Ten == 0:
        Tenths = ""
    One=(Number-Thou*1000-Hund*100-Ten*10)
    if One == 9:
        Ones = "IX"
    if One == 8:
        Ones = "VIII"
    if One == 7:
        Ones = "VII"
    if One == 6:
        Ones = "VI"
    if One == 5:
        Ones = "V"
    if One == 4:
        Ones = "IV"
    if One == 3:
        Ones = "III"
    if One == 2:
        Ones = "II"
    if One == 1:
        Ones = "I"
    if One == 0:
        Ones =""
else:
    print("Please enter a number 1-3999")
print("The Roman numeral for the year", Number, "is", Thousands+Hundreds+Tenths+Ones+".")
for i in range (1,11):
    for j in range (1,11):
        print("%4d"%(i*j), end="")
    print()
n=int(input("Please enter a number: "))
line=1
dot=1
for i in range(n):
    dot=1
    for i in range(n):
        print("*", end = "")
    print(end=" ")
    for i in range(n):
        if line==1 or line==n:
            print("*", end = "")
        else:
            if dot==1 or dot==n:
                print("*", end = "")
            else:
                print(" ", end = "")   
        dot=dot+1
    line=line+1
    print()

from random import randint
from math import log
human = 0     
comp = 1
smart = 0
dumb = 1
pile = randint(10, 100)
turn = randint(0, 1)
strat = randint(0, 1)
while pile > 0 :
   if turn == comp :
      if pile == 1 :
         take = 1
      elif strat == dumb :
         take = randint(1, pile // 2)
      elif pile == 3 or pile == 7 or pile == 15 or pile == 31 or pile == 63 :
         take = randint(1, pile // 2)
      else : 
         take = pile - 2 ** int(log(pile, 2)) + 1
      pile = pile - take
      print("The computer took",take,"marbles, leaving",pile)
      print()
      turn = human
   elif turn == human :
      print("Your turn. The pile currently has", pile, "marbles in it.")
      take = int(input("How many marbles will you take? "))
      while take < 1 or take > max(pile // 2, 1) :
         print("That isn't a legal move.")
         take = int(input("How many marbles will you take? "))
      pile = pile - take 
      print("Now the pile has", pile, "marbles in it.")
      print()
      turn = comp
if turn == comp :
   print("The computer won!")
else :
   print("You Won!")
num = input("Enter an 8 digit credit card number: ")
odd = 0
for i in range(7, 0, -2) :
    odd = odd + int(num[i])
even = 0
for i in range(6, -1, -2) :
    double = int(num[i]) * 2
    even = even + double // 10 + double % 10
total = odd + even
if total % 10 == 0 :
    print("That number is valid.")
else :
    digit = int(num[7])
    shouldbe = (10 - (total % 10) + digit) % 10
    print("The number is not valid.  The check digit should be: ", shouldbe)
number=int(input("Please enter a random positive number: "))
if number>=0: 
    def main() :
        print("firstDigit of", number, "is", firstDigit(number))
        print("lastDigit of", number, "is", lastDigit(number))
        print("digits of", number, "is", digits(number))
    
    def firstDigit(n) :
        x = str(n)
        first = int(x[0])
        return first

    def lastDigit(n) :
        return n % 10

    
    def digits(n) :
        x = str(n)
        return len(x)

    main()
else:
    print("Please enter a valid number")

from math import pi, sqrt
r = float(input("Enter the radius: "))
h = float(input("Enter the height: "))
def main() :
   print("A sphere has volume:", sphereVolume(r))
   print("A sphere has surface area:", sphereSurface(r))
   print("A cylinder has volume:", cylinderVolume(r, h))
   print("A cylinder has surface area:", cylinderSurface(r, h))
   print("A cone has volume:", coneVolume(r, h))
   print("A cone has surface area:", coneSurface(r, h))

def sphereVolume(r) :
   return 4 / 3 * pi * r ** 3

def sphereSurface(r) :
   return 4 * pi * r ** 2

def cylinderVolume(r, h) :
   return pi * r ** 2 * h

def cylinderSurface(r, h) :
   return 2 * (pi * r ** 2 + pi * r * h)

def coneVolume(r, h) :
   return 1 / 3 * pi * r * r * h

def coneSurface(r, h) :
   s = sqrt(h * h + r * r)
   return pi * r * s + pi * r * r

main()
hours = int(input("Enter the hours (between 1-12): "))
minutes = int(input("Enter the minutes: "))
def main() :
    print(getTimeName(hours, minutes))

def getTimeName(hours, minutes) :
    if minutes == 15 :
        return "quarter after " + hourName(hours)
    elif minutes == 30 :
        return "half past " + hourName(hours)
    elif minutes == 45 :
        return "quarter to " + hourName((hours + 1))
    elif minutes == 0 :
        return hourName(hours) + " o'clock"
    elif minutes < 30 :
        if minutes == 1 : 
            word = " minute past "
        else :
            word= " minutes past "
        return intName(minutes) + word + hourName(hours)
    else :
        if 60 - minutes == 1 :
            word = " minute before "
        else :
            word = " minutes before "
        return intName(60 - minutes) + word + hourName((hours + 1))

def hourName(digit) :
    if digit == 0: return "twelve"
    if digit == 1: return "one"
    if digit == 2: return "two"
    if digit == 3: return "three"
    if digit == 4: return "four"
    if digit == 5: return "five"
    if digit == 6: return "six"
    if digit == 7: return "seven"
    if digit == 8: return "eight"
    if digit == 9: return "nine"
    if digit == 10: return "ten"
    if digit == 11: return "eleven"
    if digit == 12: return "twelve"
    return ""

def intName(number) :
    part = number
    name = ""     
    if part >= 100 :
        name = digitName(part // 100) + " hundred"
        part = part % 100

    if part >= 20 :
        name = name + " " + tensName(part)
        part = part % 10
    elif part >= 10 :
        name = name + " " + teenName(part)
        part = 0
    if part > 0 :
        name = name + " " + digitName(part)
    return name.strip()

def digitName(digit) :
    if digit == 1: return "one"
    if digit == 2: return "two"
    if digit == 3: return "three"
    if digit == 4: return "four"
    if digit == 5: return "five"
    if digit == 6: return "six"
    if digit == 7: return "seven"
    if digit == 8: return "eight"
    if digit == 9: return "nine"
    return ""

def teenName(number) :
    if number == 10 : return "ten"
    if number == 11 : return "eleven"
    if number == 12 : return "twelve"
    if number == 13 : return "thirteen"
    if number == 14 : return "fourteen"
    if number == 15 : return "fifteen"
    if number == 16 : return "sixteen"
    if number == 17 : return "seventeen"
    if number == 18 : return "eighteen"
    if number == 19 : return "nineteen"
    return ""

def tensName(number) :
    if number >= 90 : return "ninety"
    if number >= 80 : return "eighty"
    if number >= 70 : return "seventy"
    if number >= 60 : return "sixty"
    if number >= 50 : return "fifty"
    if number >= 40 : return "forty"
    if number >= 30 : return "thirty"
    if number >= 20 : return "twenty"
    return ""

main()

word=str(input("Please enter a word: "))
search=str(input("Please enter the word you want test whether or not it is in the word above: "))
def main():
    print(search, "is in the word,",word,":",find(word,search))

def find(string, match) :
    if string.startswith(match) == True :
        return True
    elif len(string) >= len(match) :
        return find(string[1 : len(string)], match)
    else :
        return False
main()
year=int(input("Please enter a year: "))
def main() :
    print(year,"is a leap year: ", isLeapYear(year))

def isLeapYear(n) :
    if n > 1582 and year % 400 == 0 :
        return True
    if n > 1582 and year % 100 == 0 : 
        return False
    if n % 4 == 0 :
        return True
    return False
main()
import sys
inputFile = sys.argv[1]
inp = open(inputFile, "r")
lines = inp.readlines()
inp.close()
outputFile = sys.argv[2]
out = open(outputFile, "w")
for i in range(len(lines) - 1, -1, -1) :
    out.write(lines[i])
out.close()
import sys
from sys import exit
def main() :
    if len(sys.argv) != 5 :
        exit("Cipher requires 4 command line parameters")
    keyword = Remove(Get())  
    keyword = keyword.upper()
    inname = sys.argv[3]
    inf = open(inname, "r")
    outname = sys.argv[4]
    outf = open(outname, "w")
    for x in "ZYXWVUTSRQPONMLKJIHGFEDCBA" :
        if x not in keyword :
            keyword = keyword + x
    if "-e" in sys.argv :
        for line in inf :
            for x in line :
                pos = -1
                if x >= "A" and x <= "Z" :
                    pos = ord(x) - ord("A")
                    outf.write(keyword[pos])
                elif x >= "a" and x <= "z" :
                    pos = ord(x) - ord("a")
                    outf.write(keyword[pos].lower())
                else :
                    outf.write(x)
    elif "-d" in sys.argv :
        for line in inf :
            for x in line :
                if x in keyword :
                    x = chr(ord("A") + keyword.index(x))
                elif x in keyword.lower() :
                    x = chr(ord("a") + keyword.lower().index(x))
                outf.write(x)
    else :
        exit("Either -d or -e must be provided for decrypt or encrypt.")
    inf.close()
    outf.close()

def Remove(s) :
    y = ""
    for x in s :
        if x not in y :
            y = y + x
    return y
def Get() :
    for a in sys.argv :
        if a[0 : 2] == "-k" :
            return a[2 : ]
    exit("A keyword must be provided with -kKEYWORD")

main()
from math import pi, sqrt

def sphereVolume(r) :
   return 4 / 3 * pi * r ** 3

def sphereSurface(r) :
   return 4 * pi * r ** 2

def cylinderVolume(r, h) :
   return pi * r ** 2 * h

def cylinderSurface(r, h) :
   return 2 * (pi * r ** 2 + pi * r * h)

def coneVolume(r, h) :
   return 1 / 3 * pi * r * r * h

def coneSurface(r, h) :
   s = sqrt(h * h + r * r)
   return pi * r * s + pi * r * r

from math import pi, sqrt
from geometry import sphereVolume, sphereSurface, cylinderVolume, cylinderSurface, coneVolume, coneSurface

r = float(input("Enter the radius: "))
h = float(input("Enter the height: "))
print("A sphere has volume:", sphereVolume(r))
print("A sphere has surface area:", sphereSurface(r))
print("A cylinder has volume:", cylinderVolume(r, h))
print("A cylinder has surface area:", cylinderSurface(r, h))
print("A cone has volume:", coneVolume(r, h))
print("A cone has surface area:", coneSurface(r, h))




